{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"D-FAST Bank Erosion","text":"<p>This is one of the Deltares Fluvial Assessment Tools to be used in conjunction with D-Flow FM. The purpose of this particular tool is * to compute local bank erosion sensitivity, and * to give an estimate of the amount of bank material that will be eroded     * during the first year, and     * until equilibrium.</p> <p>The user should carry out a number of steady state hydrodynamic simulations for different discharges using D-Flow FM. The results of these simulations will be combined with some basic morphological characteristics to estimate the bank erosion. For more details see the documentation section.</p>"},{"location":"index.html#license","title":"License","text":"<p>This software is distributed under the terms of the GNU Lesser General Public License Version 2.1. See the license file for details.</p>"},{"location":"change-log.html","title":"Release Notes","text":""},{"location":"change-log.html#231-2025-01-","title":"2.3.1 (2025-01-**)","text":""},{"location":"change-log.html#initial-design","title":"Initial Design","text":"<ul> <li>Initial design of the core library</li> </ul>"},{"location":"license.html","title":"License","text":""},{"location":"license.html#gnu-lesser-general-public-license","title":"GNU LESSER GENERAL PUBLIC LICENSE","text":"<p>Version 2.1, February 1999</p> <pre><code>Copyright (C) 1991, 1999 Free Software Foundation, Inc.\n51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nEveryone is permitted to copy and distribute verbatim copies\nof this license document, but changing it is not allowed.\n\n[This is the first released version of the Lesser GPL.  It also counts\n as the successor of the GNU Library Public License, version 2, hence\n the version number 2.1.]\n</code></pre>"},{"location":"license.html#preamble","title":"Preamble","text":"<p>The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public Licenses are intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users.</p> <p>This license, the Lesser General Public License, applies to some specially designated software packages--typically libraries--of the Free Software Foundation and other authors who decide to use it. You can use it too, but we suggest you first think carefully about whether this license or the ordinary General Public License is the better strategy to use in any particular case, based on the explanations below.</p> <p>When we speak of free software, we are referring to freedom of use, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish); that you receive source code or can get it if you want it; that you can change the software and use pieces of it in new free programs; and that you are informed that you can do these things.</p> <p>To protect your rights, we need to make restrictions that forbid distributors to deny you these rights or to ask you to surrender these rights. These restrictions translate to certain responsibilities for you if you distribute copies of the library or if you modify it.</p> <p>For example, if you distribute copies of the library, whether gratis or for a fee, you must give the recipients all the rights that we gave you. You must make sure that they, too, receive or can get the source code. If you link other code with the library, you must provide complete object files to the recipients, so that they can relink them with the library after making changes to the library and recompiling it. And you must show them these terms so they know their rights.</p> <p>We protect your rights with a two-step method: (1) we copyright the library, and (2) we offer you this license, which gives you legal permission to copy, distribute and/or modify the library.</p> <p>To protect each distributor, we want to make it very clear that there is no warranty for the free library. Also, if the library is modified by someone else and passed on, the recipients should know that what they have is not the original version, so that the original author's reputation will not be affected by problems that might be introduced by others.</p> <p>Finally, software patents pose a constant threat to the existence of any free program. We wish to make sure that a company cannot effectively restrict the users of a free program by obtaining a restrictive license from a patent holder. Therefore, we insist that any patent license obtained for a version of the library must be consistent with the full freedom of use specified in this license.</p> <p>Most GNU software, including some libraries, is covered by the ordinary GNU General Public License. This license, the GNU Lesser General Public License, applies to certain designated libraries, and is quite different from the ordinary General Public License. We use this license for certain libraries in order to permit linking those libraries into non-free programs.</p> <p>When a program is linked with a library, whether statically or using a shared library, the combination of the two is legally speaking a combined work, a derivative of the original library. The ordinary General Public License therefore permits such linking only if the entire combination fits its criteria of freedom. The Lesser General Public License permits more lax criteria for linking other code with the library.</p> <p>We call this license the \"Lesser\" General Public License because it does Less to protect the user's freedom than the ordinary General Public License. It also provides other free software developers Less of an advantage over competing non-free programs. These disadvantages are the reason we use the ordinary General Public License for many libraries. However, the Lesser license provides advantages in certain special circumstances.</p> <p>For example, on rare occasions, there may be a special need to encourage the widest possible use of a certain library, so that it becomes a de-facto standard. To achieve this, non-free programs must be allowed to use the library. A more frequent case is that a free library does the same job as widely used non-free libraries. In this case, there is little to gain by limiting the free library to free software only, so we use the Lesser General Public License.</p> <p>In other cases, permission to use a particular library in non-free programs enables a greater number of people to use a large body of free software. For example, permission to use the GNU C Library in non-free programs enables many more people to use the whole GNU operating system, as well as its variant, the GNU/Linux operating system.</p> <p>Although the Lesser General Public License is Less protective of the users' freedom, it does ensure that the user of a program that is linked with the Library has the freedom and the wherewithal to run that program using a modified version of the Library.</p> <p>The precise terms and conditions for copying, distribution and modification follow. Pay close attention to the difference between a \"work based on the library\" and a \"work that uses the library\". The former contains code derived from the library, whereas the latter must be combined with the library in order to run.</p>"},{"location":"license.html#terms-and-conditions-for-copying-distribution-and-modification","title":"TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION","text":"<p>0. This License Agreement applies to any software library or other program which contains a notice placed by the copyright holder or other authorized party saying it may be distributed under the terms of this Lesser General Public License (also called \"this License\"). Each licensee is addressed as \"you\".</p> <p>A \"library\" means a collection of software functions and/or data prepared so as to be conveniently linked with application programs (which use some of those functions and data) to form executables.</p> <p>The \"Library\", below, refers to any such software library or work which has been distributed under these terms. A \"work based on the Library\" means either the Library or any derivative work under copyright law: that is to say, a work containing the Library or a portion of it, either verbatim or with modifications and/or translated straightforwardly into another language. (Hereinafter, translation is included without limitation in the term \"modification\".)</p> <p>\"Source code\" for a work means the preferred form of the work for making modifications to it. For a library, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the library.</p> <p>Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running a program using the Library is not restricted, and output from such a program is covered only if its contents constitute a work based on the Library (independent of the use of the Library in a tool for writing it). Whether that is true depends on what the Library does and what the program that uses the Library does.</p> <p>1. You may copy and distribute verbatim copies of the Library's complete source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and distribute a copy of this License along with the Library.</p> <p>You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee.</p> <p>2. You may modify your copy or copies of the Library or any portion of it, thus forming a work based on the Library, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions:</p> <ul> <li>a) The modified work must itself be a software library.</li> <li>b) You must cause the files modified to carry prominent     notices stating that you changed the files and the date of     any change.</li> <li>c) You must cause the whole of the work to be licensed at no     charge to all third parties under the terms of this License.</li> <li> <p>d) If a facility in the modified Library refers to a function     or a table of data to be supplied by an application program that     uses the facility, other than as an argument passed when the     facility is invoked, then you must make a good faith effort to     ensure that, in the event an application does not supply such     function or table, the facility still operates, and performs     whatever part of its purpose remains meaningful.</p> <p>(For example, a function in a library to compute square roots has a purpose that is entirely well-defined independent of the application. Therefore, Subsection 2d requires that any application-supplied function or table used by this function must be optional: if the application does not supply it, the square root function must still compute square roots.)</p> </li> </ul> <p>These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Library, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Library, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it.</p> <p>Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Library.</p> <p>In addition, mere aggregation of another work not based on the Library with the Library (or with a work based on the Library) on a volume of a storage or distribution medium does not bring the other work under the scope of this License.</p> <p>3. You may opt to apply the terms of the ordinary GNU General Public License instead of this License to a given copy of the Library. To do this, you must alter all the notices that refer to this License, so that they refer to the ordinary GNU General Public License, version 2, instead of to this License. (If a newer version than version 2 of the ordinary GNU General Public License has appeared, then you can specify that version instead if you wish.) Do not make any other change in these notices.</p> <p>Once this change is made in a given copy, it is irreversible for that copy, so the ordinary GNU General Public License applies to all subsequent copies and derivative works made from that copy.</p> <p>This option is useful when you wish to copy part of the code of the Library into a program that is not a library.</p> <p>4. You may copy and distribute the Library (or a portion or derivative of it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange.</p> <p>If distribution of object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place satisfies the requirement to distribute the source code, even though third parties are not compelled to copy the source along with the object code.</p> <p>5. A program that contains no derivative of any portion of the Library, but is designed to work with the Library by being compiled or linked with it, is called a \"work that uses the Library\". Such a work, in isolation, is not a derivative work of the Library, and therefore falls outside the scope of this License.</p> <p>However, linking a \"work that uses the Library\" with the Library creates an executable that is a derivative of the Library (because it contains portions of the Library), rather than a \"work that uses the library\". The executable is therefore covered by this License. Section 6 states terms for distribution of such executables.</p> <p>When a \"work that uses the Library\" uses material from a header file that is part of the Library, the object code for the work may be a derivative work of the Library even though the source code is not. Whether this is true is especially significant if the work can be linked without the Library, or if the work is itself a library. The threshold for this to be true is not precisely defined by law.</p> <p>If such an object file uses only numerical parameters, data structure layouts and accessors, and small macros and small inline functions (ten lines or less in length), then the use of the object file is unrestricted, regardless of whether it is legally a derivative work. (Executables containing this object code plus portions of the Library will still fall under Section 6.)</p> <p>Otherwise, if the work is a derivative of the Library, you may distribute the object code for the work under the terms of Section 6. Any executables containing that work also fall under Section 6, whether or not they are linked directly with the Library itself.</p> <p>6. As an exception to the Sections above, you may also combine or link a \"work that uses the Library\" with the Library to produce a work containing portions of the Library, and distribute that work under terms of your choice, provided that the terms permit modification of the work for the customer's own use and reverse engineering for debugging such modifications.</p> <p>You must give prominent notice with each copy of the work that the Library is used in it and that the Library and its use are covered by this License. You must supply a copy of this License. If the work during execution displays copyright notices, you must include the copyright notice for the Library among them, as well as a reference directing the user to the copy of this License. Also, you must do one of these things:</p> <ul> <li>a) Accompany the work with the complete corresponding     machine-readable source code for the Library including whatever     changes were used in the work (which must be distributed under     Sections 1 and 2 above); and, if the work is an executable linked     with the Library, with the complete machine-readable \"work that     uses the Library\", as object code and/or source code, so that the     user can modify the Library and then relink to produce a modified     executable containing the modified Library. (It is understood that     the user who changes the contents of definitions files in the     Library will not necessarily be able to recompile the application     to use the modified definitions.)</li> <li>b) Use a suitable shared library mechanism for linking with     the Library. A suitable mechanism is one that (1) uses at run time     a copy of the library already present on the user's computer     system, rather than copying library functions into the executable,     and (2) will operate properly with a modified version of the     library, if the user installs one, as long as the modified version     is interface-compatible with the version that the work was     made with.</li> <li>c) Accompany the work with a written offer, valid for at least     three years, to give the same user the materials specified in     Subsection 6a, above, for a charge no more than the cost of     performing this distribution.</li> <li>d) If distribution of the work is made by offering access to     copy from a designated place, offer equivalent access to copy the     above specified materials from the same place.</li> <li>e) Verify that the user has already received a copy of these     materials or that you have already sent this user a copy.</li> </ul> <p>For an executable, the required form of the \"work that uses the Library\" must include any data and utility programs needed for reproducing the executable from it. However, as a special exception, the materials to be distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable.</p> <p>It may happen that this requirement contradicts the license restrictions of other proprietary libraries that do not normally accompany the operating system. Such a contradiction means you cannot use both them and the Library together in an executable that you distribute.</p> <p>7. You may place library facilities that are a work based on the Library side-by-side in a single library together with other library facilities not covered by this License, and distribute such a combined library, provided that the separate distribution of the work based on the Library and of the other library facilities is otherwise permitted, and provided that you do these two things:</p> <ul> <li>a) Accompany the combined library with a copy of the same work     based on the Library, uncombined with any other     library facilities. This must be distributed under the terms of     the Sections above.</li> <li>b) Give prominent notice with the combined library of the fact     that part of it is a work based on the Library, and explaining     where to find the accompanying uncombined form of the same work.</li> </ul> <p>8. You may not copy, modify, sublicense, link with, or distribute the Library except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, link with, or distribute the Library is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance.</p> <p>9. You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Library or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Library (or any work based on the Library), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Library or works based on it.</p> <p>10. Each time you redistribute the Library (or any work based on the Library), the recipient automatically receives a license from the original licensor to copy, distribute, link with or modify the Library subject to these terms and conditions. You may not impose any further restrictions on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties with this License.</p> <p>11. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Library at all. For example, if a patent license would not permit royalty-free redistribution of the Library by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Library.</p> <p>If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply, and the section as a whole is intended to apply in other circumstances.</p> <p>It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice.</p> <p>This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License.</p> <p>12. If the distribution and/or use of the Library is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Library under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License.</p> <p>13. The Free Software Foundation may publish revised and/or new versions of the Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.</p> <p>Each version is given a distinguishing version number. If the Library specifies a version number of this License which applies to it and \"any later version\", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Library does not specify a license version number, you may choose any version ever published by the Free Software Foundation.</p> <p>14. If you wish to incorporate parts of the Library into other free programs whose distribution conditions are incompatible with these, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally.</p> <p>NO WARRANTY</p> <p>15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE LIBRARY \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE LIBRARY IS WITH YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</p> <p>16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p>"},{"location":"license.html#end-of-terms-and-conditions","title":"END OF TERMS AND CONDITIONS","text":""},{"location":"license.html#how-to-apply-these-terms-to-your-new-libraries","title":"How to Apply These Terms to Your New Libraries","text":"<p>If you develop a new library, and you want it to be of the greatest possible use to the public, we recommend making it free software that everyone can redistribute and change. You can do so by permitting redistribution under these terms (or, alternatively, under the terms of the ordinary General Public License).</p> <p>To apply these terms, attach the following notices to the library. It is safest to attach them to the start of each source file to most effectively convey the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found.</p> <pre><code>one line to give the library's name and an idea of what it does.\nCopyright (C) year  name of author\n\nThis library is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense as published by the Free Software Foundation; either\nversion 2.1 of the License, or (at your option) any later version.\n\nThis library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public\nLicense along with this library; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n</code></pre> <p>Also add information on how to contact you by electronic and paper mail.</p> <p>You should also get your employer (if you work as a programmer) or your school, if any, to sign a \"copyright disclaimer\" for the library, if necessary. Here is a sample; alter the names:</p> <pre><code>Yoyodyne, Inc., hereby disclaims all copyright interest in\nthe library `Frob' (a library for tweaking knobs) written\nby James Random Hacker.\n\nsignature of Ty Coon, 1 April 1990\nTy Coon, President of Vice\n</code></pre> <p>That's all there is to it!</p>"},{"location":"api/bank_erosion.html","title":"bank_erosion","text":""},{"location":"api/bank_erosion.html#bank-erosion","title":"Bank Erosion","text":""},{"location":"api/bank_erosion.html#dfastbe.bank_erosion","title":"<code>dfastbe.bank_erosion</code>","text":"<p>Copyright (C) 2020 Stichting Deltares.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation version 2.1.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, see http://www.gnu.org/licenses/.</p> <p>contact: delft3d.support@deltares.nl Stichting Deltares P.O. Box 177 2600 MH Delft, The Netherlands</p> <p>All indications and logos of, and references to, \"Delft3D\" and \"Deltares\" are registered trademarks of Stichting Deltares, and remain the property of Stichting Deltares. All rights reserved.</p> <p>INFORMATION This file is part of D-FAST Bank Erosion: https://github.com/Deltares/D-FAST_Bank_Erosion</p>"},{"location":"api/bank_erosion.html#dfastbe.bank_erosion.BankLinesResultsError","title":"<code>BankLinesResultsError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for BankLine results errors.</p> Source code in <code>src/dfastbe/bank_erosion.py</code> <pre><code>class BankLinesResultsError(Exception):\n    \"\"\"Custom exception for BankLine results errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/bank_erosion.html#dfastbe.bank_erosion.Erosion","title":"<code>Erosion</code>","text":"Source code in <code>src/dfastbe/bank_erosion.py</code> <pre><code>class Erosion:\n    def __init__(self, config_file: ConfigFile, gui: bool = False):\n        self.root_dir = config_file.root_dir\n        self._config_file = config_file\n        self.gui = gui\n        self.bank_dir = self._get_bank_line_dir()\n        self.output_dir = config_file.get_output_dir(\"erosion\")\n        # check if additional debug output is requested\n        self.debug = config_file.get_bool(\"General\", \"DebugOutput\", False)\n        # set plotting flags\n        self.plot_flags = config_file.get_plotting_flags(self.root_dir)\n        self.river_data = RiverData(config_file)\n\n        # get filter settings for bank levels and flow velocities along banks\n        self.zb_dx = config_file.get_float(\"Erosion\", \"BedFilterDist\", 0.0, positive=True)\n        self.vel_dx = config_file.get_float(\"Erosion\", \"VelFilterDist\", 0.0, positive=True)\n        log_text(\"get_levels\")\n        self.num_levels = config_file.get_int(\"Erosion\", \"NLevel\")\n        self.ref_level = config_file.get_int(\"Erosion\", \"RefLevel\") - 1\n        self.sim_files, self.p_discharge = self.get_sim_data()\n\n    @property\n    def config_file(self) -&gt; ConfigFile:\n        \"\"\"Configuration file object.\"\"\"\n        return self._config_file\n\n    def _get_bank_line_dir(self) -&gt; Path:\n        bank_dir = self.config_file.get_str(\"General\", \"BankDir\")\n        log_text(\"bankdir_in\", data={\"dir\": bank_dir})\n        bank_dir = Path(bank_dir)\n        if not bank_dir.exists():\n            log_text(\"missing_dir\", data={\"dir\": bank_dir})\n            raise BankLinesResultsError(\n                f\"Required bank line directory:{bank_dir} does not exist. please use the banklines command to run the \"\n                \"bankline detection tool first it.\"\n            )\n        else:\n            return bank_dir\n\n    def get_ship_parameters(self, bank_km_mid) -&gt; Dict[str, float]:\n\n        ship_relative_velocity = self.config_file.get_parameter(\n            \"Erosion\", \"VShip\", bank_km_mid, positive=True, onefile=True\n        )\n        num_ships_year = self.config_file.get_parameter(\n            \"Erosion\", \"NShip\", bank_km_mid, positive=True, onefile=True\n        )\n        num_waves_p_ship = self.config_file.get_parameter(\n            \"Erosion\", \"NWave\", bank_km_mid, default=5, positive=True, onefile=True\n        )\n        ship_draught = self.config_file.get_parameter(\n            \"Erosion\", \"Draught\", bank_km_mid, positive=True, onefile=True\n        )\n        ship_type = self.config_file.get_parameter(\n            \"Erosion\", \"ShipType\", bank_km_mid, valid=[1, 2, 3], onefile=True\n        )\n        parslope0 = self.config_file.get_parameter(\n            \"Erosion\", \"Slope\", bank_km_mid, default=20, positive=True, ext=\"slp\"\n        )\n        reed_wave_damping_coeff = self.config_file.get_parameter(\n            \"Erosion\", \"Reed\", bank_km_mid, default=0, positive=True, ext=\"rdd\"\n        )\n\n        ship_data = {\n            \"vship0\": ship_relative_velocity,\n            \"Nship0\": num_ships_year,\n            \"nwave0\": num_waves_p_ship,\n            \"Tship0\": ship_draught,\n            \"ship0\": ship_type,\n            \"parslope0\": parslope0,\n            \"parreed0\": reed_wave_damping_coeff,\n        }\n        return ship_data\n\n    def get_sim_data(self):\n        # get pdischarges\n        sim_files = []\n        p_discharge = []\n        for iq in range(self.num_levels):\n            iq_str = str(iq + 1)\n            sim_files.append(self.config_file.get_sim_file(\"Erosion\", iq_str))\n            p_discharge.append(\n                self.config_file.get_float(\"Erosion\", f\"PDischarge{iq_str}\")\n            )\n        return sim_files, p_discharge\n\n    def intersect_bank_lines_with_mesh(\n        self,\n        config_file: ConfigFile,\n        stations_coords: np.ndarray,\n        mesh_data: MeshData,\n    ) -&gt; BankData:\n        bank_lines = config_file.get_bank_lines(str(self.bank_dir))\n        n_bank_lines = len(bank_lines)\n\n        bank_line_coords = []\n        bank_face_indices = []\n        for bank_index in range(n_bank_lines):\n            line_coords = np.array(bank_lines.geometry[bank_index].coords)\n            log_text(\"bank_nodes\", data={\"ib\": bank_index + 1, \"n\": len(line_coords)})\n\n            coords_along_bank, face_indices = intersect_line_mesh(\n                line_coords, mesh_data\n            )\n            bank_line_coords.append(coords_along_bank)\n            bank_face_indices.append(face_indices)\n\n        # linking bank lines to chainage\n        log_text(\"chainage_to_banks\")\n        bank_chainage_midpoints = [None] * n_bank_lines\n        is_right_bank = [True] * n_bank_lines\n        for bank_index, coords in enumerate(bank_line_coords):\n            segment_mid_points = (coords[:-1, :] + coords[1:, :]) / 2\n            chainage_mid_points = project_km_on_line(segment_mid_points, self.river_data.masked_profile_arr)\n\n            # check if bank line is defined from low chainage to high chainage\n            if chainage_mid_points[0] &gt; chainage_mid_points[-1]:\n                # if not, flip the bank line and all associated data\n                chainage_mid_points = chainage_mid_points[::-1]\n                bank_line_coords[bank_index] = bank_line_coords[bank_index][::-1, :]\n                bank_face_indices[bank_index] = bank_face_indices[bank_index][::-1]\n\n            bank_chainage_midpoints[bank_index] = chainage_mid_points\n\n            # check if bank line is left or right bank\n            # when looking from low to high chainage\n            is_right_bank[bank_index] = on_right_side(coords, stations_coords)\n            if is_right_bank[bank_index]:\n                log_text(\"right_side_bank\", data={\"ib\": bank_index + 1})\n            else:\n                log_text(\"left_side_bank\", data={\"ib\": bank_index + 1})\n\n        return BankData(\n            bank_line_coords=bank_line_coords,\n            bank_face_indices=bank_face_indices,\n            bank_chainage_midpoints=bank_chainage_midpoints,\n            is_right_bank=is_right_bank,\n            bank_lines=bank_lines,\n            n_bank_lines=n_bank_lines,\n        )\n\n    def _prepare_river_axis(\n        self, stations_coords: np.ndarray, config_file: ConfigFile\n    ) -&gt; Tuple[np.ndarray, np.ndarray, LineString]:\n        # read river axis file\n        river_axis = self.river_data.read_river_axis()\n        river_axis_numpy = np.array(river_axis.coords)\n        # optional sorting --&gt; see 04_Waal_D3D example\n        # check: sum all distances and determine maximum distance ...\n        # if maximum &gt; alpha * sum then perform sort\n        # Waal OK: 0.0082 ratio max/sum, Waal NotOK: 0.13 - Waal: 2500 points,\n        # so even when OK still some 21 times more than 1/2500 = 0.0004\n        dist2 = (np.diff(river_axis_numpy, axis=0) ** 2).sum(axis=1)\n        alpha = dist2.max() / dist2.sum()\n        if alpha &gt; 0.03:\n            print(\"The river axis needs sorting!!\")\n\n        # map km to axis points, further using axis\n        log_text(\"chainage_to_axis\")\n        river_axis_km = project_km_on_line(river_axis_numpy, self.river_data.masked_profile_arr)\n        write_shp_pnt(\n            river_axis_numpy,\n            {\"chainage\": river_axis_km},\n            f\"{str(self.output_dir)}{os.sep}river_axis_chainage.shp\",\n            config_file,\n        )\n\n        # clip river axis to reach of interest\n        i1 = np.argmin(((stations_coords[0] - river_axis_numpy) ** 2).sum(axis=1))\n        i2 = np.argmin(((stations_coords[-1] - river_axis_numpy) ** 2).sum(axis=1))\n        if i1 &lt; i2:\n            river_axis_km = river_axis_km[i1 : i2 + 1]\n            river_axis_numpy = river_axis_numpy[i1 : i2 + 1]\n        else:\n            # reverse river axis\n            river_axis_km = river_axis_km[i2 : i1 + 1][::-1]\n            river_axis_numpy = river_axis_numpy[i2 : i1 + 1][::-1]\n        river_axis = LineString(river_axis_numpy)\n\n        return river_axis_km, river_axis_numpy, river_axis\n\n    def _prepare_fairway(\n        self,\n        river_axis: LineString,\n        stations_coords: np.ndarray,\n        mesh_data: MeshData,\n        config_file: ConfigFile,\n    ):\n        # read fairway file\n        fairway_file = self.config_file.get_str(\"Erosion\", \"Fairway\")\n        log_text(\"read_fairway\", data={\"file\": fairway_file})\n\n        # map km to fairway points, further using axis\n        log_text(\"chainage_to_fairway\")\n        fairway_numpy = np.array(river_axis.coords)\n        fairway_km = project_km_on_line(fairway_numpy, self.river_data.masked_profile_arr)\n        write_shp_pnt(\n            fairway_numpy,\n            {\"chainage\": fairway_km},\n            str(self.output_dir) + os.sep + \"fairway_chainage.shp\",\n            config_file,\n        )\n\n        # clip fairway to reach of interest\n        i1 = np.argmin(((stations_coords[0] - fairway_numpy) ** 2).sum(axis=1))\n        i2 = np.argmin(((stations_coords[-1] - fairway_numpy) ** 2).sum(axis=1))\n        if i1 &lt; i2:\n            fairway_numpy = fairway_numpy[i1 : i2 + 1]\n        else:\n            # reverse fairway\n            fairway_numpy = fairway_numpy[i2 : i1 + 1][::-1]\n\n        # intersect fairway and mesh\n        log_text(\"intersect_fairway_mesh\", data={\"n\": len(fairway_numpy)})\n        fairway_intersection_coords, fairway_face_indices = intersect_line_mesh(\n            fairway_numpy, mesh_data\n        )\n        if self.debug:\n            write_shp_pnt(\n                (fairway_intersection_coords[:-1] + fairway_intersection_coords[1:])\n                / 2,\n                {\"iface\": fairway_face_indices},\n                f\"{str(self.output_dir)}{os.sep}fairway_face_indices.shp\",\n                config_file,\n            )\n\n        return FairwayData(fairway_face_indices, fairway_intersection_coords)\n\n    def _map_bank_to_fairway(\n        self, bank_data: BankData, fairway_data: FairwayData, sim: SimulationObject, config_file: ConfigFile\n    ):\n        # distance fairway-bankline (bankfairway)\n        log_text(\"bank_distance_fairway\")\n        distance_fw = []\n        bp_fw_face_idx = []\n        nfw = len(fairway_data.fairway_face_indices)\n        for ib, bcrds in enumerate(bank_data.bank_line_coords):\n            bcrds_mid = (bcrds[:-1] + bcrds[1:]) / 2\n            distance_fw.append(np.zeros(len(bcrds_mid)))\n            bp_fw_face_idx.append(np.zeros(len(bcrds_mid), dtype=int))\n            for ip, bp in enumerate(bcrds_mid):\n                # find closest fairway support node\n                ifw = np.argmin(\n                    ((bp - fairway_data.intersection_coords) ** 2).sum(axis=1)\n                )\n                fwp = fairway_data.intersection_coords[ifw]\n                dbfw = ((bp - fwp) ** 2).sum() ** 0.5\n                # If fairway support node is also the closest projected fairway point, then it likely\n                # that that point is one of the original support points (a corner) of the fairway path\n                # and located inside a grid cell. The segments before and after that point will then\n                # both be located inside that same grid cell, so let's pick the segment before the point.\n                # If the point happens to coincide with a grid edge and the two segments are located\n                # in different grid cells, then we could either simply choose one or add complexity to\n                # average the values of the two grid cells. Let's go for the simplest approach ...\n                iseg = max(ifw - 1, 0)\n                if ifw &gt; 0:\n                    alpha = (\n                        (\n                            fairway_data.intersection_coords[ifw, 0]\n                            - fairway_data.intersection_coords[ifw - 1, 0]\n                        )\n                        * (bp[0] - fairway_data.intersection_coords[ifw - 1, 0])\n                        + (\n                            fairway_data.intersection_coords[ifw, 1]\n                            - fairway_data.intersection_coords[ifw - 1, 1]\n                        )\n                        * (bp[1] - fairway_data.intersection_coords[ifw - 1, 1])\n                    ) / (\n                        (\n                            fairway_data.intersection_coords[ifw, 0]\n                            - fairway_data.intersection_coords[ifw - 1, 0]\n                        )\n                        ** 2\n                        + (\n                            fairway_data.intersection_coords[ifw, 1]\n                            - fairway_data.intersection_coords[ifw - 1, 1]\n                        )\n                        ** 2\n                    )\n                    if alpha &gt; 0 and alpha &lt; 1:\n                        fwp1 = fairway_data.intersection_coords[ifw - 1] + alpha * (\n                            fairway_data.intersection_coords[ifw]\n                            - fairway_data.intersection_coords[ifw - 1]\n                        )\n                        d1 = ((bp - fwp1) ** 2).sum() ** 0.5\n                        if d1 &lt; dbfw:\n                            dbfw = d1\n                            # projected point located on segment before, which corresponds to initial choice: iseg = ifw - 1\n                if ifw &lt; nfw:\n                    alpha = (\n                        (\n                            fairway_data.intersection_coords[ifw + 1, 0]\n                            - fairway_data.intersection_coords[ifw, 0]\n                        )\n                        * (bp[0] - fairway_data.intersection_coords[ifw, 0])\n                        + (\n                            fairway_data.intersection_coords[ifw + 1, 1]\n                            - fairway_data.intersection_coords[ifw, 1]\n                        )\n                        * (bp[1] - fairway_data.intersection_coords[ifw, 1])\n                    ) / (\n                        (\n                            fairway_data.intersection_coords[ifw + 1, 0]\n                            - fairway_data.intersection_coords[ifw, 0]\n                        )\n                        ** 2\n                        + (\n                            fairway_data.intersection_coords[ifw + 1, 1]\n                            - fairway_data.intersection_coords[ifw, 1]\n                        )\n                        ** 2\n                    )\n                    if alpha &gt; 0 and alpha &lt; 1:\n                        fwp1 = fairway_data.intersection_coords[ifw] + alpha * (\n                            fairway_data.intersection_coords[ifw + 1]\n                            - fairway_data.intersection_coords[ifw]\n                        )\n                        d1 = ((bp - fwp1) ** 2).sum() ** 0.5\n                        if d1 &lt; dbfw:\n                            dbfw = d1\n                            iseg = ifw\n\n                bp_fw_face_idx[ib][ip] = fairway_data.fairway_face_indices[iseg]\n                distance_fw[ib][ip] = dbfw\n\n            if self.debug:\n                write_shp_pnt(\n                    bcrds_mid,\n                    {\n                        \"chainage\": bank_data.bank_chainage_midpoints[ib],\n                        \"iface_fw\": bp_fw_face_idx[ib],\n                    },\n                    f\"{self.output_dir}/bank_{ib + 1}_chainage_and_fairway_face_idx.shp\",\n                    config_file,\n                )\n\n        bank_data.fairway_face_indices = bp_fw_face_idx\n        bank_data.fairway_distances = distance_fw\n\n        # water level at fairway\n        zfw_ini = []\n        for ib in range(bank_data.n_bank_lines):\n            ii = bank_data.fairway_face_indices[ib]\n            zfw_ini.append(sim[\"zw_face\"][ii])\n        fairway_data.fairway_initial_water_levels = zfw_ini\n\n    def _prepare_initial_conditions(\n        self, config_file: ConfigFile, bank_data: BankData, fairway_data: FairwayData\n    ) -&gt; ErosionInputs:\n        # wave reduction s0, s1\n        wave_fairway_distance_0 = config_file.get_parameter(\n            \"Erosion\",\n            \"Wave0\",\n            bank_data.bank_chainage_midpoints,\n            default=200,\n            positive=True,\n            onefile=True,\n        )\n        wave_fairway_distance_1 = config_file.get_parameter(\n            \"Erosion\",\n            \"Wave1\",\n            bank_data.bank_chainage_midpoints,\n            default=150,\n            positive=True,\n            onefile=True,\n        )\n\n        # save 1_banklines\n        # read vship, nship, nwave, draught (tship), shiptype ... independent of level number\n        shipping_data = self.get_ship_parameters(bank_data.bank_chainage_midpoints)\n\n        # read classes flag (yes: banktype = taucp, no: banktype = tauc) and banktype (taucp: 0-4 ... or ... tauc = critical shear value)\n        classes = config_file.get_bool(\"Erosion\", \"Classes\")\n        if classes:\n            bank_type = config_file.get_parameter(\n                \"Erosion\",\n                \"BankType\",\n                bank_data.bank_chainage_midpoints,\n                default=0,\n                ext=\".btp\",\n            )\n            tauc = []\n            for bank in bank_type:\n                tauc.append(ErosionInputs.taucls[bank])\n        else:\n            tauc = config_file.get_parameter(\n                \"Erosion\",\n                \"BankType\",\n                bank_data.bank_chainage_midpoints,\n                default=0,\n                ext=\".btp\",\n            )\n            thr = (ErosionInputs.taucls[:-1] + ErosionInputs.taucls[1:]) / 2\n            bank_type = [None] * len(thr)\n            for ib, shear_stress in enumerate(tauc):\n                bt = np.zeros(shear_stress.size)\n                for thr_i in thr:\n                    bt[shear_stress &lt; thr_i] += 1\n                bank_type[ib] = bt\n\n        # read bank protection level zss\n        zss_miss = -1000\n        zss = config_file.get_parameter(\n            \"Erosion\",\n            \"ProtectionLevel\",\n            bank_data.bank_chainage_midpoints,\n            default=zss_miss,\n            ext=\".bpl\",\n        )\n        # if zss undefined, set zss equal to zfw_ini - 1\n        for ib, one_zss in enumerate(zss):\n            mask = one_zss == zss_miss\n            one_zss[mask] = fairway_data.fairway_initial_water_levels[ib][mask] - 1\n\n        return ErosionInputs(\n            shipping_data=shipping_data,\n            wave_fairway_distance_0=wave_fairway_distance_0,\n            wave_fairway_distance_1=wave_fairway_distance_1,\n            bank_protection_level=zss,\n            tauc=tauc,\n            bank_type=bank_type,\n        )\n\n    def _process_discharge_levels(\n        self,\n        km_mid,\n        km_bin,\n        config_file: ConfigFile,\n        erosion_inputs: ErosionInputs,\n        bank_data: BankData,\n        fairway_data: FairwayData,\n    ) -&gt; Tuple[\n        WaterLevelData,\n        ErosionResults,\n    ]:\n        # initialize arrays for erosion loop over all discharges\n        velocity: List[List[np.ndarray]] = []\n        bank_height: List[np.ndarray] = []\n        water_level: List[List[np.ndarray]] = []\n        chezy: List[List[np.ndarray]] = []\n        vol_per_discharge: List[List[np.ndarray]] = []\n        ship_wave_max: List[List[np.ndarray]] = []\n        ship_wave_min: List[List[np.ndarray]] = []\n\n        line_size: List[np.ndarray] = []\n        flow_erosion_dist: List[np.ndarray] = []\n        ship_erosion_dist: List[np.ndarray] = []\n        total_erosion_dist: List[np.ndarray] = []\n        total_eroded_vol: List[np.ndarray] = []\n        eq_erosion_dist: List[np.ndarray] = []\n        eq_eroded_vol: List[np.ndarray] = []\n\n        erosion_time = config_file.get_int(\"Erosion\", \"TErosion\", positive=True)\n        log_text(\"total_time\", data={\"t\": erosion_time})\n\n        for iq in range(self.num_levels):\n            log_text(\n                \"discharge_header\",\n                data={\n                    \"i\": iq + 1,\n                    \"p\": self.p_discharge[iq],\n                    \"t\": self.p_discharge[iq] * erosion_time,\n                },\n            )\n\n            iq_str = \"{}\".format(iq + 1)\n\n            log_text(\"read_q_params\", indent=\"  \")\n            # read vship, nship, nwave, draught, shiptype, slope, reed, fairwaydepth, ... (level specific values)\n            vship = config_file.get_parameter(\n                \"Erosion\",\n                f\"VShip{iq_str}\",\n                bank_data.bank_chainage_midpoints,\n                default=erosion_inputs.shipping_data[\"vship0\"],\n                positive=True,\n                onefile=True,\n            )\n            Nship = config_file.get_parameter(\n                \"Erosion\",\n                f\"NShip{iq_str}\",\n                bank_data.bank_chainage_midpoints,\n                default=erosion_inputs.shipping_data[\"Nship0\"],\n                positive=True,\n                onefile=True,\n            )\n            nwave = config_file.get_parameter(\n                \"Erosion\",\n                f\"NWave{iq_str}\",\n                bank_data.bank_chainage_midpoints,\n                default=erosion_inputs.shipping_data[\"nwave0\"],\n                positive=True,\n                onefile=True,\n            )\n            Tship = config_file.get_parameter(\n                \"Erosion\",\n                f\"Draught{iq_str}\",\n                bank_data.bank_chainage_midpoints,\n                default=erosion_inputs.shipping_data[\"Tship0\"],\n                positive=True,\n                onefile=True,\n            )\n            ship_type = config_file.get_parameter(\n                \"Erosion\",\n                f\"ShipType{iq_str}\",\n                bank_data.bank_chainage_midpoints,\n                default=erosion_inputs.shipping_data[\"ship0\"],\n                valid=[1, 2, 3],\n                onefile=True,\n            )\n\n            parslope = config_file.get_parameter(\n                \"Erosion\",\n                f\"Slope{iq_str}\",\n                bank_data.bank_chainage_midpoints,\n                default=erosion_inputs.shipping_data[\"parslope0\"],\n                positive=True,\n                ext=\"slp\",\n            )\n            parreed = config_file.get_parameter(\n                \"Erosion\",\n                f\"Reed{iq_str}\",\n                bank_data.bank_chainage_midpoints,\n                default=erosion_inputs.shipping_data[\"parreed0\"],\n                positive=True,\n                ext=\"rdd\",\n            )\n            mu_slope = [None] * bank_data.n_bank_lines\n            mu_reed = [None] * bank_data.n_bank_lines\n            for ib in range(bank_data.n_bank_lines):\n                mus = parslope[ib].copy()\n                mus[mus &gt; 0] = 1 / mus[mus &gt; 0]\n                mu_slope[ib] = mus\n                mu_reed[ib] = 8.5e-4 * parreed[ib] ** 0.8\n\n            log_text(\"-\", indent=\"  \")\n            log_text(\"read_simdata\", data={\"file\": self.sim_files[iq]}, indent=\"  \")\n            log_text(\"-\", indent=\"  \")\n            sim, _ = read_simulation_data(self.sim_files[iq], indent=\"  \")\n            log_text(\"-\", indent=\"  \")\n            fnc = sim[\"facenode\"]\n\n            log_text(\"bank_erosion\", indent=\"  \")\n            velocity.append([])\n            water_level.append([])\n            chezy.append([])\n            vol_per_discharge.append([])\n            ship_wave_max.append([])\n            ship_wave_min.append([])\n\n            dvol_bank = np.zeros((len(km_mid), bank_data.n_bank_lines))\n            hfw_max = 0\n            for ib, bcrds in enumerate(bank_data.bank_line_coords):\n                # determine velocity along banks ...\n                dx = np.diff(bcrds[:, 0])\n                dy = np.diff(bcrds[:, 1])\n                if iq == 0:\n                    line_size.append(np.sqrt(dx ** 2 + dy ** 2))\n\n                bank_index = bank_data.bank_face_indices[ib]\n                vel_bank = (\n                        np.absolute(\n                            sim[\"ucx_face\"][bank_index] * dx + sim[\"ucy_face\"][bank_index] * dy\n                        )\n                        / line_size[ib]\n                )\n                if self.vel_dx &gt; 0.0:\n                    if ib == 0:\n                        log_text(\n                            \"apply_velocity_filter\", indent=\"  \", data={\"dx\": self.vel_dx}\n                        )\n                    vel_bank = moving_avg(\n                        bank_data.bank_chainage_midpoints[ib], vel_bank, self.vel_dx\n                    )\n                velocity[iq].append(vel_bank)\n                #\n                if iq == 0:\n                    # determine velocity and bankheight along banks ...\n                    # bankheight = maximum bed elevation per cell\n                    if sim[\"zb_location\"] == \"node\":\n                        zb = sim[\"zb_val\"]\n                        zb_all_nodes = _apply_masked_indexing(zb, fnc[bank_index, :])\n                        zb_bank = zb_all_nodes.max(axis=1)\n                        if self.zb_dx &gt; 0.0:\n                            if ib == 0:\n                                log_text(\n                                    \"apply_banklevel_filter\",\n                                    indent=\"  \",\n                                    data={\"dx\": self.zb_dx},\n                                )\n                            zb_bank = moving_avg(\n                                bank_data.bank_chainage_midpoints[ib],\n                                zb_bank,\n                                self.zb_dx,\n                            )\n                        bank_height.append(zb_bank)\n                    else:\n                        # don't know ... need to check neighbouring cells ...\n                        bank_height.append(None)\n\n                # get water depth along fairway\n                ii = bank_data.fairway_face_indices[ib]\n                hfw = sim[\"h_face\"][ii]\n                hfw_max = max(hfw_max, hfw.max())\n                water_level[iq].append(sim[\"zw_face\"][ii])\n                chez = sim[\"chz_face\"][ii]\n                chezy[iq].append(0 * chez + chez.mean())\n\n                if iq == self.num_levels - 1:  # ref_level:\n                    dn_eq1, dv_eq1 = comp_erosion_eq(\n                        bank_height[ib],\n                        line_size[ib],\n                        fairway_data.fairway_initial_water_levels[ib],\n                        vship[ib],\n                        ship_type[ib],\n                        Tship[ib],\n                        mu_slope[ib],\n                        bank_data.fairway_distances[ib],\n                        hfw,\n                        erosion_inputs,\n                        ib,\n                        g,\n                    )\n                    eq_erosion_dist.append(dn_eq1)\n                    eq_eroded_vol.append(dv_eq1)\n\n                    if self.debug:\n                        bcrds_mid = (bcrds[:-1] + bcrds[1:]) / 2\n                        bank_coords_points = [Point(xy1) for xy1 in bcrds_mid]\n                        bank_coords_geo = GeoSeries(\n                            bank_coords_points, crs=config_file.crs\n                        )\n                        params = {\n                            \"chainage\": bank_data.bank_chainage_midpoints[ib],\n                            \"x\": bcrds_mid[:, 0],\n                            \"y\": bcrds_mid[:, 1],\n                            \"iface_fw\": bank_data.fairway_face_indices[ib],\n                            \"iface_bank\": bank_data.bank_face_indices[ib],  # bank_index\n                            \"zb\": bank_height[ib],\n                            \"len\": line_size[ib],\n                            \"zw0\": fairway_data.fairway_initial_water_levels[ib],\n                            \"vship\": vship[ib],\n                            \"shiptype\": ship_type[ib],\n                            \"draught\": Tship[ib],\n                            \"mu_slp\": mu_slope[ib],\n                            \"dist_fw\": bank_data.fairway_distances[ib],\n                            \"dfw0\": erosion_inputs.wave_fairway_distance_0[ib],\n                            \"dfw1\": erosion_inputs.wave_fairway_distance_1[ib],\n                            \"hfw\": hfw,\n                            \"zss\": erosion_inputs.bank_protection_level[ib],\n                            \"dn\": dn_eq1,\n                            \"dv\": dv_eq1,\n                        }\n\n                        write_shp(bank_coords_geo, params, f\"{str(self.output_dir)}{os.sep}debug.EQ.B{ib + 1}.shp\")\n                        write_csv(params, f\"{str(self.output_dir)}{os.sep}debug.EQ.B{ib + 1}.csv\")\n\n                dniqib, dviqib, dn_ship, dn_flow, ship_wave_max_ib, ship_wave_min_ib = (\n                    comp_erosion(\n                        velocity[iq][ib],\n                        bank_height[ib],\n                        line_size[ib],\n                        water_level[iq][ib],\n                        fairway_data.fairway_initial_water_levels[ib],\n                        Nship[ib],\n                        vship[ib],\n                        nwave[ib],\n                        ship_type[ib],\n                        Tship[ib],\n                        erosion_time * self.p_discharge[iq],\n                        mu_slope[ib],\n                        mu_reed[ib],\n                        bank_data.fairway_distances[ib],\n                        hfw,\n                        chezy[iq][ib],\n                        erosion_inputs,\n                        RHO,\n                        g,\n                        ib,\n                    )\n                )\n                ship_wave_max[iq].append(ship_wave_max_ib)\n                ship_wave_min[iq].append(ship_wave_min_ib)\n\n                if self.debug:\n                    bcrds_mid = (bcrds[:-1] + bcrds[1:]) / 2\n\n                    bank_coords_points = [Point(xy1) for xy1 in bcrds_mid]\n                    bank_coords_geo = GeoSeries(bank_coords_points, crs=config_file.crs)\n                    params = {\n                        \"chainage\": bank_data.bank_chainage_midpoints[ib],\n                        \"x\": bcrds_mid[:, 0],\n                        \"y\": bcrds_mid[:, 1],\n                        \"iface_fw\": bank_data.fairway_face_indices[ib],\n                        \"iface_bank\": bank_data.bank_face_indices[ib],  # bank_index\n                        \"u\": velocity[iq][ib],\n                        \"zb\": bank_height[ib],\n                        \"len\": line_size[ib],\n                        \"zw\": water_level[iq][ib],\n                        \"zw0\": fairway_data.fairway_initial_water_levels[ib],\n                        \"tauc\": erosion_inputs.tauc[ib],\n                        \"nship\": Nship[ib],\n                        \"vship\": vship[ib],\n                        \"nwave\": nwave[ib],\n                        \"shiptype\": ship_type[ib],\n                        \"draught\": Tship[ib],\n                        \"mu_slp\": mu_slope[ib],\n                        \"mu_reed\": mu_reed[ib],\n                        \"dist_fw\": bank_data.fairway_distances[ib],\n                        \"dfw0\": erosion_inputs.wave_fairway_distance_0[ib],\n                        \"dfw1\": erosion_inputs.wave_fairway_distance_1[ib],\n                        \"hfw\": hfw,\n                        \"chez\": chezy[iq][ib],\n                        \"zss\": erosion_inputs.bank_protection_level[ib],\n                        \"dn\": dniqib,\n                        \"dv\": dviqib,\n                        \"dnship\": dn_ship,\n                        \"dnflow\": dn_flow,\n                    }\n                    write_shp(bank_coords_geo, params, f\"{str(self.output_dir)}{os.sep}debug.Q{iq + 1}.B{ib + 1}.shp\")\n                    write_csv(params, f\"{str(self.output_dir)}{os.sep}debug.Q{iq + 1}.B{ib + 1}.csv\")\n\n                # shift bank lines\n                if len(total_erosion_dist) == ib:\n                    flow_erosion_dist.append(dn_flow.copy())\n                    ship_erosion_dist.append(dn_ship.copy())\n                    total_erosion_dist.append(dniqib.copy())\n                    total_eroded_vol.append(dviqib.copy())\n                else:\n                    flow_erosion_dist[ib] += dn_flow\n                    ship_erosion_dist[ib] += dn_ship\n                    total_erosion_dist[ib] += dniqib\n                    total_eroded_vol[ib] += dviqib\n\n                # accumulate eroded volumes per km\n                dvol = get_km_eroded_volume(\n                    bank_data.bank_chainage_midpoints[ib], dviqib, km_bin\n                )\n                vol_per_discharge[iq].append(dvol)\n                dvol_bank[:, ib] += dvol\n\n            erovol_file = config_file.get_str(\"Erosion\", f\"EroVol{iq_str}\", default=f\"erovolQ{iq_str}.evo\")\n            log_text(\"save_erovol\", data={\"file\": erovol_file}, indent=\"  \")\n            write_km_eroded_volumes(\n                km_mid, dvol_bank, str(self.output_dir) + os.sep + erovol_file\n            )\n\n        erosion_results = ErosionResults(\n            eq_erosion_dist=eq_erosion_dist,\n            total_erosion_dist=total_erosion_dist,\n            flow_erosion_dist=flow_erosion_dist,\n            ship_erosion_dist=ship_erosion_dist,\n            vol_per_discharge=vol_per_discharge,\n            eq_eroded_vol=eq_eroded_vol,\n            total_eroded_vol=total_eroded_vol,\n            erosion_time=erosion_time,\n        )\n\n        water_level_data = WaterLevelData(\n            hfw_max=hfw_max,\n            water_level=water_level,\n            ship_wave_max=ship_wave_max,\n            ship_wave_min=ship_wave_min,\n            velocity=velocity,\n            bank_height=bank_height,\n            chezy=chezy,\n        )\n        bank_data.bank_line_size = line_size\n\n        return water_level_data, erosion_results\n\n    def _postprocess_erosion_results(\n        self,\n        km_bin: Tuple[float, float, float],\n        km_mid,\n        bank_data: BankData,\n        erosion_results: ErosionResults,\n    ) -&gt; Tuple[List[LineString], List[LineString], List[LineString]]:\n        \"\"\"Postprocess the erosion results to get the new bank lines and volumes.\"\"\"\n        log_text(\"=\")\n        avg_erosion_rate = np.zeros(bank_data.n_bank_lines)\n        dn_max = np.zeros(bank_data.n_bank_lines)\n        d_nav_flow = np.zeros(bank_data.n_bank_lines)\n        d_nav_ship = np.zeros(bank_data.n_bank_lines)\n        d_nav_eq = np.zeros(bank_data.n_bank_lines)\n        dn_max_eq = np.zeros(bank_data.n_bank_lines)\n        eq_eroded_vol_per_km = np.zeros((len(km_mid), bank_data.n_bank_lines))\n        total_eroded_vol_per_km = np.zeros((len(km_mid), bank_data.n_bank_lines))\n        xy_line_new_list = []\n        bankline_new_list = []\n        xy_line_eq_list = []\n        bankline_eq_list = []\n        for ib, bank_coords in enumerate(bank_data.bank_line_coords):\n            avg_erosion_rate[ib] = (\n                erosion_results.total_erosion_dist[ib] * bank_data.bank_line_size[ib]\n            ).sum() / bank_data.bank_line_size[ib].sum()\n            dn_max[ib] = erosion_results.total_erosion_dist[ib].max()\n            d_nav_flow[ib] = (\n                erosion_results.flow_erosion_dist[ib] * bank_data.bank_line_size[ib]\n            ).sum() / bank_data.bank_line_size[ib].sum()\n            d_nav_ship[ib] = (\n                erosion_results.ship_erosion_dist[ib] * bank_data.bank_line_size[ib]\n            ).sum() / bank_data.bank_line_size[ib].sum()\n            d_nav_eq[ib] = (\n                erosion_results.eq_erosion_dist[ib] * bank_data.bank_line_size[ib]\n            ).sum() / bank_data.bank_line_size[ib].sum()\n            dn_max_eq[ib] = erosion_results.eq_erosion_dist[ib].max()\n            log_text(\"bank_dnav\", data={\"ib\": ib + 1, \"v\": avg_erosion_rate[ib]})\n            log_text(\"bank_dnavflow\", data={\"v\": d_nav_flow[ib]})\n            log_text(\"bank_dnavship\", data={\"v\": d_nav_ship[ib]})\n            log_text(\"bank_dnmax\", data={\"v\": dn_max[ib]})\n            log_text(\"bank_dnaveq\", data={\"v\": d_nav_eq[ib]})\n            log_text(\"bank_dnmaxeq\", data={\"v\": dn_max_eq[ib]})\n\n            xy_line_new = move_line(\n                bank_coords,\n                erosion_results.total_erosion_dist[ib],\n                bank_data.is_right_bank[ib],\n            )\n            xy_line_new_list.append(xy_line_new)\n            bankline_new_list.append(LineString(xy_line_new))\n\n            xy_line_eq = move_line(\n                bank_coords,\n                erosion_results.eq_erosion_dist[ib],\n                bank_data.is_right_bank[ib],\n            )\n            xy_line_eq_list.append(xy_line_eq)\n            bankline_eq_list.append(LineString(xy_line_eq))\n\n            dvol_eq = get_km_eroded_volume(\n                bank_data.bank_chainage_midpoints[ib],\n                erosion_results.eq_eroded_vol[ib],\n                km_bin,\n            )\n            eq_eroded_vol_per_km[:, ib] = dvol_eq\n            dvol_tot = get_km_eroded_volume(\n                bank_data.bank_chainage_midpoints[ib],\n                erosion_results.total_eroded_vol[ib],\n                km_bin,\n            )\n            total_eroded_vol_per_km[:, ib] = dvol_tot\n            if ib &lt; bank_data.n_bank_lines - 1:\n                log_text(\"-\")\n\n        erosion_results.avg_erosion_rate = avg_erosion_rate\n        erosion_results.eq_eroded_vol_per_km = eq_eroded_vol_per_km\n        erosion_results.total_eroded_vol_per_km = total_eroded_vol_per_km\n\n        return bankline_new_list, bankline_eq_list, xy_line_eq_list\n\n    def bankerosion_core(self) -&gt; None:\n        \"\"\"Run the bank erosion analysis for a specified configuration.\"\"\"\n        timed_logger(\"-- start analysis --\")\n        log_text(\n            \"header_bankerosion\",\n            data={\n                \"version\": __version__,\n                \"location\": \"https://github.com/Deltares/D-FAST_Bank_Erosion\",\n            },\n        )\n        log_text(\"-\")\n        config_file = self.config_file\n\n        # read simulation data (get_sim_data)\n        sim_file = config_file.get_sim_file(\"Erosion\", str(self.ref_level + 1))\n        log_text(\"-\")\n        log_text(\"read_simdata\", data={\"file\": sim_file})\n        log_text(\"-\")\n        sim, _ = read_simulation_data(sim_file)\n        log_text(\"-\")\n\n        log_text(\"derive_topology\")\n\n        mesh_data = _compute_mesh_topology(sim)\n\n        # clip the chainage path to the range of chainages of interest\n        km_bounds = self.river_data.station_bounds\n        log_text(\"clip_chainage\", data={\"low\": km_bounds[0], \"high\": km_bounds[1]})\n\n        stations_coords = self.river_data.masked_profile_arr[:, :2]\n\n        # map bank lines to mesh cells\n        log_text(\"intersect_bank_mesh\")\n\n        bank_data = self.intersect_bank_lines_with_mesh(\n            config_file, stations_coords, mesh_data\n        )\n\n        river_axis_km, _, river_axis = self._prepare_river_axis(\n            stations_coords, config_file\n        )\n\n        # get output interval\n        km_step = config_file.get_float(\"Erosion\", \"OutputInterval\", 1.0)\n        # map to output interval\n        km_bin = (river_axis_km.min(), river_axis_km.max(), km_step)\n        km_mid = get_km_bins(km_bin, type=3)  # get mid-points\n\n        fairway_data = self._prepare_fairway(river_axis, stations_coords, mesh_data, config_file)\n\n        self._map_bank_to_fairway(bank_data, fairway_data, sim, config_file)\n\n        erosion_inputs = self._prepare_initial_conditions(\n            config_file, bank_data, fairway_data\n        )\n\n        # initialize arrays for erosion loop over all discharges\n        water_level_data, erosion_results = self._process_discharge_levels(\n            km_mid,\n            km_bin,\n            config_file,\n            erosion_inputs,\n            bank_data,\n            fairway_data,\n        )\n\n        bankline_new_list, bankline_eq_list, xy_line_eq_list = (\n            self._postprocess_erosion_results(\n                km_bin,\n                km_mid,\n                bank_data,\n                erosion_results,\n            )\n        )\n\n        self._write_bankline_shapefiles(bankline_new_list, bankline_eq_list, config_file)\n        self._write_volume_outputs(erosion_results, km_mid)\n\n        # create various plots\n        self._generate_plots(\n            river_axis_km,\n            sim,\n            xy_line_eq_list,\n            km_mid,\n            km_step,\n            erosion_inputs,\n            water_level_data,\n            mesh_data,\n            bank_data,\n            erosion_results,\n        )\n        log_text(\"end_bankerosion\")\n        timed_logger(\"-- end analysis --\")\n\n    def _write_bankline_shapefiles(\n        self, bankline_new_list, bankline_eq_list, config_file: ConfigFile\n    ):\n        bankline_new_series = GeoSeries(bankline_new_list, crs=config_file.crs)\n        bank_lines_new = GeoDataFrame(geometry=bankline_new_series)\n        bank_name = self.config_file.get_str(\"General\", \"BankFile\", \"bankfile\")\n\n        bank_file = self.output_dir / f\"{bank_name}_new.shp\"\n        log_text(\"save_banklines\", data={\"file\": str(bank_file)})\n        bank_lines_new.to_file(bank_file)\n\n        bankline_eq_series = GeoSeries(bankline_eq_list, crs=config_file.crs)\n        banklines_eq = GeoDataFrame(geometry=bankline_eq_series)\n\n        bank_file = self.output_dir / f\"{bank_name}_eq.shp\"\n        log_text(\"save_banklines\", data={\"file\": str(bank_file)})\n        banklines_eq.to_file(bank_file)\n\n    def _write_volume_outputs(self, erosion_results: ErosionResults, km_mid):\n        erosion_vol_file = self.config_file.get_str(\"Erosion\", \"EroVol\", default=\"erovol.evo\")\n        log_text(\"save_tot_erovol\", data={\"file\": erosion_vol_file})\n        write_km_eroded_volumes(\n            km_mid,\n            erosion_results.total_eroded_vol_per_km,\n            str(self.output_dir / erosion_vol_file),\n        )\n\n        # write eroded volumes per km (equilibrium)\n        erosion_vol_file = self.config_file.get_str(\"Erosion\", \"EroVolEqui\", default=\"erovol_eq.evo\")\n        log_text(\"save_eq_erovol\", data={\"file\": erosion_vol_file})\n        write_km_eroded_volumes(\n            km_mid,\n            erosion_results.eq_eroded_vol_per_km,\n            str(self.output_dir / erosion_vol_file),\n        )\n\n    def _generate_plots(\n        self,\n        river_axis_km,\n        sim,\n        xy_line_eq_list,\n        km_mid,\n        km_step,\n        erosion_inputs: ErosionInputs,\n        water_level_data: WaterLevelData,\n        mesh_data: MeshData,\n        bank_data: BankData,\n        erosion_results: ErosionResults,\n    ):\n        # create various plots\n        if self.plot_flags[\"plot_data\"]:\n            log_text(\"=\")\n            log_text(\"create_figures\")\n            fig_i = 0\n            bbox = get_bbox(self.river_data.masked_profile_arr)\n\n            if self.plot_flags[\"save_plot_zoomed\"]:\n                bank_coords_mid = []\n                for ib in range(bank_data.n_bank_lines):\n                    bank_coords_mid.append(\n                        (\n                            bank_data.bank_line_coords[ib][:-1, :]\n                            + bank_data.bank_line_coords[ib][1:, :]\n                        )\n                        / 2\n                    )\n                km_zoom, xy_zoom = get_zoom_extends(\n                    river_axis_km.min(),\n                    river_axis_km.max(),\n                    self.plot_flags[\"zoom_km_step\"],\n                    bank_coords_mid,\n                    bank_data.bank_chainage_midpoints,\n                )\n\n            fig, ax = df_plt.plot1_waterdepth_and_banklines(\n                bbox,\n                self.river_data.masked_profile_arr,\n                bank_data.bank_lines,\n                mesh_data.face_node,\n                sim[\"nnodes\"],\n                sim[\"x_node\"],\n                sim[\"y_node\"],\n                sim[\"h_face\"],\n                1.1 * water_level_data.hfw_max,\n                X_AXIS_TITLE,\n                Y_AXIS_TITLE,\n                \"water depth and initial bank lines\",\n                \"water depth [m]\",\n            )\n            if self.plot_flags[\"save_plot\"]:\n                fig_i = fig_i + 1\n                fig_base = f\"{self.plot_flags['fig_dir']}{os.sep}{fig_i}_banklines\"\n\n                if self.plot_flags[\"save_plot_zoomed\"]:\n                    df_plt.zoom_xy_and_save(fig, ax, fig_base, self.plot_flags[\"plot_ext\"], xy_zoom)\n\n                fig_path = fig_base + self.plot_flags[\"plot_ext\"]\n                df_plt.savefig(fig, fig_path)\n\n            fig, ax = df_plt.plot2_eroded_distance_and_equilibrium(\n                bbox,\n                self.river_data.masked_profile_arr,\n                bank_data.bank_line_coords,\n                erosion_results.total_erosion_dist,\n                bank_data.is_right_bank,\n                erosion_results.avg_erosion_rate,\n                xy_line_eq_list,\n                mesh_data.x_edge_coords,\n                mesh_data.y_edge_coords,\n                X_AXIS_TITLE,\n                Y_AXIS_TITLE,\n                \"eroded distance and equilibrium bank location\",\n                f\"eroded during {erosion_results.erosion_time} year\",\n                \"eroded distance [m]\",\n                \"equilibrium location\",\n            )\n            if self.plot_flags[\"save_plot\"]:\n                fig_i = fig_i + 1\n                fig_base = f\"{self.plot_flags['fig_dir']}{os.sep}{fig_i}_erosion_sensitivity\"\n\n                if self.plot_flags[\"save_plot_zoomed\"]:\n                    df_plt.zoom_xy_and_save(fig, ax, fig_base, self.plot_flags[\"plot_ext\"], xy_zoom)\n\n                fig_path = fig_base + self.plot_flags[\"plot_ext\"]\n                df_plt.savefig(fig, fig_path)\n\n            fig, ax = df_plt.plot3_eroded_volume(\n                km_mid,\n                km_step,\n                \"river chainage [km]\",\n                erosion_results.vol_per_discharge,\n                \"eroded volume [m^3]\",\n                f\"eroded volume per {km_step} chainage km ({erosion_results.erosion_time} years)\",\n                \"Q{iq}\",\n                \"Bank {ib}\",\n            )\n            if self.plot_flags[\"save_plot\"]:\n                fig_i = fig_i + 1\n                fig_base = f\"{self.plot_flags['fig_dir']}{os.sep}{fig_i}_eroded_volume\"\n\n                if self.plot_flags[\"save_plot_zoomed\"]:\n                    df_plt.zoom_x_and_save(fig, ax, fig_base, self.plot_flags[\"plot_ext\"], km_zoom)\n\n                fig_path = fig_base + self.plot_flags[\"plot_ext\"]\n                df_plt.savefig(fig, fig_path)\n\n            fig, ax = df_plt.plot3_eroded_volume_subdivided_1(\n                km_mid,\n                km_step,\n                \"river chainage [km]\",\n                erosion_results.vol_per_discharge,\n                \"eroded volume [m^3]\",\n                f\"eroded volume per {km_step} chainage km ({erosion_results.erosion_time} years)\",\n                \"Q{iq}\",\n            )\n            if self.plot_flags[\"save_plot\"]:\n                fig_i = fig_i + 1\n                fig_base = self.plot_flags[\"fig_dir\"] + os.sep + str(fig_i) + \"_eroded_volume_per_discharge\"\n                if self.plot_flags[\"save_plot_zoomed\"]:\n                    df_plt.zoom_x_and_save(fig, ax, fig_base, self.plot_flags[\"plot_ext\"], km_zoom)\n                fig_path = fig_base + self.plot_flags[\"plot_ext\"]\n                df_plt.savefig(fig, fig_path)\n\n            fig, ax = df_plt.plot3_eroded_volume_subdivided_2(\n                km_mid,\n                km_step,\n                \"river chainage [km]\",\n                erosion_results.vol_per_discharge,\n                \"eroded volume [m^3]\",\n                f\"eroded volume per {km_step} chainage km ({erosion_results.erosion_time} years)\",\n                \"Bank {ib}\",\n            )\n            if self.plot_flags[\"save_plot\"]:\n                fig_i = fig_i + 1\n                fig_base = self.plot_flags[\"fig_dir\"] + os.sep + str(fig_i) + \"_eroded_volume_per_bank\"\n                if self.plot_flags[\"save_plot_zoomed\"]:\n                    df_plt.zoom_x_and_save(fig, ax, fig_base, self.plot_flags[\"plot_ext\"], km_zoom)\n                fig_path = fig_base + self.plot_flags[\"plot_ext\"]\n                df_plt.savefig(fig, fig_path)\n\n            fig, ax = df_plt.plot4_eroded_volume_eq(\n                km_mid,\n                km_step,\n                \"river chainage [km]\",\n                erosion_results.eq_eroded_vol_per_km,\n                \"eroded volume [m^3]\",\n                f\"eroded volume per {km_step} chainage km (equilibrium)\",\n            )\n            if self.plot_flags[\"save_plot\"]:\n                fig_i = fig_i + 1\n                fig_base = self.plot_flags[\"fig_dir\"] + os.sep + str(fig_i) + \"_eroded_volume_eq\"\n                if self.plot_flags[\"save_plot_zoomed\"]:\n                    df_plt.zoom_x_and_save(fig, ax, fig_base, self.plot_flags[\"plot_ext\"], km_zoom)\n                fig_path = fig_base + self.plot_flags[\"plot_ext\"]\n                df_plt.savefig(fig, fig_path)\n\n            figlist, axlist = df_plt.plot5series_waterlevels_per_bank(\n                bank_data.bank_chainage_midpoints,\n                \"river chainage [km]\",\n                water_level_data.water_level,\n                water_level_data.ship_wave_max,\n                water_level_data.ship_wave_min,\n                \"water level at Q{iq}\",\n                \"average water level\",\n                \"wave influenced range\",\n                water_level_data.bank_height,\n                \"level of bank\",\n                erosion_inputs.bank_protection_level,\n                \"bank protection level\",\n                \"elevation\",\n                \"(water)levels along bank line {ib}\",\n                \"[m NAP]\",\n            )\n            if self.plot_flags[\"save_plot\"]:\n                for ib, fig in enumerate(figlist):\n                    fig_i = fig_i + 1\n                    fig_base = f\"{self.plot_flags['fig_dir']}/{fig_i}_levels_bank_{ib + 1}\"\n\n                    if self.plot_flags[\"save_plot_zoomed\"]:\n                        df_plt.zoom_x_and_save(fig, axlist[ib], fig_base, self.plot_flags[\"plot_ext\"], km_zoom)\n                    fig_file = f\"{fig_base}{self.plot_flags['plot_ext']}\"\n                    df_plt.savefig(fig, fig_file)\n\n            figlist, axlist = df_plt.plot6series_velocity_per_bank(\n                bank_data.bank_chainage_midpoints,\n                \"river chainage [km]\",\n                water_level_data.velocity,\n                \"velocity at Q{iq}\",\n                erosion_inputs.tauc,\n                water_level_data.chezy[0],\n                RHO,\n                g,\n                \"critical velocity\",\n                \"velocity\",\n                \"velocity along bank line {ib}\",\n                \"[m/s]\",\n            )\n            if self.plot_flags[\"save_plot\"]:\n                for ib, fig in enumerate(figlist):\n                    fig_i = fig_i + 1\n                    fig_base = f\"{self.plot_flags['fig_dir']}{os.sep}{fig_i}_velocity_bank_{ib + 1}\"\n\n                    if self.plot_flags[\"save_plot_zoomed\"]:\n                        df_plt.zoom_x_and_save(fig, axlist[ib], fig_base, self.plot_flags[\"plot_ext\"], km_zoom)\n\n                    fig_file = fig_base + self.plot_flags[\"plot_ext\"]\n                    df_plt.savefig(fig, fig_file)\n\n            fig, ax = df_plt.plot7_banktype(\n                bbox,\n                self.river_data.masked_profile_arr,\n                bank_data.bank_line_coords,\n                erosion_inputs.bank_type,\n                erosion_inputs.taucls_str,\n                X_AXIS_TITLE,\n                Y_AXIS_TITLE,\n                \"bank type\",\n            )\n            if self.plot_flags[\"save_plot\"]:\n                fig_i = fig_i + 1\n                fig_base = self.plot_flags[\"fig_dir\"] + os.sep + str(fig_i) + \"_banktype\"\n                if self.plot_flags[\"save_plot_zoomed\"]:\n                    df_plt.zoom_xy_and_save(fig, ax, fig_base, self.plot_flags[\"plot_ext\"], xy_zoom)\n                fig_file = fig_base + self.plot_flags[\"plot_ext\"]\n                df_plt.savefig(fig, fig_file)\n\n            fig, ax = df_plt.plot8_eroded_distance(\n                bank_data.bank_chainage_midpoints,\n                \"river chainage [km]\",\n                erosion_results.total_erosion_dist,\n                \"Bank {ib}\",\n                erosion_results.eq_erosion_dist,\n                \"Bank {ib} (eq)\",\n                \"eroded distance\",\n                \"[m]\",\n            )\n            if self.plot_flags[\"save_plot\"]:\n                fig_i = fig_i + 1\n                fig_base = self.plot_flags[\"fig_dir\"] + os.sep + str(fig_i) + \"_erodis\"\n                if self.plot_flags[\"save_plot_zoomed\"]:\n                    df_plt.zoom_x_and_save(fig, ax, fig_base, self.plot_flags[\"plot_ext\"], km_zoom)\n                fig_file = fig_base + self.plot_flags[\"plot_ext\"]\n                df_plt.savefig(fig, fig_file)\n\n            if self.plot_flags[\"close_plot\"]:\n                plt.close(\"all\")\n            else:\n                plt.show(block=not self.gui)\n</code></pre>"},{"location":"api/bank_erosion.html#dfastbe.bank_erosion.Erosion.config_file","title":"<code>config_file: ConfigFile</code>  <code>property</code>","text":"<p>Configuration file object.</p>"},{"location":"api/bank_erosion.html#dfastbe.bank_erosion.Erosion.bankerosion_core","title":"<code>bankerosion_core() -&gt; None</code>","text":"<p>Run the bank erosion analysis for a specified configuration.</p> Source code in <code>src/dfastbe/bank_erosion.py</code> <pre><code>def bankerosion_core(self) -&gt; None:\n    \"\"\"Run the bank erosion analysis for a specified configuration.\"\"\"\n    timed_logger(\"-- start analysis --\")\n    log_text(\n        \"header_bankerosion\",\n        data={\n            \"version\": __version__,\n            \"location\": \"https://github.com/Deltares/D-FAST_Bank_Erosion\",\n        },\n    )\n    log_text(\"-\")\n    config_file = self.config_file\n\n    # read simulation data (get_sim_data)\n    sim_file = config_file.get_sim_file(\"Erosion\", str(self.ref_level + 1))\n    log_text(\"-\")\n    log_text(\"read_simdata\", data={\"file\": sim_file})\n    log_text(\"-\")\n    sim, _ = read_simulation_data(sim_file)\n    log_text(\"-\")\n\n    log_text(\"derive_topology\")\n\n    mesh_data = _compute_mesh_topology(sim)\n\n    # clip the chainage path to the range of chainages of interest\n    km_bounds = self.river_data.station_bounds\n    log_text(\"clip_chainage\", data={\"low\": km_bounds[0], \"high\": km_bounds[1]})\n\n    stations_coords = self.river_data.masked_profile_arr[:, :2]\n\n    # map bank lines to mesh cells\n    log_text(\"intersect_bank_mesh\")\n\n    bank_data = self.intersect_bank_lines_with_mesh(\n        config_file, stations_coords, mesh_data\n    )\n\n    river_axis_km, _, river_axis = self._prepare_river_axis(\n        stations_coords, config_file\n    )\n\n    # get output interval\n    km_step = config_file.get_float(\"Erosion\", \"OutputInterval\", 1.0)\n    # map to output interval\n    km_bin = (river_axis_km.min(), river_axis_km.max(), km_step)\n    km_mid = get_km_bins(km_bin, type=3)  # get mid-points\n\n    fairway_data = self._prepare_fairway(river_axis, stations_coords, mesh_data, config_file)\n\n    self._map_bank_to_fairway(bank_data, fairway_data, sim, config_file)\n\n    erosion_inputs = self._prepare_initial_conditions(\n        config_file, bank_data, fairway_data\n    )\n\n    # initialize arrays for erosion loop over all discharges\n    water_level_data, erosion_results = self._process_discharge_levels(\n        km_mid,\n        km_bin,\n        config_file,\n        erosion_inputs,\n        bank_data,\n        fairway_data,\n    )\n\n    bankline_new_list, bankline_eq_list, xy_line_eq_list = (\n        self._postprocess_erosion_results(\n            km_bin,\n            km_mid,\n            bank_data,\n            erosion_results,\n        )\n    )\n\n    self._write_bankline_shapefiles(bankline_new_list, bankline_eq_list, config_file)\n    self._write_volume_outputs(erosion_results, km_mid)\n\n    # create various plots\n    self._generate_plots(\n        river_axis_km,\n        sim,\n        xy_line_eq_list,\n        km_mid,\n        km_step,\n        erosion_inputs,\n        water_level_data,\n        mesh_data,\n        bank_data,\n        erosion_results,\n    )\n    log_text(\"end_bankerosion\")\n    timed_logger(\"-- end analysis --\")\n</code></pre>"},{"location":"api/bank_lines.html","title":"bank_lines","text":""},{"location":"api/bank_lines.html#bank-lines","title":"Bank Lines","text":""},{"location":"api/bank_lines.html#dfastbe.bank_lines","title":"<code>dfastbe.bank_lines</code>","text":"<p>Bank line detection module.</p>"},{"location":"api/bank_lines.html#dfastbe.bank_lines.BankLines","title":"<code>BankLines</code>","text":"<p>Bank line detection class.</p> Source code in <code>src/dfastbe/bank_lines.py</code> <pre><code>class BankLines:\n    \"\"\"Bank line detection class.\"\"\"\n\n    def __init__(self, config_file: ConfigFile, gui: bool = False):\n        \"\"\"Bank line initializer.\n\n        Args:\n            config_file : configparser.ConfigParser\n                Analysis configuration settings.\n            gui : bool\n                Flag indicating whether this routine is called from the GUI.\n        \"\"\"\n        # the root_dir is used to get the FigureDir in the `_get_plotting_flags`\n        self.root_dir = config_file.root_dir\n\n        self._config_file = config_file\n        self.gui = gui\n        self.bank_output_dir = config_file.get_output_dir(\"banklines\")\n\n        # set plotting flags\n        self.plot_flags = config_file.get_plotting_flags(self.root_dir)\n        self.river_data = RiverData(config_file)\n\n        self.simulation_data, self.h0 = self._get_simulation_data()\n\n    def _get_simulation_data(self) -&gt; Tuple[SimulationObject, float]:\n        # read simulation data and drying flooding threshold dh0\n        sim_file = self.config_file.get_sim_file(\"Detect\", \"\")\n        log_text(\"read_simdata\", data={\"file\": sim_file})\n        simulation_data, dh0 = read_simulation_data(sim_file)\n        # increase critical water depth h0 by flooding threshold dh0\n        # get critical water depth used for defining bank line (default = 0.0 m)\n        critical_water_depth = self.config_file.get_float(\n            \"Detect\", \"WaterDepth\", default=0\n        )\n        h0 = critical_water_depth + dh0\n        return simulation_data, h0\n\n    @property\n    def config_file(self) -&gt; ConfigFile:\n        \"\"\"Configuration file object.\"\"\"\n        return self._config_file\n\n    @property\n    def max_river_width(self) -&gt; int:\n        \"\"\"Maximum river width in meters.\"\"\"\n        return MAX_RIVER_WIDTH\n\n    def _get_bank_output_dir(self) -&gt; Path:\n        bank_output_dir = self.config_file.get_str(\"General\", \"BankDir\")\n        log_text(\"bankdir_out\", data={\"dir\": bank_output_dir})\n        if os.path.exists(bank_output_dir):\n            log_text(\"overwrite_dir\", data={\"dir\": bank_output_dir})\n        else:\n            os.makedirs(bank_output_dir)\n\n        return Path(bank_output_dir)\n\n    def detect(self) -&gt; None:\n        \"\"\"Run the bank line detection analysis for a specified configuration.\"\"\"\n        config_file = self.config_file\n        river_data = self.river_data\n        timed_logger(\"-- start analysis --\")\n\n        log_text(\n            \"header_banklines\",\n            data={\n                \"version\": __version__,\n                \"location\": \"https://github.com/Deltares/D-FAST_Bank_Erosion\",\n            },\n        )\n        log_text(\"-\")\n\n        # clip the chainage path to the range of chainages of interest\n        km_bounds = river_data.station_bounds\n        river_profile = river_data.masked_profile\n        stations_coords = river_data.masked_profile_arr[:, :2]\n        masked_search_lines, max_distance = river_data.clip_search_lines()\n\n        # convert search lines to bank polygons\n        d_lines = config_file.get_bank_search_distances(river_data.num_search_lines)\n        bank_areas: List[Polygon] = self._convert_search_lines_to_bank_polygons(\n            masked_search_lines, d_lines\n        )\n\n        # determine whether search lines are located on the left or right\n        to_right = [True] * river_data.num_search_lines\n        for ib in range(river_data.num_search_lines):\n            to_right[ib] = on_right_side(\n                np.array(masked_search_lines[ib].coords), stations_coords\n            )\n\n        # clip simulation data to boundaries ...\n        log_text(\"clip_data\")\n        sim = clip_simulation_data(self.simulation_data, river_profile, max_distance)\n\n        # derive bank lines (get_banklines)\n        log_text(\"identify_banklines\")\n        banklines = self._get_bank_lines(sim, self.h0, config_file)\n\n        # clip the set of detected bank lines to the bank areas\n        log_text(\"simplify_banklines\")\n        bank = [None] * river_data.num_search_lines\n        clipped_banklines = [None] * river_data.num_search_lines\n        for ib, bank_area in enumerate(bank_areas):\n            log_text(\"bank_lines\", data={\"ib\": ib + 1})\n            clipped_banklines[ib] = clip_bank_lines(banklines, bank_area)\n            bank[ib] = sort_connect_bank_lines(\n                clipped_banklines[ib], river_profile, to_right[ib]\n            )\n\n        # save bank_file\n        self.save(bank, banklines, clipped_banklines, bank_areas, config_file)\n\n        if self.plot_flags[\"plot_data\"]:\n            self.plot(\n                river_data.masked_profile_arr,\n                self.plot_flags,\n                river_data.num_search_lines,\n                bank,\n                km_bounds,\n                bank_areas,\n                sim,\n                config_file,\n            )\n\n        log_text(\"end_banklines\")\n        timed_logger(\"-- stop analysis --\")\n\n    def plot(\n        self,\n        xy_km_numpy: np.ndarray,\n        plot_flags: Dict[str, bool],\n        n_search_lines: int,\n        bank: List,\n        km_bounds,\n        bank_areas,\n        sim,\n        config_file: ConfigFile,\n    ):\n        \"\"\"Plot the bank lines and the simulation data.\"\"\"\n        log_text(\"=\")\n        log_text(\"create_figures\")\n        i_fig = 0\n        bbox = get_bbox(xy_km_numpy)\n\n        if plot_flags[\"save_plot_zoomed\"]:\n            bank_crds: List[np.ndarray] = []\n            bank_km: List[np.ndarray] = []\n            for ib in range(n_search_lines):\n                bcrds_numpy = np.array(bank[ib])\n                km_numpy = project_km_on_line(bcrds_numpy, xy_km_numpy)\n                bank_crds.append(bcrds_numpy)\n                bank_km.append(km_numpy)\n            km_zoom, xy_zoom = get_zoom_extends(\n                km_bounds[0],\n                km_bounds[1],\n                plot_flags[\"zoom_km_step\"],\n                bank_crds,\n                bank_km,\n            )\n\n        fig, ax = df_plt.plot_detect1(\n            bbox,\n            xy_km_numpy,\n            bank_areas,\n            bank,\n            sim[\"facenode\"],\n            sim[\"nnodes\"],\n            sim[\"x_node\"],\n            sim[\"y_node\"],\n            sim[\"h_face\"],\n            1.1 * sim[\"h_face\"].max(),\n            \"x-coordinate [m]\",\n            \"y-coordinate [m]\",\n            \"water depth and detected bank lines\",\n            \"water depth [m]\",\n            \"bank search area\",\n            \"detected bank line\",\n            config_file,\n        )\n        if plot_flags[\"save_plot\"]:\n            i_fig = i_fig + 1\n            fig_base = f\"{plot_flags.get('fig_dir')}{os.sep}{i_fig}_banklinedetection\"\n            if plot_flags[\"save_plot_zoomed\"]:\n                df_plt.zoom_xy_and_save(\n                    fig, ax, fig_base, plot_flags.get(\"plot_ext\"), xy_zoom, scale=1\n                )\n            fig_file = fig_base + plot_flags[\"plot_ext\"]\n            df_plt.savefig(fig, fig_file)\n\n        if self.plot_flags[\"close_plot\"]:\n            plt.close(\"all\")\n        else:\n            plt.show(block=not self.gui)\n\n    def save(\n        self, bank, banklines, clipped_banklines, bank_areas, config_file: ConfigFile\n    ):\n        \"\"\"Save result files.\"\"\"\n        bank_name = self.config_file.get_str(\"General\", \"BankFile\", \"bankfile\")\n        bank_file = self.bank_output_dir / f\"{bank_name}.shp\"\n        log_text(\"save_banklines\", data={\"file\": bank_file})\n        gpd.GeoSeries(bank, crs=config_file.crs).to_file(bank_file)\n\n        gpd.GeoSeries(clipped_banklines, crs=config_file.crs).to_file(\n            self.bank_output_dir / f\"{BANKLINE_FRAGMENTS_PER_BANK_AREA_FILE}{EXTENSION}\"\n        )\n        banklines.to_file(\n            self.bank_output_dir / f\"{RAW_DETECTED_BANKLINE_FRAGMENTS_FILE}{EXTENSION}\"\n        )\n        gpd.GeoSeries(bank_areas, crs=config_file.crs).to_file(\n            self.bank_output_dir / f\"{BANK_AREAS_FILE}{EXTENSION}\"\n        )\n\n    @staticmethod\n    def _get_bank_lines(\n        sim: SimulationObject, h0: float, config_file: ConfigFile\n    ) -&gt; gpd.GeoSeries:\n        \"\"\"\n        Detect all possible bank line segments based on simulation data.\n\n        Use a critical water depth h0 as a water depth threshold for dry/wet boundary.\n\n        Args:\n            sim (SimulationObject):\n                Simulation data: mesh, bed levels, water levels, velocities, etc.\n            h0 (float):\n                Critical water depth for determining the banks.\n\n        Returns:\n        banklines (geopandas.GeoSeries):\n            The collection of all detected bank segments in the remaining model area.\n        \"\"\"\n        fnc = sim[\"facenode\"]\n        n_nodes = sim[\"nnodes\"]\n        max_nnodes = fnc.shape[1]\n        x_node = sim[\"x_node\"][fnc]\n        y_node = sim[\"y_node\"][fnc]\n        zb = sim[\"zb_val\"][fnc]\n        zw = sim[\"zw_face\"]\n\n        nnodes_total = len(sim[\"x_node\"])\n        try:\n            mask = ~fnc.mask\n            non_masked = sum(mask.reshape(fnc.size))\n            f_nc_m = fnc[mask]\n            zwm = np.repeat(zw, max_nnodes)[mask]\n        except:\n            mask = np.repeat(True, fnc.size)\n            non_masked = fnc.size\n            f_nc_m = fnc.reshape(non_masked)\n            zwm = np.repeat(zw, max_nnodes).reshape(non_masked)\n\n        zw_node = np.bincount(f_nc_m, weights=zwm, minlength=nnodes_total)\n        n_val = np.bincount(f_nc_m, weights=np.ones(non_masked), minlength=nnodes_total)\n        zw_node = zw_node / np.maximum(n_val, 1)\n        zw_node[n_val == 0] = sim[\"zb_val\"][n_val == 0]\n\n        h_node = zw_node[fnc] - zb\n        wet_node = h_node &gt; h0\n        n_wet_arr = wet_node.sum(axis=1)\n        mask = n_wet_arr.mask.size &gt; 1\n\n        n_faces = len(fnc)\n        lines = [None] * n_faces\n        frac = 0\n        for i in range(n_faces):\n            if i &gt;= frac * (n_faces - 1) / 10:\n                print(int(frac * 10))\n                frac = frac + 1\n            nnodes = n_nodes[i]\n            n_wet = n_wet_arr[i]\n            if (mask and n_wet.mask) or n_wet == 0 or n_wet == nnodes:\n                # all dry or all wet\n                pass\n            else:\n                # some nodes dry and some nodes wet: determine the line\n                if nnodes == 3:\n                    lines[i] = tri_to_line(\n                        x_node[i], y_node[i], wet_node[i], h_node[i], h0\n                    )\n                else:\n                    lines[i] = poly_to_line(\n                        nnodes, x_node[i], y_node[i], wet_node[i], h_node[i], h0\n                    )\n        lines = [line for line in lines if line is not None and not line.is_empty]\n        multi_line = union_all(lines)\n        merged_line = line_merge(multi_line)\n\n        return gpd.GeoSeries(merged_line, crs=config_file.crs)\n\n    @staticmethod\n    def _convert_search_lines_to_bank_polygons(\n        search_lines: List[np.ndarray], d_lines: List[float]\n    ) -&gt; List[Polygon]:\n        \"\"\"\n        Construct a series of polygons surrounding the bank search lines.\n\n        Args:\n            search_lines : List[numpy.ndarray]\n                List of arrays containing the x,y-coordinates of a bank search lines.\n            d_lines : List[float]\n                Array containing the search distance value per bank line.\n\n        Returns:\n            bank_areas:\n                Array containing the areas of interest surrounding the bank search lines.\n        \"\"\"\n        n_bank = len(search_lines)\n        bank_areas = [None] * n_bank\n        for b, distance in enumerate(d_lines):\n            bank_areas[b] = search_lines[b].buffer(distance, cap_style=2)\n\n        return bank_areas\n</code></pre>"},{"location":"api/bank_lines.html#dfastbe.bank_lines.BankLines.config_file","title":"<code>config_file: ConfigFile</code>  <code>property</code>","text":"<p>Configuration file object.</p>"},{"location":"api/bank_lines.html#dfastbe.bank_lines.BankLines.max_river_width","title":"<code>max_river_width: int</code>  <code>property</code>","text":"<p>Maximum river width in meters.</p>"},{"location":"api/bank_lines.html#dfastbe.bank_lines.BankLines.__init__","title":"<code>__init__(config_file: ConfigFile, gui: bool = False)</code>","text":"<p>Bank line initializer.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <p>configparser.ConfigParser Analysis configuration settings.</p> required <code>gui</code> <p>bool Flag indicating whether this routine is called from the GUI.</p> <code>False</code> Source code in <code>src/dfastbe/bank_lines.py</code> <pre><code>def __init__(self, config_file: ConfigFile, gui: bool = False):\n    \"\"\"Bank line initializer.\n\n    Args:\n        config_file : configparser.ConfigParser\n            Analysis configuration settings.\n        gui : bool\n            Flag indicating whether this routine is called from the GUI.\n    \"\"\"\n    # the root_dir is used to get the FigureDir in the `_get_plotting_flags`\n    self.root_dir = config_file.root_dir\n\n    self._config_file = config_file\n    self.gui = gui\n    self.bank_output_dir = config_file.get_output_dir(\"banklines\")\n\n    # set plotting flags\n    self.plot_flags = config_file.get_plotting_flags(self.root_dir)\n    self.river_data = RiverData(config_file)\n\n    self.simulation_data, self.h0 = self._get_simulation_data()\n</code></pre>"},{"location":"api/bank_lines.html#dfastbe.bank_lines.BankLines.detect","title":"<code>detect() -&gt; None</code>","text":"<p>Run the bank line detection analysis for a specified configuration.</p> Source code in <code>src/dfastbe/bank_lines.py</code> <pre><code>def detect(self) -&gt; None:\n    \"\"\"Run the bank line detection analysis for a specified configuration.\"\"\"\n    config_file = self.config_file\n    river_data = self.river_data\n    timed_logger(\"-- start analysis --\")\n\n    log_text(\n        \"header_banklines\",\n        data={\n            \"version\": __version__,\n            \"location\": \"https://github.com/Deltares/D-FAST_Bank_Erosion\",\n        },\n    )\n    log_text(\"-\")\n\n    # clip the chainage path to the range of chainages of interest\n    km_bounds = river_data.station_bounds\n    river_profile = river_data.masked_profile\n    stations_coords = river_data.masked_profile_arr[:, :2]\n    masked_search_lines, max_distance = river_data.clip_search_lines()\n\n    # convert search lines to bank polygons\n    d_lines = config_file.get_bank_search_distances(river_data.num_search_lines)\n    bank_areas: List[Polygon] = self._convert_search_lines_to_bank_polygons(\n        masked_search_lines, d_lines\n    )\n\n    # determine whether search lines are located on the left or right\n    to_right = [True] * river_data.num_search_lines\n    for ib in range(river_data.num_search_lines):\n        to_right[ib] = on_right_side(\n            np.array(masked_search_lines[ib].coords), stations_coords\n        )\n\n    # clip simulation data to boundaries ...\n    log_text(\"clip_data\")\n    sim = clip_simulation_data(self.simulation_data, river_profile, max_distance)\n\n    # derive bank lines (get_banklines)\n    log_text(\"identify_banklines\")\n    banklines = self._get_bank_lines(sim, self.h0, config_file)\n\n    # clip the set of detected bank lines to the bank areas\n    log_text(\"simplify_banklines\")\n    bank = [None] * river_data.num_search_lines\n    clipped_banklines = [None] * river_data.num_search_lines\n    for ib, bank_area in enumerate(bank_areas):\n        log_text(\"bank_lines\", data={\"ib\": ib + 1})\n        clipped_banklines[ib] = clip_bank_lines(banklines, bank_area)\n        bank[ib] = sort_connect_bank_lines(\n            clipped_banklines[ib], river_profile, to_right[ib]\n        )\n\n    # save bank_file\n    self.save(bank, banklines, clipped_banklines, bank_areas, config_file)\n\n    if self.plot_flags[\"plot_data\"]:\n        self.plot(\n            river_data.masked_profile_arr,\n            self.plot_flags,\n            river_data.num_search_lines,\n            bank,\n            km_bounds,\n            bank_areas,\n            sim,\n            config_file,\n        )\n\n    log_text(\"end_banklines\")\n    timed_logger(\"-- stop analysis --\")\n</code></pre>"},{"location":"api/bank_lines.html#dfastbe.bank_lines.BankLines.plot","title":"<code>plot(xy_km_numpy: np.ndarray, plot_flags: Dict[str, bool], n_search_lines: int, bank: List, km_bounds, bank_areas, sim, config_file: ConfigFile)</code>","text":"<p>Plot the bank lines and the simulation data.</p> Source code in <code>src/dfastbe/bank_lines.py</code> <pre><code>def plot(\n    self,\n    xy_km_numpy: np.ndarray,\n    plot_flags: Dict[str, bool],\n    n_search_lines: int,\n    bank: List,\n    km_bounds,\n    bank_areas,\n    sim,\n    config_file: ConfigFile,\n):\n    \"\"\"Plot the bank lines and the simulation data.\"\"\"\n    log_text(\"=\")\n    log_text(\"create_figures\")\n    i_fig = 0\n    bbox = get_bbox(xy_km_numpy)\n\n    if plot_flags[\"save_plot_zoomed\"]:\n        bank_crds: List[np.ndarray] = []\n        bank_km: List[np.ndarray] = []\n        for ib in range(n_search_lines):\n            bcrds_numpy = np.array(bank[ib])\n            km_numpy = project_km_on_line(bcrds_numpy, xy_km_numpy)\n            bank_crds.append(bcrds_numpy)\n            bank_km.append(km_numpy)\n        km_zoom, xy_zoom = get_zoom_extends(\n            km_bounds[0],\n            km_bounds[1],\n            plot_flags[\"zoom_km_step\"],\n            bank_crds,\n            bank_km,\n        )\n\n    fig, ax = df_plt.plot_detect1(\n        bbox,\n        xy_km_numpy,\n        bank_areas,\n        bank,\n        sim[\"facenode\"],\n        sim[\"nnodes\"],\n        sim[\"x_node\"],\n        sim[\"y_node\"],\n        sim[\"h_face\"],\n        1.1 * sim[\"h_face\"].max(),\n        \"x-coordinate [m]\",\n        \"y-coordinate [m]\",\n        \"water depth and detected bank lines\",\n        \"water depth [m]\",\n        \"bank search area\",\n        \"detected bank line\",\n        config_file,\n    )\n    if plot_flags[\"save_plot\"]:\n        i_fig = i_fig + 1\n        fig_base = f\"{plot_flags.get('fig_dir')}{os.sep}{i_fig}_banklinedetection\"\n        if plot_flags[\"save_plot_zoomed\"]:\n            df_plt.zoom_xy_and_save(\n                fig, ax, fig_base, plot_flags.get(\"plot_ext\"), xy_zoom, scale=1\n            )\n        fig_file = fig_base + plot_flags[\"plot_ext\"]\n        df_plt.savefig(fig, fig_file)\n\n    if self.plot_flags[\"close_plot\"]:\n        plt.close(\"all\")\n    else:\n        plt.show(block=not self.gui)\n</code></pre>"},{"location":"api/bank_lines.html#dfastbe.bank_lines.BankLines.save","title":"<code>save(bank, banklines, clipped_banklines, bank_areas, config_file: ConfigFile)</code>","text":"<p>Save result files.</p> Source code in <code>src/dfastbe/bank_lines.py</code> <pre><code>def save(\n    self, bank, banklines, clipped_banklines, bank_areas, config_file: ConfigFile\n):\n    \"\"\"Save result files.\"\"\"\n    bank_name = self.config_file.get_str(\"General\", \"BankFile\", \"bankfile\")\n    bank_file = self.bank_output_dir / f\"{bank_name}.shp\"\n    log_text(\"save_banklines\", data={\"file\": bank_file})\n    gpd.GeoSeries(bank, crs=config_file.crs).to_file(bank_file)\n\n    gpd.GeoSeries(clipped_banklines, crs=config_file.crs).to_file(\n        self.bank_output_dir / f\"{BANKLINE_FRAGMENTS_PER_BANK_AREA_FILE}{EXTENSION}\"\n    )\n    banklines.to_file(\n        self.bank_output_dir / f\"{RAW_DETECTED_BANKLINE_FRAGMENTS_FILE}{EXTENSION}\"\n    )\n    gpd.GeoSeries(bank_areas, crs=config_file.crs).to_file(\n        self.bank_output_dir / f\"{BANK_AREAS_FILE}{EXTENSION}\"\n    )\n</code></pre>"},{"location":"api/cmd.html","title":"cmd","text":""},{"location":"api/cmd.html#cmd_1","title":"cmd","text":""},{"location":"api/cmd.html#dfastbe.cmd","title":"<code>dfastbe.cmd</code>","text":"<p>Copyright (C) 2020 Stichting Deltares.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation version 2.1.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, see http://www.gnu.org/licenses/.</p> <p>contact: delft3d.support@deltares.nl Stichting Deltares P.O. Box 177 2600 MH Delft, The Netherlands</p> <p>All indications and logos of, and references to, \"Delft3D\" and \"Deltares\" are registered trademarks of Stichting Deltares, and remain the property of Stichting Deltares. All rights reserved.</p> <p>INFORMATION This file is part of D-FAST Bank Erosion: https://github.com/Deltares/D-FAST_Bank_Erosion</p>"},{"location":"api/cmd.html#dfastbe.cmd.run","title":"<code>run(language: str = 'UK', run_mode: str = 'GUI', configfile: str = 'dfastbe.cfg') -&gt; None</code>","text":"<p>Initializes the language file and starts the chosen run mode.</p> <p>This function loads the appropriate language file and executes one of the available modes: 'BANKLINES', 'BANKEROSION', or 'GUI'. The default configuration file is <code>dfastbe.cfg</code>.</p> <p>Parameters:</p> Name Type Description Default <code>language</code> <code>str</code> <p>Display language code. Acceptable values are 'NL' (Dutch) or 'UK' (English). Defaults to 'UK'.</p> <code>'UK'</code> <code>run_mode</code> <code>str</code> <p>Mode in which the program should run. Available options:</p> <ul> <li>'BANKLINES': Runs the bank lines processing.</li> <li>'BANKEROSION': Runs the bank erosion processing.</li> <li>'GUI': Launches the graphical user interface.</li> </ul> <p>Defaults to 'GUI'.</p> <code>'GUI'</code> <code>configfile</code> <code>str</code> <p>Path to the configuration file. Defaults to 'dfastbe.cfg'.</p> <code>'dfastbe.cfg'</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If an invalid <code>run_mode</code> is provided. The valid options are 'BANKLINES', 'BANKEROSION', or 'GUI'.</p> Example <p>Running the program with Dutch language and bank erosion mode:</p> <pre><code>run(language=\"NL\", run_mode=\"BANKEROSION\", configfile=\"custom_config.cfg\")\n</code></pre> <p>Running the program in default mode (GUI) with English language:</p> <pre><code>run()\n</code></pre> Source code in <code>src/dfastbe/cmd.py</code> <pre><code>def run(\n    language: str = \"UK\",\n    run_mode: str = \"GUI\",\n    configfile: str = \"dfastbe.cfg\",\n) -&gt; None:\n    \"\"\"\n    Initializes the language file and starts the chosen run mode.\n\n    This function loads the appropriate language file and executes one of the\n    available modes: 'BANKLINES', 'BANKEROSION', or 'GUI'. The default configuration\n    file is `dfastbe.cfg`.\n\n    Args:\n        language (str, optional):\n            Display language code. Acceptable values are 'NL' (Dutch) or 'UK' (English).\n            Defaults to 'UK'.\n        run_mode (str, optional):\n            Mode in which the program should run. Available options:\n\n            - 'BANKLINES': Runs the bank lines processing.\n            - 'BANKEROSION': Runs the bank erosion processing.\n            - 'GUI': Launches the graphical user interface.\n\n            Defaults to 'GUI'.\n        configfile (str, optional):\n            Path to the configuration file. Defaults to 'dfastbe.cfg'.\n\n    Raises:\n        Exception: If an invalid `run_mode` is provided. The valid options are\n            'BANKLINES', 'BANKEROSION', or 'GUI'.\n\n    Example:\n        Running the program with Dutch language and bank erosion mode:\n\n        ```python\n        run(language=\"NL\", run_mode=\"BANKEROSION\", configfile=\"custom_config.cfg\")\n        ```\n\n        Running the program in default mode (GUI) with English language:\n\n        ```python\n        run()\n        ```\n    \"\"\"\n    language = language.upper()\n    load_program_texts( R_DIR / f\"messages.{language}.ini\")\n    run_mode = run_mode.upper()\n\n    if run_mode == \"GUI\":\n        main(configfile)\n    else:\n        config_file = ConfigFile.read(configfile)\n\n        if run_mode == \"BANKLINES\":\n            bank_lines = BankLines(config_file)\n            bank_lines.detect()\n        elif run_mode == \"BANKEROSION\":\n            erosion = Erosion(config_file)\n            erosion.bankerosion_core()\n        else:\n            raise ValueError(f\"Invalid run mode {run_mode} specified. Should read 'BANKLINES', 'BANKEROSION' or 'GUI'.\")\n</code></pre>"},{"location":"api/io.html","title":"IO","text":""},{"location":"api/io.html#io_1","title":"IO","text":""},{"location":"api/io.html#dfastbe.io","title":"<code>dfastbe.io</code>","text":"<p>Copyright (C) 2020 Stichting Deltares.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation version 2.1.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, see http://www.gnu.org/licenses/.</p> <p>contact: delft3d.support@deltares.nl Stichting Deltares P.O. Box 177 2600 MH Delft, The Netherlands</p> <p>All indications and logos of, and references to, \"Delft3D\" and \"Deltares\" are registered trademarks of Stichting Deltares, and remain the property of Stichting Deltares. All rights reserved.</p> <p>INFORMATION This file is part of D-FAST Bank Erosion: https://github.com/Deltares/D-FAST_Bank_Erosion</p>"},{"location":"api/io.html#dfastbe.io.ConfigFile","title":"<code>ConfigFile</code>","text":"<p>Class to read configuration files for D-FAST Bank Erosion.</p> <p>This class provides methods to read, write, and manage configuration files for the D-FAST Bank Erosion analysis. It also allows access to configuration settings and supports upgrading older configuration formats.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConfigParser</code> <p>Settings for the D-FAST Bank Erosion analysis.</p> required <code>path</code> <code>Union[Path, str]</code> <p>Path to the configuration file.</p> <code>None</code> <p>Examples:</p> <p>Reading a configuration file:     <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from dfastbe.io import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; print(config_file.config[\"General\"][\"Version\"])\n1.0\n</code></pre> Writing a configuration file:     <pre><code>&gt;&gt;&gt; from dfastbe.io import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdirname:\n...     config_file.write(f\"{tmpdirname}/meuse_manual_out.cfg\")\n</code></pre></p> Source code in <code>src/dfastbe/io.py</code> <pre><code>class ConfigFile:\n    \"\"\"Class to read configuration files for D-FAST Bank Erosion.\n\n    This class provides methods to read, write, and manage configuration files\n    for the D-FAST Bank Erosion analysis. It also allows access to configuration\n    settings and supports upgrading older configuration formats.\n\n    Args:\n        config (ConfigParser): Settings for the D-FAST Bank Erosion analysis.\n        path (Union[Path, str]): Path to the configuration file.\n\n    Examples:\n        Reading a configuration file:\n            ```python\n            &gt;&gt;&gt; import tempfile\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; print(config_file.config[\"General\"][\"Version\"])\n            1.0\n\n            ```\n        Writing a configuration file:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdirname:\n            ...     config_file.write(f\"{tmpdirname}/meuse_manual_out.cfg\")\n\n            ```\n    \"\"\"\n\n    def __init__(self, config: ConfigParser, path: Union[Path, str] = None):\n        self._config = config\n        self.crs = \"EPSG:28992\"\n        if path:\n            self.path = Path(path)\n            self.root_dir = self.path.parent\n            self.make_paths_absolute()\n\n    @property\n    def config(self) -&gt; ConfigParser:\n        \"\"\"ConfigParser: Get the configuration settings.\"\"\"\n        return self._config\n\n    @config.setter\n    def config(self, value: ConfigParser):\n        self._config = value\n\n    @property\n    def version(self) -&gt; str:\n        \"\"\"str: Get the version of the configuration file.\"\"\"\n        return self.get_str(\"General\", \"Version\")\n\n    @property\n    def root_dir(self) -&gt; Path:\n        \"\"\"Path: Get the root directory of the configuration file.\"\"\"\n        return self._root_dir\n\n    @root_dir.setter\n    def root_dir(self, value: str):\n        self._root_dir = value\n\n    @classmethod\n    def read(cls, path: Union[str, Path]) -&gt; \"ConfigFile\":\n        \"\"\"Read a configParser object (configuration file).\n\n        Reads the config file using the standard `configparser`. Falls back to a\n        dedicated reader compatible with old waqbank files.\n\n        Args:\n            path (Union[str, Path]): Path to the configuration file.\n\n        Returns:\n            ConfigFile: Settings for the D-FAST Bank Erosion analysis.\n\n        Raises:\n            FileNotFoundError: If the configuration file does not exist.\n            Exception: If there is an error reading the config file.\n\n        Examples:\n            Read a config file:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n\n            ```\n        \"\"\"\n        if not Path(path).exists():\n            raise FileNotFoundError(f\"The Config-File: {path} does not exist\")\n\n        try:\n            config = ConfigParser(comment_prefixes=\"%\")\n            with open(path, \"r\") as configfile:\n                config.read_file(configfile)\n        except ConfigparserError as e:\n            print(f\"Error during reading the config file: {e}\")\n            config = cls.config_file_callback_parser(path)\n\n        # if version != \"1.0\":\n        config = cls._upgrade(config)\n        return cls(config, path=path)\n\n    @staticmethod\n    def config_file_callback_parser(path: str) -&gt; ConfigParser:\n        \"\"\"Parse a configuration file as fallback to the read method.\n\n        Args:\n            path (str): Path to the configuration file.\n\n        Returns:\n            ConfigParser: Parsed configuration file.\n        \"\"\"\n        config = ConfigParser()\n        config[\"General\"] = {}\n        all_lines = open(path, \"r\").read().splitlines()\n        for line in all_lines:\n            perc = line.find(\"%\")\n            if perc &gt;= 0:\n                line = line[:perc]\n            data = line.split()\n            if len(data) &gt;= 3:\n                config[\"General\"][data[0]] = data[2]\n        return config\n\n    @staticmethod\n    def _upgrade(config: ConfigParser) -&gt; ConfigParser:\n        \"\"\"Upgrade the configuration data structure to version 1.0 format.\n\n        Args:\n            config (ConfigParser): D-FAST Bank Erosion settings in 0.1 format.\n\n        Returns:\n            ConfigParser: D-FAST Bank Erosion settings in 1.0 format.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; result = config_file._upgrade(config_file.config)\n            &gt;&gt;&gt; isinstance(result, ConfigParser)\n            True\n\n            ```\n        \"\"\"\n        try:\n            version = config[\"General\"][\"Version\"]\n        except KeyError:\n            version = \"0.1\"\n\n        if version == \"0.1\":\n            config[\"General\"][\"Version\"] = \"1.0\"\n\n            config[\"Detect\"] = {}\n            config = move_parameter_location(\n                config, \"General\", \"Delft3Dfile\", \"Detect\", \"SimFile\", convert=sim2nc\n            )\n            config = move_parameter_location(\n                config, \"General\", \"SDSfile\", \"Detect\", \"SimFile\", convert=sim2nc\n            )\n            config = move_parameter_location(config, \"General\", \"SimFile\", \"Detect\")\n            config = move_parameter_location(config, \"General\", \"NBank\", \"Detect\")\n            config_file = ConfigFile(config)\n            n_bank = config_file.get_int(\"Detect\", \"NBank\", default=0, positive=True)\n            for i in range(1, n_bank + 1):\n                config = move_parameter_location(\n                    config, \"General\", f\"Line{i}\", \"Detect\"\n                )\n\n            config = move_parameter_location(config, \"General\", \"WaterDepth\", \"Detect\")\n            config = move_parameter_location(config, \"General\", \"DLines\", \"Detect\")\n\n            config[\"Erosion\"] = {}\n            config = move_parameter_location(config, \"General\", \"TErosion\", \"Erosion\")\n            config = move_parameter_location(config, \"General\", \"RiverAxis\", \"Erosion\")\n            config = move_parameter_location(config, \"General\", \"Fairway\", \"Erosion\")\n            config = move_parameter_location(config, \"General\", \"RefLevel\", \"Erosion\")\n            config = move_parameter_location(\n                config, \"General\", \"OutputInterval\", \"Erosion\"\n            )\n            config = move_parameter_location(config, \"General\", \"OutputDir\", \"Erosion\")\n            config = move_parameter_location(config, \"General\", \"BankNew\", \"Erosion\")\n            config = move_parameter_location(config, \"General\", \"BankEq\", \"Erosion\")\n            config = move_parameter_location(config, \"General\", \"EroVol\", \"Erosion\")\n            config = move_parameter_location(config, \"General\", \"EroVolEqui\", \"Erosion\")\n            config = move_parameter_location(config, \"General\", \"NLevel\", \"Erosion\")\n            config_file = ConfigFile(config)\n            n_level = config_file.get_int(\"Erosion\", \"NLevel\", default=0, positive=True)\n\n            for i in range(1, n_level + 1):\n                config = move_parameter_location(\n                    config,\n                    \"General\",\n                    f\"Delft3Dfile{i}\",\n                    \"Erosion\",\n                    f\"SimFile{i}\",\n                    convert=sim2nc,\n                )\n                config = move_parameter_location(\n                    config,\n                    \"General\",\n                    f\"SDSfile{i}\",\n                    \"Erosion\",\n                    f\"SimFile{i}\",\n                    convert=sim2nc,\n                )\n                config = move_parameter_location(\n                    config, \"General\", f\"SimFile{i}\", \"Erosion\"\n                )\n                config = move_parameter_location(\n                    config, \"General\", f\"PDischarge{i}\", \"Erosion\"\n                )\n\n            config = move_parameter_location(config, \"General\", \"ShipType\", \"Erosion\")\n            config = move_parameter_location(config, \"General\", \"VShip\", \"Erosion\")\n            config = move_parameter_location(config, \"General\", \"NShip\", \"Erosion\")\n            config = move_parameter_location(config, \"General\", \"NWave\", \"Erosion\")\n            config = move_parameter_location(config, \"General\", \"Draught\", \"Erosion\")\n            config = move_parameter_location(config, \"General\", \"Wave0\", \"Erosion\")\n            config = move_parameter_location(config, \"General\", \"Wave1\", \"Erosion\")\n\n            config = move_parameter_location(config, \"General\", \"Classes\", \"Erosion\")\n            config = move_parameter_location(config, \"General\", \"BankType\", \"Erosion\")\n            config = move_parameter_location(\n                config, \"General\", \"ProtectLevel\", \"Erosion\", \"ProtectionLevel\"\n            )\n            config = move_parameter_location(config, \"General\", \"Slope\", \"Erosion\")\n            config = move_parameter_location(config, \"General\", \"Reed\", \"Erosion\")\n            config = move_parameter_location(config, \"General\", \"VelFilter\", \"Erosion\")\n\n            for i in range(1, n_level + 1):\n                config = move_parameter_location(\n                    config, \"General\", f\"ShipType{i}\", \"Erosion\"\n                )\n                config = move_parameter_location(\n                    config, \"General\", f\"VShip{i}\", \"Erosion\"\n                )\n                config = move_parameter_location(\n                    config, \"General\", f\"NShip{i}\", \"Erosion\"\n                )\n                config = move_parameter_location(\n                    config, \"General\", f\"NWave{i}\", \"Erosion\"\n                )\n                config = move_parameter_location(\n                    config, \"General\", f\"Draught{i}\", \"Erosion\"\n                )\n                config = move_parameter_location(\n                    config, \"General\", f\"Slope{i}\", \"Erosion\"\n                )\n                config = move_parameter_location(\n                    config, \"General\", f\"Reed{i}\", \"Erosion\"\n                )\n                config = move_parameter_location(\n                    config, \"General\", f\"EroVol{i}\", \"Erosion\"\n                )\n\n        return config\n\n    def write(self, filename: str) -&gt; None:\n        \"\"\"Pretty print a configParser object (configuration file) to file.\n\n        Pretty prints a `configparser` object to a file. Aligns the equal signs for\n        all keyword/value pairs, adds a two-space indentation to all keyword lines,\n        and adds an empty line before the start of a new block.\n\n        Args:\n            filename (str): Name of the configuration file to be written.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; import tempfile\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdirname:\n            ...     config_file.write(f\"{tmpdirname}/meuse_manual_out.cfg\")\n\n            ```\n        \"\"\"\n        sections = self.config.sections()\n        max_length = 0\n        for section in sections:\n            options = self.config.options(section)\n            max_length = max(max_length, *[len(option) for option in options])\n\n        with open(filename, \"w\") as configfile:\n            for index, section in enumerate(sections):\n                if index &gt; 0:\n                    configfile.write(\"\\n\")\n                configfile.write(f\"[{section}]\\n\")\n\n                for option in self.config.options(section):\n                    configfile.write(\n                        f\"  {option:&lt;{max_length}} = {self.config[section][option]}\\n\"\n                    )\n\n    def make_paths_absolute(self) -&gt; str:\n        \"\"\"Convert all relative paths in the configuration to absolute paths.\n\n        Returns:\n            str: Absolute path of the configuration file's root directory.\n        \"\"\"\n        self.resolve(self.root_dir)\n\n        return self.root_dir\n\n    def get_str(\n        self,\n        group: str,\n        key: str,\n        default: Optional[str] = None,\n    ) -&gt; str:\n        \"\"\"Get a string from a selected group and keyword in the analysis settings.\n\n        Args:\n            group (str): Name of the group from which to read.\n            key (str): Name of the keyword from which to read.\n            default (Optional[str]): Optional default value.\n\n        Raises:\n            ConfigFileError: If the keyword isn't specified and no default value is given.\n\n        Returns:\n            str: value of the keyword as string.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; result = config_file.get_str(\"General\", \"BankDir\")\n            &gt;&gt;&gt; expected = Path(\"tests/data/erosion/output/banklines\").resolve()\n            &gt;&gt;&gt; str(expected) == result\n            True\n\n            ```\n        \"\"\"\n        try:\n            val = self.config[group][key]\n        except KeyError as e:\n            if default is not None:\n                val = default\n            else:\n                raise ConfigFileError(\n                    f\"No value specified for required keyword {key} in block {group}.\"\n                ) from e\n        return val\n\n    def get_bool(\n        self,\n        group: str,\n        key: str,\n        default: Optional[bool] = None,\n    ) -&gt; bool:\n        \"\"\"Get a boolean from a selected group and keyword in the analysis settings.\n\n        Args:\n            group (str): Name of the group from which to read.\n            key (str): Name of the keyword from which to read.\n            default (Optional[bool]): Optional default value.\n\n        Raises:\n            ConfigFileError: If the keyword isn't specified and no default value is given.\n\n        Returns:\n            bool: value of the keyword as boolean.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.get_bool(\"General\", \"Plotting\")\n            True\n\n            ```\n        \"\"\"\n        try:\n            str_val = self.config[group][key].lower()\n            val = (\n                (str_val == \"yes\")\n                or (str_val == \"y\")\n                or (str_val == \"true\")\n                or (str_val == \"t\")\n                or (str_val == \"1\")\n            )\n        except KeyError as e:\n            if default is not None:\n                val = default\n            else:\n                raise ConfigFileError(\n                    f\"No boolean value specified for required keyword {key} in block {group}.\"\n                ) from e\n\n        return val\n\n    def get_float(\n        self,\n        group: str,\n        key: str,\n        default: Optional[float] = None,\n        positive: bool = False,\n    ) -&gt; float:\n        \"\"\"Get a floating point value from a selected group and keyword in the analysis settings.\n\n        Args:\n            group (str): Name of the group from which to read.\n            key (str): Name of the keyword from which to read.\n            default (Optional[float]): Optional default value.\n            positive (bool): Flag specifying which floats are accepted.\n                All floats are accepted (if False), or only positive floats (if True).\n\n        Raises:\n            ConfigFileError: If the keyword isn't specified and no default value is given.\n            ConfigFileError: If a negative value is specified when a positive value is required.\n\n\n        Returns:\n            float: value of the keyword as float.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.get_float(\"General\", \"ZoomStepKM\")\n            1.0\n\n            ```\n        \"\"\"\n        try:\n            val = float(self.config[group][key])\n        except (KeyError, ValueError) as e:\n            if default is not None:\n                val = default\n            else:\n                raise ConfigFileError(\n                    f\"No floating point value specified for required keyword {key} in block {group}.\"\n                ) from e\n        if positive and val &lt; 0.0:\n            raise ConfigFileError(\n                f\"Value for {key} in block {group} must be positive, not {val}.\"\n            )\n        return val\n\n    def get_int(\n        self,\n        group: str,\n        key: str,\n        default: Optional[int] = None,\n        positive: bool = False,\n    ) -&gt; int:\n        \"\"\"Get an integer from a selected group and keyword in the analysis settings.\n\n        Args:\n            group (str): Name of the group from which to read.\n            key (str): Name of the keyword from which to read.\n            default (Optional[int]): Optional default value.\n            positive (bool): Flag specifying which floats are accepted.\n                All floats are accepted (if False), or only positive floats (if True).\n\n        Raises:\n            ConfigFileError: If the keyword isn't specified and no default value is given.\n            ConfigFileError: If a negative or zero value is specified when a positive value is required.\n\n\n        Returns:\n            int: value of the keyword as int.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.get_int(\"Detect\", \"NBank\")\n            2\n\n            ```\n        \"\"\"\n        try:\n            val = int(self.config[group][key])\n        except (KeyError, ValueError) as e:\n            if default is not None:\n                val = default\n            else:\n                raise ConfigFileError(\n                    f\"No integer value specified for required keyword {key} in block {group}.\"\n                ) from e\n        if positive and val &lt;= 0:\n            raise ConfigFileError(\n                f\"Value for {key} in block {group} must be positive, not {val}.\"\n            )\n        return val\n\n    def get_sim_file(self, group: str, istr: str) -&gt; str:\n        \"\"\"Get the name of the simulation file from the analysis settings.\n\n        Args:\n            group (str): Name of the group in which to search for the simulation file name.\n            istr (str): Postfix for the simulation file name keyword;\n                typically a string representation of the index.\n\n        Returns:\n            str: Name of the simulation file (empty string if keywords are not found).\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; result = config_file.get_sim_file(\"Erosion\", \"1\")\n            &gt;&gt;&gt; expected = Path(\"tests/data/erosion/inputs/sim0075/SDS-j19_map.nc\").resolve()\n            &gt;&gt;&gt; str(expected) == result\n            True\n\n            ```\n        \"\"\"\n        sim_file = self.config[group].get(f\"SimFile{istr}\", \"\")\n        return sim_file\n\n    def get_km_bounds(self) -&gt; Tuple[float, float]:\n        \"\"\"Get the lower and upper limit for the chainage.\n\n        Returns:\n            Tuple[float, float]: Lower and upper limit for the chainage.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.get_km_bounds()\n            (123.0, 128.0)\n\n            ```\n        \"\"\"\n        km_bounds = self.get_range(\"General\", \"Boundaries\")\n\n        return km_bounds\n\n    def get_search_lines(self) -&gt; List[LineString]:\n        \"\"\"Get the search lines for the bank lines from the analysis settings.\n\n        Returns:\n            List[np.ndarray]: List of arrays containing the x,y-coordinates of a bank search lines.\n        \"\"\"\n        # read guiding bank line\n        n_bank = self.get_int(\"Detect\", \"NBank\")\n        line = [None] * n_bank\n        for b in range(n_bank):\n            bankfile = self.config[\"Detect\"][f\"Line{b + 1}\"]\n            log_text(\"read_search_line\", data={\"nr\": b + 1, \"file\": bankfile})\n            line[b] = XYCModel.read(bankfile)\n        return line\n\n    def get_bank_lines(self, bank_dir: str) -&gt; List[np.ndarray]:\n        \"\"\"Get the bank lines from the detection step.\n\n        Args:\n            bank_dir (str): Name of directory in which the bank lines files are located.\n\n        Returns:\n            List[np.ndarray]: List of arrays containing the x,y-coordinates of a bank lines.\n        \"\"\"\n        bank_name = self.get_str(\"General\", \"BankFile\", \"bankfile\")\n        bankfile = Path(bank_dir) / f\"{bank_name}.shp\"\n        if bankfile.exists():\n            log_text(\"read_banklines\", data={\"file\": str(bankfile)})\n            return gpd.read_file(bankfile)\n\n        bankfile = Path(bank_dir) / f\"{bank_name}_#.xyc\"\n        log_text(\"read_banklines\", data={\"file\": str(bankfile)})\n        bankline_list = []\n        b = 1\n        while True:\n            xyc_file = Path(bank_dir) / f\"{bank_name}_{b}.xyc\"\n            if not xyc_file.exists():\n                break\n\n            xy_bank = XYCModel.read(xyc_file)\n            bankline_list.append(LineString(xy_bank))\n            b += 1\n        bankline_series = GeoSeries(bankline_list, crs=self.crs)\n        banklines = GeoDataFrame(geometry=bankline_series)\n        return banklines\n\n    def get_parameter(\n        self,\n        group: str,\n        key: str,\n        bank_km: List[np.ndarray],\n        default=None,\n        ext: str = \"\",\n        positive: bool = False,\n        valid: Optional[List[float]] = None,\n        onefile: bool = False,\n    ) -&gt; List[np.ndarray]:\n        \"\"\"Get a parameter field from a selected group and keyword in the analysis settings.\n\n        Args:\n            group (str): Name of the group from which to read.\n            key (str): Name of the keyword from which to read.\n            bank_km (List[np.ndarray]): For each bank a listing of the bank points (bank chainage locations).\n            default (Optional[Union[float, List[np.ndarray]]]): Optional default value or default parameter field; default None.\n            ext (str): File name extension; default empty string.\n            positive (bool): Flag specifying which boolean values are accepted.\n                All values are accepted (if False), or only strictly positive values (if True); default False.\n            valid (Optional[List[float]]): Optional list of valid values; default None.\n            onefile (bool): Flag indicating whether parameters are read from one file.\n                One file should be used for all bank lines (True) or one file per bank line (False; default).\n\n        Raises:\n            Exception:\n                If a parameter isn't provided in the configuration, but no default value provided either.\n                If the value is negative while a positive value is required (positive = True).\n                If the value doesn't match one of the value values (valid is not None).\n\n        Returns:\n            List[np.ndarray]: Parameter field\n                For each bank a parameter value per bank point (bank chainage location).\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; bank_km = [np.array([0, 1, 2]), np.array([3, 4, 5])]\n            &gt;&gt;&gt; config_file.get_parameter(\"General\", \"ZoomStepKM\", bank_km)\n            [array([1., 1., 1.]), array([1., 1., 1.])]\n\n            ```\n        \"\"\"\n        try:\n            filename = self.config[group][key]\n            use_default = False\n        except (KeyError, TypeError) as e:\n            if default is None:\n                raise ConfigFileError(\n                    f'No value specified for required keyword \"{key}\" in block \"{group}\".'\n                ) from e\n            use_default = True\n\n        # if val is value then use that value globally\n        parfield = [None] * len(bank_km)\n        try:\n            if use_default:\n                if isinstance(default, list):\n                    return default\n                rval = default\n            else:\n                rval = float(filename)\n                if positive and rval &lt; 0:\n                    raise ValueError(\n                        f'Value of \"{key}\" should be positive, not {rval}.'\n                    )\n                if valid is not None and valid.count(rval) == 0:\n                    raise ValueError(\n                        f'Value of \"{key}\" should be in {valid}, not {rval}.'\n                    )\n            for ib, bkm in enumerate(bank_km):\n                parfield[ib] = np.zeros(len(bkm)) + rval\n        except (ValueError, TypeError):\n            if onefile:\n                log_text(\"read_param\", data={\"param\": key, \"file\": filename})\n                km_thr, val = get_kmval(filename, key, positive, valid)\n            for ib, bkm in enumerate(bank_km):\n                if not onefile:\n                    filename_i = filename + f\"_{ib + 1}\" + ext\n                    log_text(\n                        \"read_param_one_bank\",\n                        data={\"param\": key, \"i\": ib + 1, \"file\": filename_i},\n                    )\n                    km_thr, val = get_kmval(filename_i, key, positive, valid)\n                if km_thr is None:\n                    parfield[ib] = np.zeros(len(bkm)) + val[0]\n                else:\n                    idx = np.zeros(len(bkm), dtype=int)\n                    for thr in km_thr:\n                        idx[bkm &gt;= thr] += 1\n                    parfield[ib] = val[idx]\n                # print(\"Min/max of data: \", parfield[ib].min(), parfield[ib].max())\n        return parfield\n\n    def get_bank_search_distances(self, nbank: int) -&gt; List[float]:\n        \"\"\"Get the search distance per bank line from the analysis settings.\n\n        Args:\n            nbank (int): Number of bank search lines.\n\n        Returns:\n            List[float]: Array of length nbank containing the search distance value per bank line (default value: 50).\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.get_bank_search_distances(2)\n            [50.0, 50.0]\n\n            ```\n        \"\"\"\n        dlines_key = self.config[\"Detect\"].get(\"DLines\", None)\n        if dlines_key is None:\n            dlines = [50] * nbank\n        elif dlines_key[0] == \"[\" and dlines_key[-1] == \"]\":\n            dlines_split = dlines_key[1:-1].split(\",\")\n            dlines = [float(d) for d in dlines_split]\n            if not all([d &gt; 0 for d in dlines]):\n                raise ValueError(\n                    \"keyword DLINES should contain positive values in configuration file.\"\n                )\n            if len(dlines) != nbank:\n                raise ConfigFileError(\n                    \"keyword DLINES should contain NBANK values in configuration file.\"\n                )\n        return dlines\n\n    def get_range(self, group: str, key: str) -&gt; Tuple[float, float]:\n        \"\"\"Get a start and end value from a selected group and keyword in the analysis settings.\n\n        Args:\n            group (str): Name of the group from which to read.\n            key (str): Name of the keyword from which to read.\n\n        Returns:\n            Tuple[float,float]: Lower and upper limit of the range.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.get_range(\"General\", \"Boundaries\")\n            (123.0, 128.0)\n\n            ```\n        \"\"\"\n        str_val = self.get_str(group, key)\n        try:\n            obrack = str_val.find(\"[\")\n            cbrack = str_val.find(\"]\")\n            if obrack &gt;= 0 and cbrack &gt;= 0:\n                str_val = str_val[obrack + 1 : cbrack - 1]\n            val_list = [float(fstr) for fstr in str_val.split(\":\")]\n            if val_list[0] &gt; val_list[1]:\n                val = (val_list[1], val_list[0])\n            else:\n                val = (val_list[0], val_list[1])\n        except ValueError as e:\n            raise ValueError(\n                f'Invalid range specification \"{str_val}\" for required keyword \"{key}\" in block \"{group}\".'\n            ) from e\n        return val\n\n    def get_xy_km(self) -&gt; LineString:\n        \"\"\"Get the chainage line from the analysis settings.\n\n        Returns:\n            LineString: Chainage line.\n        \"\"\"\n        # get the chainage file\n        km_file = self.get_str(\"General\", \"RiverKM\")\n        log_text(\"read_chainage\", data={\"file\": km_file})\n        xy_km = XYCModel.read(km_file, num_columns=3)\n\n        # make sure that chainage is increasing with node index\n        if xy_km.coords[0][2] &gt; xy_km.coords[1][2]:\n            xy_km = LineString(xy_km.coords[::-1])\n\n        return xy_km\n\n    def resolve(self, rootdir: str):\n        \"\"\"Convert a configuration object to contain absolute paths (for editing).\n\n        Args:\n            rootdir (str): The path to be used as base for the absolute paths.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.resolve(\"tests/data/erosion\")\n\n            ```\n        \"\"\"\n        if \"General\" in self.config:\n            self.resolve_parameter(\"General\", \"RiverKM\", rootdir)\n            self.resolve_parameter(\"General\", \"BankDir\", rootdir)\n            self.resolve_parameter(\"General\", \"FigureDir\", rootdir)\n\n        if \"Detect\" in self.config:\n            self.resolve_parameter(\"Detect\", \"SimFile\", rootdir)\n            i = 0\n            while True:\n                i = i + 1\n                line_i = \"Line\" + str(i)\n                if line_i in self.config[\"Detect\"]:\n                    self.resolve_parameter(\"Detect\", line_i, rootdir)\n                else:\n                    break\n\n        if \"Erosion\" in self.config:\n            self.resolve_parameter(\"Erosion\", \"RiverAxis\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"Fairway\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"OutputDir\", rootdir)\n\n            self.resolve_parameter(\"Erosion\", \"ShipType\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"VShip\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"NShip\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"NWave\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"Draught\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"Wave0\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"Wave1\", rootdir)\n\n            self.resolve_parameter(\"Erosion\", \"BankType\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"ProtectionLevel\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"Slope\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"Reed\", rootdir)\n\n            n_level = self.get_int(\"Erosion\", \"NLevel\", default=0)\n            for i in range(1, n_level + 1):\n                self.resolve_parameter(\"Erosion\", f\"SimFile{i}\", rootdir)\n                self.resolve_parameter(\"Erosion\", f\"ShipType{i}\", rootdir)\n                self.resolve_parameter(\"Erosion\", f\"VShip{i}\", rootdir)\n                self.resolve_parameter(\"Erosion\", f\"NShip{i}\", rootdir)\n                self.resolve_parameter(\"Erosion\", f\"NWave{i}\", rootdir)\n                self.resolve_parameter(\"Erosion\", f\"Draught{i}\", rootdir)\n                self.resolve_parameter(\"Erosion\", f\"Slope{i}\", rootdir)\n                self.resolve_parameter(\"Erosion\", f\"Reed{i}\", rootdir)\n\n    def relative_to(self, rootdir: str) -&gt; None:\n        \"\"\"Convert a configuration object to contain relative paths (for saving).\n\n        Args:\n            rootdir (str): The path to be used as base for the relative paths.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.relative_to(\"testing/data/erosion\")\n\n            ```\n        \"\"\"\n        if \"General\" in self.config:\n            self.parameter_relative_to(\"General\", \"RiverKM\", rootdir)\n            self.parameter_relative_to(\"General\", \"BankDir\", rootdir)\n            self.parameter_relative_to(\"General\", \"FigureDir\", rootdir)\n\n        if \"Detect\" in self.config:\n            self.parameter_relative_to(\"Detect\", \"SimFile\", rootdir)\n\n            i = 0\n            while True:\n                i = i + 1\n                line_i = f\"Line{i}\"\n                if line_i in self.config[\"Detect\"]:\n                    self.parameter_relative_to(\"Detect\", line_i, rootdir)\n                else:\n                    break\n\n        if \"Erosion\" in self.config:\n            self.parameter_relative_to(\"Erosion\", \"RiverAxis\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"Fairway\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"OutputDir\", rootdir)\n\n            self.parameter_relative_to(\"Erosion\", \"ShipType\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"VShip\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"NShip\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"NWave\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"Draught\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"Wave0\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"Wave1\", rootdir)\n\n            self.parameter_relative_to(\"Erosion\", \"BankType\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"ProtectionLevel\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"Slope\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"Reed\", rootdir)\n\n            n_level = self.get_int(\"Erosion\", \"NLevel\", default=0)\n            for i in range(1, n_level + 1):\n                self.parameter_relative_to(\"Erosion\", f\"SimFile{i}\", rootdir)\n                self.parameter_relative_to(\"Erosion\", f\"ShipType{i}\", rootdir)\n                self.parameter_relative_to(\"Erosion\", f\"VShip{i}\", rootdir)\n                self.parameter_relative_to(\"Erosion\", f\"NShip{i}\", rootdir)\n                self.parameter_relative_to(\"Erosion\", f\"NWave{i}\", rootdir)\n                self.parameter_relative_to(\"Erosion\", f\"Draught{i}\", rootdir)\n                self.parameter_relative_to(\"Erosion\", f\"Slope{i}\", rootdir)\n                self.parameter_relative_to(\"Erosion\", f\"Reed{i}\", rootdir)\n\n    def resolve_parameter(self, group: str, key: str, rootdir: str):\n        \"\"\"Convert a parameter value to contain an absolute path.\n\n        Determine whether the string represents a number.\n        If not, try to convert to an absolute path.\n\n        Args:\n            group (str): Name of the group in the configuration.\n            key (str): Name of the key in the configuration.\n            rootdir (str): The path to be used as base for the absolute paths.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.resolve_parameter(\"General\", \"RiverKM\", \"tests/data/erosion\")\n\n            ```\n        \"\"\"\n        if key in self.config[group]:\n            val_str = self.config[group][key]\n            try:\n                float(val_str)\n            except ValueError:\n                self.config[group][key] = absolute_path(rootdir, val_str)\n\n    def parameter_relative_to(self, group: str, key: str, rootdir: str):\n        \"\"\"Convert a parameter value to contain a relative path.\n\n        Determine whether the string represents a number.\n        If not, try to convert to a relative path.\n\n        Args:\n            group (str): Name of the group in the configuration.\n            key (str): Name of the key in the configuration.\n            rootdir (str): The path to be used as base for the relative paths.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.parameter_relative_to(\"General\", \"RiverKM\", \"tests/data/erosion\")\n\n            ```\n        \"\"\"\n        if key in self.config[group]:\n            val_str = self.config[group][key]\n\n            try:\n                float(val_str)\n            except ValueError:\n                self.config[group][key] = relative_path(rootdir, val_str)\n\n    def get_plotting_flags(self, root_dir: str) -&gt; Dict[str, bool]:\n        \"\"\"Get the plotting flags from the configuration file.\n\n        Returns:\n            data (Dict[str, bool]):\n                Dictionary containing the plotting flags.\n                save_plot (bool): Flag indicating whether to save the plot.\n                save_plot_zoomed (bool): Flag indicating whether to save the zoomed plot.\n                zoom_km_step (float): Step size for zooming in on the plot.\n                close_plot (bool): Flag indicating whether to close the plot.\n        \"\"\"\n        plot_data = self.get_bool(\"General\", \"Plotting\", True)\n\n        if plot_data:\n            save_plot = self.get_bool(\"General\", \"SavePlots\", True)\n            save_plot_zoomed = self.get_bool(\"General\", \"SaveZoomPlots\", True)\n            zoom_km_step = self.get_float(\"General\", \"ZoomStepKM\", 1.0)\n            if zoom_km_step &lt; 0.01:\n                save_plot_zoomed = False\n            close_plot = self.get_bool(\"General\", \"ClosePlots\", False)\n        else:\n            save_plot = False\n            save_plot_zoomed = False\n            close_plot = False\n\n        data = {\n            \"plot_data\": plot_data,\n            \"save_plot\": save_plot,\n            \"save_plot_zoomed\": save_plot_zoomed,\n            \"zoom_km_step\": zoom_km_step,\n            \"close_plot\": close_plot,\n        }\n\n        # as appropriate, check output dir for figures and file format\n        if save_plot:\n            fig_dir = self.get_str(\"General\", \"FigureDir\", Path(root_dir) / \"figure\")\n            log_text(\"figure_dir\", data={\"dir\": fig_dir})\n            path_fig_dir = Path(fig_dir)\n            if path_fig_dir.exists():\n                log_text(\"overwrite_dir\", data={\"dir\": fig_dir})\n            path_fig_dir.mkdir(parents=True, exist_ok=True)\n            plot_ext = self.get_str(\"General\", \"FigureExt\", \".png\")\n            data = data | {\n                \"fig_dir\": fig_dir,\n                \"plot_ext\": plot_ext,\n            }\n\n        return data\n\n    def get_output_dir(self, option: str) -&gt; Path:\n        if option == \"banklines\":\n            output_dir = self.get_str(\"General\", \"BankDir\")\n        else:\n            output_dir = self.get_str(\"Erosion\", \"OutputDir\")\n\n        output_dir = Path(output_dir)\n        log_text(f\"{option}_out\", data={\"dir\": output_dir})\n        if output_dir.exists():\n            log_text(\"overwrite_dir\", data={\"dir\": output_dir})\n        else:\n            output_dir.mkdir(parents=True, exist_ok=True)\n\n        return output_dir\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.config","title":"<code>config: ConfigParser</code>  <code>property</code> <code>writable</code>","text":"<p>ConfigParser: Get the configuration settings.</p>"},{"location":"api/io.html#dfastbe.io.ConfigFile.root_dir","title":"<code>root_dir: Path</code>  <code>property</code> <code>writable</code>","text":"<p>Path: Get the root directory of the configuration file.</p>"},{"location":"api/io.html#dfastbe.io.ConfigFile.version","title":"<code>version: str</code>  <code>property</code>","text":"<p>str: Get the version of the configuration file.</p>"},{"location":"api/io.html#dfastbe.io.ConfigFile.config_file_callback_parser","title":"<code>config_file_callback_parser(path: str) -&gt; ConfigParser</code>  <code>staticmethod</code>","text":"<p>Parse a configuration file as fallback to the read method.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the configuration file.</p> required <p>Returns:</p> Name Type Description <code>ConfigParser</code> <code>ConfigParser</code> <p>Parsed configuration file.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>@staticmethod\ndef config_file_callback_parser(path: str) -&gt; ConfigParser:\n    \"\"\"Parse a configuration file as fallback to the read method.\n\n    Args:\n        path (str): Path to the configuration file.\n\n    Returns:\n        ConfigParser: Parsed configuration file.\n    \"\"\"\n    config = ConfigParser()\n    config[\"General\"] = {}\n    all_lines = open(path, \"r\").read().splitlines()\n    for line in all_lines:\n        perc = line.find(\"%\")\n        if perc &gt;= 0:\n            line = line[:perc]\n        data = line.split()\n        if len(data) &gt;= 3:\n            config[\"General\"][data[0]] = data[2]\n    return config\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.get_bank_lines","title":"<code>get_bank_lines(bank_dir: str) -&gt; List[np.ndarray]</code>","text":"<p>Get the bank lines from the detection step.</p> <p>Parameters:</p> Name Type Description Default <code>bank_dir</code> <code>str</code> <p>Name of directory in which the bank lines files are located.</p> required <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>List[np.ndarray]: List of arrays containing the x,y-coordinates of a bank lines.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def get_bank_lines(self, bank_dir: str) -&gt; List[np.ndarray]:\n    \"\"\"Get the bank lines from the detection step.\n\n    Args:\n        bank_dir (str): Name of directory in which the bank lines files are located.\n\n    Returns:\n        List[np.ndarray]: List of arrays containing the x,y-coordinates of a bank lines.\n    \"\"\"\n    bank_name = self.get_str(\"General\", \"BankFile\", \"bankfile\")\n    bankfile = Path(bank_dir) / f\"{bank_name}.shp\"\n    if bankfile.exists():\n        log_text(\"read_banklines\", data={\"file\": str(bankfile)})\n        return gpd.read_file(bankfile)\n\n    bankfile = Path(bank_dir) / f\"{bank_name}_#.xyc\"\n    log_text(\"read_banklines\", data={\"file\": str(bankfile)})\n    bankline_list = []\n    b = 1\n    while True:\n        xyc_file = Path(bank_dir) / f\"{bank_name}_{b}.xyc\"\n        if not xyc_file.exists():\n            break\n\n        xy_bank = XYCModel.read(xyc_file)\n        bankline_list.append(LineString(xy_bank))\n        b += 1\n    bankline_series = GeoSeries(bankline_list, crs=self.crs)\n    banklines = GeoDataFrame(geometry=bankline_series)\n    return banklines\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.get_bank_search_distances","title":"<code>get_bank_search_distances(nbank: int) -&gt; List[float]</code>","text":"<p>Get the search distance per bank line from the analysis settings.</p> <p>Parameters:</p> Name Type Description Default <code>nbank</code> <code>int</code> <p>Number of bank search lines.</p> required <p>Returns:</p> Type Description <code>List[float]</code> <p>List[float]: Array of length nbank containing the search distance value per bank line (default value: 50).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.get_bank_search_distances(2)\n[50.0, 50.0]\n</code></pre> Source code in <code>src/dfastbe/io.py</code> <pre><code>def get_bank_search_distances(self, nbank: int) -&gt; List[float]:\n    \"\"\"Get the search distance per bank line from the analysis settings.\n\n    Args:\n        nbank (int): Number of bank search lines.\n\n    Returns:\n        List[float]: Array of length nbank containing the search distance value per bank line (default value: 50).\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.get_bank_search_distances(2)\n        [50.0, 50.0]\n\n        ```\n    \"\"\"\n    dlines_key = self.config[\"Detect\"].get(\"DLines\", None)\n    if dlines_key is None:\n        dlines = [50] * nbank\n    elif dlines_key[0] == \"[\" and dlines_key[-1] == \"]\":\n        dlines_split = dlines_key[1:-1].split(\",\")\n        dlines = [float(d) for d in dlines_split]\n        if not all([d &gt; 0 for d in dlines]):\n            raise ValueError(\n                \"keyword DLINES should contain positive values in configuration file.\"\n            )\n        if len(dlines) != nbank:\n            raise ConfigFileError(\n                \"keyword DLINES should contain NBANK values in configuration file.\"\n            )\n    return dlines\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.get_bool","title":"<code>get_bool(group: str, key: str, default: Optional[bool] = None) -&gt; bool</code>","text":"<p>Get a boolean from a selected group and keyword in the analysis settings.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group from which to read.</p> required <code>key</code> <code>str</code> <p>Name of the keyword from which to read.</p> required <code>default</code> <code>Optional[bool]</code> <p>Optional default value.</p> <code>None</code> <p>Raises:</p> Type Description <code>ConfigFileError</code> <p>If the keyword isn't specified and no default value is given.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>value of the keyword as boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.get_bool(\"General\", \"Plotting\")\nTrue\n</code></pre> Source code in <code>src/dfastbe/io.py</code> <pre><code>def get_bool(\n    self,\n    group: str,\n    key: str,\n    default: Optional[bool] = None,\n) -&gt; bool:\n    \"\"\"Get a boolean from a selected group and keyword in the analysis settings.\n\n    Args:\n        group (str): Name of the group from which to read.\n        key (str): Name of the keyword from which to read.\n        default (Optional[bool]): Optional default value.\n\n    Raises:\n        ConfigFileError: If the keyword isn't specified and no default value is given.\n\n    Returns:\n        bool: value of the keyword as boolean.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.get_bool(\"General\", \"Plotting\")\n        True\n\n        ```\n    \"\"\"\n    try:\n        str_val = self.config[group][key].lower()\n        val = (\n            (str_val == \"yes\")\n            or (str_val == \"y\")\n            or (str_val == \"true\")\n            or (str_val == \"t\")\n            or (str_val == \"1\")\n        )\n    except KeyError as e:\n        if default is not None:\n            val = default\n        else:\n            raise ConfigFileError(\n                f\"No boolean value specified for required keyword {key} in block {group}.\"\n            ) from e\n\n    return val\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.get_float","title":"<code>get_float(group: str, key: str, default: Optional[float] = None, positive: bool = False) -&gt; float</code>","text":"<p>Get a floating point value from a selected group and keyword in the analysis settings.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group from which to read.</p> required <code>key</code> <code>str</code> <p>Name of the keyword from which to read.</p> required <code>default</code> <code>Optional[float]</code> <p>Optional default value.</p> <code>None</code> <code>positive</code> <code>bool</code> <p>Flag specifying which floats are accepted. All floats are accepted (if False), or only positive floats (if True).</p> <code>False</code> <p>Raises:</p> Type Description <code>ConfigFileError</code> <p>If the keyword isn't specified and no default value is given.</p> <code>ConfigFileError</code> <p>If a negative value is specified when a positive value is required.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>value of the keyword as float.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.get_float(\"General\", \"ZoomStepKM\")\n1.0\n</code></pre> Source code in <code>src/dfastbe/io.py</code> <pre><code>def get_float(\n    self,\n    group: str,\n    key: str,\n    default: Optional[float] = None,\n    positive: bool = False,\n) -&gt; float:\n    \"\"\"Get a floating point value from a selected group and keyword in the analysis settings.\n\n    Args:\n        group (str): Name of the group from which to read.\n        key (str): Name of the keyword from which to read.\n        default (Optional[float]): Optional default value.\n        positive (bool): Flag specifying which floats are accepted.\n            All floats are accepted (if False), or only positive floats (if True).\n\n    Raises:\n        ConfigFileError: If the keyword isn't specified and no default value is given.\n        ConfigFileError: If a negative value is specified when a positive value is required.\n\n\n    Returns:\n        float: value of the keyword as float.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.get_float(\"General\", \"ZoomStepKM\")\n        1.0\n\n        ```\n    \"\"\"\n    try:\n        val = float(self.config[group][key])\n    except (KeyError, ValueError) as e:\n        if default is not None:\n            val = default\n        else:\n            raise ConfigFileError(\n                f\"No floating point value specified for required keyword {key} in block {group}.\"\n            ) from e\n    if positive and val &lt; 0.0:\n        raise ConfigFileError(\n            f\"Value for {key} in block {group} must be positive, not {val}.\"\n        )\n    return val\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.get_int","title":"<code>get_int(group: str, key: str, default: Optional[int] = None, positive: bool = False) -&gt; int</code>","text":"<p>Get an integer from a selected group and keyword in the analysis settings.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group from which to read.</p> required <code>key</code> <code>str</code> <p>Name of the keyword from which to read.</p> required <code>default</code> <code>Optional[int]</code> <p>Optional default value.</p> <code>None</code> <code>positive</code> <code>bool</code> <p>Flag specifying which floats are accepted. All floats are accepted (if False), or only positive floats (if True).</p> <code>False</code> <p>Raises:</p> Type Description <code>ConfigFileError</code> <p>If the keyword isn't specified and no default value is given.</p> <code>ConfigFileError</code> <p>If a negative or zero value is specified when a positive value is required.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>value of the keyword as int.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.get_int(\"Detect\", \"NBank\")\n2\n</code></pre> Source code in <code>src/dfastbe/io.py</code> <pre><code>def get_int(\n    self,\n    group: str,\n    key: str,\n    default: Optional[int] = None,\n    positive: bool = False,\n) -&gt; int:\n    \"\"\"Get an integer from a selected group and keyword in the analysis settings.\n\n    Args:\n        group (str): Name of the group from which to read.\n        key (str): Name of the keyword from which to read.\n        default (Optional[int]): Optional default value.\n        positive (bool): Flag specifying which floats are accepted.\n            All floats are accepted (if False), or only positive floats (if True).\n\n    Raises:\n        ConfigFileError: If the keyword isn't specified and no default value is given.\n        ConfigFileError: If a negative or zero value is specified when a positive value is required.\n\n\n    Returns:\n        int: value of the keyword as int.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.get_int(\"Detect\", \"NBank\")\n        2\n\n        ```\n    \"\"\"\n    try:\n        val = int(self.config[group][key])\n    except (KeyError, ValueError) as e:\n        if default is not None:\n            val = default\n        else:\n            raise ConfigFileError(\n                f\"No integer value specified for required keyword {key} in block {group}.\"\n            ) from e\n    if positive and val &lt;= 0:\n        raise ConfigFileError(\n            f\"Value for {key} in block {group} must be positive, not {val}.\"\n        )\n    return val\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.get_km_bounds","title":"<code>get_km_bounds() -&gt; Tuple[float, float]</code>","text":"<p>Get the lower and upper limit for the chainage.</p> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float, float]: Lower and upper limit for the chainage.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.get_km_bounds()\n(123.0, 128.0)\n</code></pre> Source code in <code>src/dfastbe/io.py</code> <pre><code>def get_km_bounds(self) -&gt; Tuple[float, float]:\n    \"\"\"Get the lower and upper limit for the chainage.\n\n    Returns:\n        Tuple[float, float]: Lower and upper limit for the chainage.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.get_km_bounds()\n        (123.0, 128.0)\n\n        ```\n    \"\"\"\n    km_bounds = self.get_range(\"General\", \"Boundaries\")\n\n    return km_bounds\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.get_parameter","title":"<code>get_parameter(group: str, key: str, bank_km: List[np.ndarray], default=None, ext: str = '', positive: bool = False, valid: Optional[List[float]] = None, onefile: bool = False) -&gt; List[np.ndarray]</code>","text":"<p>Get a parameter field from a selected group and keyword in the analysis settings.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group from which to read.</p> required <code>key</code> <code>str</code> <p>Name of the keyword from which to read.</p> required <code>bank_km</code> <code>List[ndarray]</code> <p>For each bank a listing of the bank points (bank chainage locations).</p> required <code>default</code> <code>Optional[Union[float, List[ndarray]]]</code> <p>Optional default value or default parameter field; default None.</p> <code>None</code> <code>ext</code> <code>str</code> <p>File name extension; default empty string.</p> <code>''</code> <code>positive</code> <code>bool</code> <p>Flag specifying which boolean values are accepted. All values are accepted (if False), or only strictly positive values (if True); default False.</p> <code>False</code> <code>valid</code> <code>Optional[List[float]]</code> <p>Optional list of valid values; default None.</p> <code>None</code> <code>onefile</code> <code>bool</code> <p>Flag indicating whether parameters are read from one file. One file should be used for all bank lines (True) or one file per bank line (False; default).</p> <code>False</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If a parameter isn't provided in the configuration, but no default value provided either. If the value is negative while a positive value is required (positive = True). If the value doesn't match one of the value values (valid is not None).</p> <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>List[np.ndarray]: Parameter field For each bank a parameter value per bank point (bank chainage location).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; bank_km = [np.array([0, 1, 2]), np.array([3, 4, 5])]\n&gt;&gt;&gt; config_file.get_parameter(\"General\", \"ZoomStepKM\", bank_km)\n[array([1., 1., 1.]), array([1., 1., 1.])]\n</code></pre> Source code in <code>src/dfastbe/io.py</code> <pre><code>def get_parameter(\n    self,\n    group: str,\n    key: str,\n    bank_km: List[np.ndarray],\n    default=None,\n    ext: str = \"\",\n    positive: bool = False,\n    valid: Optional[List[float]] = None,\n    onefile: bool = False,\n) -&gt; List[np.ndarray]:\n    \"\"\"Get a parameter field from a selected group and keyword in the analysis settings.\n\n    Args:\n        group (str): Name of the group from which to read.\n        key (str): Name of the keyword from which to read.\n        bank_km (List[np.ndarray]): For each bank a listing of the bank points (bank chainage locations).\n        default (Optional[Union[float, List[np.ndarray]]]): Optional default value or default parameter field; default None.\n        ext (str): File name extension; default empty string.\n        positive (bool): Flag specifying which boolean values are accepted.\n            All values are accepted (if False), or only strictly positive values (if True); default False.\n        valid (Optional[List[float]]): Optional list of valid values; default None.\n        onefile (bool): Flag indicating whether parameters are read from one file.\n            One file should be used for all bank lines (True) or one file per bank line (False; default).\n\n    Raises:\n        Exception:\n            If a parameter isn't provided in the configuration, but no default value provided either.\n            If the value is negative while a positive value is required (positive = True).\n            If the value doesn't match one of the value values (valid is not None).\n\n    Returns:\n        List[np.ndarray]: Parameter field\n            For each bank a parameter value per bank point (bank chainage location).\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; bank_km = [np.array([0, 1, 2]), np.array([3, 4, 5])]\n        &gt;&gt;&gt; config_file.get_parameter(\"General\", \"ZoomStepKM\", bank_km)\n        [array([1., 1., 1.]), array([1., 1., 1.])]\n\n        ```\n    \"\"\"\n    try:\n        filename = self.config[group][key]\n        use_default = False\n    except (KeyError, TypeError) as e:\n        if default is None:\n            raise ConfigFileError(\n                f'No value specified for required keyword \"{key}\" in block \"{group}\".'\n            ) from e\n        use_default = True\n\n    # if val is value then use that value globally\n    parfield = [None] * len(bank_km)\n    try:\n        if use_default:\n            if isinstance(default, list):\n                return default\n            rval = default\n        else:\n            rval = float(filename)\n            if positive and rval &lt; 0:\n                raise ValueError(\n                    f'Value of \"{key}\" should be positive, not {rval}.'\n                )\n            if valid is not None and valid.count(rval) == 0:\n                raise ValueError(\n                    f'Value of \"{key}\" should be in {valid}, not {rval}.'\n                )\n        for ib, bkm in enumerate(bank_km):\n            parfield[ib] = np.zeros(len(bkm)) + rval\n    except (ValueError, TypeError):\n        if onefile:\n            log_text(\"read_param\", data={\"param\": key, \"file\": filename})\n            km_thr, val = get_kmval(filename, key, positive, valid)\n        for ib, bkm in enumerate(bank_km):\n            if not onefile:\n                filename_i = filename + f\"_{ib + 1}\" + ext\n                log_text(\n                    \"read_param_one_bank\",\n                    data={\"param\": key, \"i\": ib + 1, \"file\": filename_i},\n                )\n                km_thr, val = get_kmval(filename_i, key, positive, valid)\n            if km_thr is None:\n                parfield[ib] = np.zeros(len(bkm)) + val[0]\n            else:\n                idx = np.zeros(len(bkm), dtype=int)\n                for thr in km_thr:\n                    idx[bkm &gt;= thr] += 1\n                parfield[ib] = val[idx]\n            # print(\"Min/max of data: \", parfield[ib].min(), parfield[ib].max())\n    return parfield\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.get_plotting_flags","title":"<code>get_plotting_flags(root_dir: str) -&gt; Dict[str, bool]</code>","text":"<p>Get the plotting flags from the configuration file.</p> <p>Returns:</p> Name Type Description <code>data</code> <code>Dict[str, bool]</code> <p>Dictionary containing the plotting flags. save_plot (bool): Flag indicating whether to save the plot. save_plot_zoomed (bool): Flag indicating whether to save the zoomed plot. zoom_km_step (float): Step size for zooming in on the plot. close_plot (bool): Flag indicating whether to close the plot.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def get_plotting_flags(self, root_dir: str) -&gt; Dict[str, bool]:\n    \"\"\"Get the plotting flags from the configuration file.\n\n    Returns:\n        data (Dict[str, bool]):\n            Dictionary containing the plotting flags.\n            save_plot (bool): Flag indicating whether to save the plot.\n            save_plot_zoomed (bool): Flag indicating whether to save the zoomed plot.\n            zoom_km_step (float): Step size for zooming in on the plot.\n            close_plot (bool): Flag indicating whether to close the plot.\n    \"\"\"\n    plot_data = self.get_bool(\"General\", \"Plotting\", True)\n\n    if plot_data:\n        save_plot = self.get_bool(\"General\", \"SavePlots\", True)\n        save_plot_zoomed = self.get_bool(\"General\", \"SaveZoomPlots\", True)\n        zoom_km_step = self.get_float(\"General\", \"ZoomStepKM\", 1.0)\n        if zoom_km_step &lt; 0.01:\n            save_plot_zoomed = False\n        close_plot = self.get_bool(\"General\", \"ClosePlots\", False)\n    else:\n        save_plot = False\n        save_plot_zoomed = False\n        close_plot = False\n\n    data = {\n        \"plot_data\": plot_data,\n        \"save_plot\": save_plot,\n        \"save_plot_zoomed\": save_plot_zoomed,\n        \"zoom_km_step\": zoom_km_step,\n        \"close_plot\": close_plot,\n    }\n\n    # as appropriate, check output dir for figures and file format\n    if save_plot:\n        fig_dir = self.get_str(\"General\", \"FigureDir\", Path(root_dir) / \"figure\")\n        log_text(\"figure_dir\", data={\"dir\": fig_dir})\n        path_fig_dir = Path(fig_dir)\n        if path_fig_dir.exists():\n            log_text(\"overwrite_dir\", data={\"dir\": fig_dir})\n        path_fig_dir.mkdir(parents=True, exist_ok=True)\n        plot_ext = self.get_str(\"General\", \"FigureExt\", \".png\")\n        data = data | {\n            \"fig_dir\": fig_dir,\n            \"plot_ext\": plot_ext,\n        }\n\n    return data\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.get_range","title":"<code>get_range(group: str, key: str) -&gt; Tuple[float, float]</code>","text":"<p>Get a start and end value from a selected group and keyword in the analysis settings.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group from which to read.</p> required <code>key</code> <code>str</code> <p>Name of the keyword from which to read.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float,float]: Lower and upper limit of the range.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.get_range(\"General\", \"Boundaries\")\n(123.0, 128.0)\n</code></pre> Source code in <code>src/dfastbe/io.py</code> <pre><code>def get_range(self, group: str, key: str) -&gt; Tuple[float, float]:\n    \"\"\"Get a start and end value from a selected group and keyword in the analysis settings.\n\n    Args:\n        group (str): Name of the group from which to read.\n        key (str): Name of the keyword from which to read.\n\n    Returns:\n        Tuple[float,float]: Lower and upper limit of the range.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.get_range(\"General\", \"Boundaries\")\n        (123.0, 128.0)\n\n        ```\n    \"\"\"\n    str_val = self.get_str(group, key)\n    try:\n        obrack = str_val.find(\"[\")\n        cbrack = str_val.find(\"]\")\n        if obrack &gt;= 0 and cbrack &gt;= 0:\n            str_val = str_val[obrack + 1 : cbrack - 1]\n        val_list = [float(fstr) for fstr in str_val.split(\":\")]\n        if val_list[0] &gt; val_list[1]:\n            val = (val_list[1], val_list[0])\n        else:\n            val = (val_list[0], val_list[1])\n    except ValueError as e:\n        raise ValueError(\n            f'Invalid range specification \"{str_val}\" for required keyword \"{key}\" in block \"{group}\".'\n        ) from e\n    return val\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.get_search_lines","title":"<code>get_search_lines() -&gt; List[LineString]</code>","text":"<p>Get the search lines for the bank lines from the analysis settings.</p> <p>Returns:</p> Type Description <code>List[LineString]</code> <p>List[np.ndarray]: List of arrays containing the x,y-coordinates of a bank search lines.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def get_search_lines(self) -&gt; List[LineString]:\n    \"\"\"Get the search lines for the bank lines from the analysis settings.\n\n    Returns:\n        List[np.ndarray]: List of arrays containing the x,y-coordinates of a bank search lines.\n    \"\"\"\n    # read guiding bank line\n    n_bank = self.get_int(\"Detect\", \"NBank\")\n    line = [None] * n_bank\n    for b in range(n_bank):\n        bankfile = self.config[\"Detect\"][f\"Line{b + 1}\"]\n        log_text(\"read_search_line\", data={\"nr\": b + 1, \"file\": bankfile})\n        line[b] = XYCModel.read(bankfile)\n    return line\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.get_sim_file","title":"<code>get_sim_file(group: str, istr: str) -&gt; str</code>","text":"<p>Get the name of the simulation file from the analysis settings.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group in which to search for the simulation file name.</p> required <code>istr</code> <code>str</code> <p>Postfix for the simulation file name keyword; typically a string representation of the index.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name of the simulation file (empty string if keywords are not found).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; result = config_file.get_sim_file(\"Erosion\", \"1\")\n&gt;&gt;&gt; expected = Path(\"tests/data/erosion/inputs/sim0075/SDS-j19_map.nc\").resolve()\n&gt;&gt;&gt; str(expected) == result\nTrue\n</code></pre> Source code in <code>src/dfastbe/io.py</code> <pre><code>def get_sim_file(self, group: str, istr: str) -&gt; str:\n    \"\"\"Get the name of the simulation file from the analysis settings.\n\n    Args:\n        group (str): Name of the group in which to search for the simulation file name.\n        istr (str): Postfix for the simulation file name keyword;\n            typically a string representation of the index.\n\n    Returns:\n        str: Name of the simulation file (empty string if keywords are not found).\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; result = config_file.get_sim_file(\"Erosion\", \"1\")\n        &gt;&gt;&gt; expected = Path(\"tests/data/erosion/inputs/sim0075/SDS-j19_map.nc\").resolve()\n        &gt;&gt;&gt; str(expected) == result\n        True\n\n        ```\n    \"\"\"\n    sim_file = self.config[group].get(f\"SimFile{istr}\", \"\")\n    return sim_file\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.get_str","title":"<code>get_str(group: str, key: str, default: Optional[str] = None) -&gt; str</code>","text":"<p>Get a string from a selected group and keyword in the analysis settings.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group from which to read.</p> required <code>key</code> <code>str</code> <p>Name of the keyword from which to read.</p> required <code>default</code> <code>Optional[str]</code> <p>Optional default value.</p> <code>None</code> <p>Raises:</p> Type Description <code>ConfigFileError</code> <p>If the keyword isn't specified and no default value is given.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>value of the keyword as string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; result = config_file.get_str(\"General\", \"BankDir\")\n&gt;&gt;&gt; expected = Path(\"tests/data/erosion/output/banklines\").resolve()\n&gt;&gt;&gt; str(expected) == result\nTrue\n</code></pre> Source code in <code>src/dfastbe/io.py</code> <pre><code>def get_str(\n    self,\n    group: str,\n    key: str,\n    default: Optional[str] = None,\n) -&gt; str:\n    \"\"\"Get a string from a selected group and keyword in the analysis settings.\n\n    Args:\n        group (str): Name of the group from which to read.\n        key (str): Name of the keyword from which to read.\n        default (Optional[str]): Optional default value.\n\n    Raises:\n        ConfigFileError: If the keyword isn't specified and no default value is given.\n\n    Returns:\n        str: value of the keyword as string.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; result = config_file.get_str(\"General\", \"BankDir\")\n        &gt;&gt;&gt; expected = Path(\"tests/data/erosion/output/banklines\").resolve()\n        &gt;&gt;&gt; str(expected) == result\n        True\n\n        ```\n    \"\"\"\n    try:\n        val = self.config[group][key]\n    except KeyError as e:\n        if default is not None:\n            val = default\n        else:\n            raise ConfigFileError(\n                f\"No value specified for required keyword {key} in block {group}.\"\n            ) from e\n    return val\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.get_xy_km","title":"<code>get_xy_km() -&gt; LineString</code>","text":"<p>Get the chainage line from the analysis settings.</p> <p>Returns:</p> Name Type Description <code>LineString</code> <code>LineString</code> <p>Chainage line.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def get_xy_km(self) -&gt; LineString:\n    \"\"\"Get the chainage line from the analysis settings.\n\n    Returns:\n        LineString: Chainage line.\n    \"\"\"\n    # get the chainage file\n    km_file = self.get_str(\"General\", \"RiverKM\")\n    log_text(\"read_chainage\", data={\"file\": km_file})\n    xy_km = XYCModel.read(km_file, num_columns=3)\n\n    # make sure that chainage is increasing with node index\n    if xy_km.coords[0][2] &gt; xy_km.coords[1][2]:\n        xy_km = LineString(xy_km.coords[::-1])\n\n    return xy_km\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.make_paths_absolute","title":"<code>make_paths_absolute() -&gt; str</code>","text":"<p>Convert all relative paths in the configuration to absolute paths.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Absolute path of the configuration file's root directory.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def make_paths_absolute(self) -&gt; str:\n    \"\"\"Convert all relative paths in the configuration to absolute paths.\n\n    Returns:\n        str: Absolute path of the configuration file's root directory.\n    \"\"\"\n    self.resolve(self.root_dir)\n\n    return self.root_dir\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.parameter_relative_to","title":"<code>parameter_relative_to(group: str, key: str, rootdir: str)</code>","text":"<p>Convert a parameter value to contain a relative path.</p> <p>Determine whether the string represents a number. If not, try to convert to a relative path.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group in the configuration.</p> required <code>key</code> <code>str</code> <p>Name of the key in the configuration.</p> required <code>rootdir</code> <code>str</code> <p>The path to be used as base for the relative paths.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.parameter_relative_to(\"General\", \"RiverKM\", \"tests/data/erosion\")\n</code></pre> Source code in <code>src/dfastbe/io.py</code> <pre><code>def parameter_relative_to(self, group: str, key: str, rootdir: str):\n    \"\"\"Convert a parameter value to contain a relative path.\n\n    Determine whether the string represents a number.\n    If not, try to convert to a relative path.\n\n    Args:\n        group (str): Name of the group in the configuration.\n        key (str): Name of the key in the configuration.\n        rootdir (str): The path to be used as base for the relative paths.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.parameter_relative_to(\"General\", \"RiverKM\", \"tests/data/erosion\")\n\n        ```\n    \"\"\"\n    if key in self.config[group]:\n        val_str = self.config[group][key]\n\n        try:\n            float(val_str)\n        except ValueError:\n            self.config[group][key] = relative_path(rootdir, val_str)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.read","title":"<code>read(path: Union[str, Path]) -&gt; ConfigFile</code>  <code>classmethod</code>","text":"<p>Read a configParser object (configuration file).</p> <p>Reads the config file using the standard <code>configparser</code>. Falls back to a dedicated reader compatible with old waqbank files.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the configuration file.</p> required <p>Returns:</p> Name Type Description <code>ConfigFile</code> <code>ConfigFile</code> <p>Settings for the D-FAST Bank Erosion analysis.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the configuration file does not exist.</p> <code>Exception</code> <p>If there is an error reading the config file.</p> <p>Examples:</p> <p>Read a config file: <pre><code>&gt;&gt;&gt; from dfastbe.io import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n</code></pre></p> Source code in <code>src/dfastbe/io.py</code> <pre><code>@classmethod\ndef read(cls, path: Union[str, Path]) -&gt; \"ConfigFile\":\n    \"\"\"Read a configParser object (configuration file).\n\n    Reads the config file using the standard `configparser`. Falls back to a\n    dedicated reader compatible with old waqbank files.\n\n    Args:\n        path (Union[str, Path]): Path to the configuration file.\n\n    Returns:\n        ConfigFile: Settings for the D-FAST Bank Erosion analysis.\n\n    Raises:\n        FileNotFoundError: If the configuration file does not exist.\n        Exception: If there is an error reading the config file.\n\n    Examples:\n        Read a config file:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n\n        ```\n    \"\"\"\n    if not Path(path).exists():\n        raise FileNotFoundError(f\"The Config-File: {path} does not exist\")\n\n    try:\n        config = ConfigParser(comment_prefixes=\"%\")\n        with open(path, \"r\") as configfile:\n            config.read_file(configfile)\n    except ConfigparserError as e:\n        print(f\"Error during reading the config file: {e}\")\n        config = cls.config_file_callback_parser(path)\n\n    # if version != \"1.0\":\n    config = cls._upgrade(config)\n    return cls(config, path=path)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.relative_to","title":"<code>relative_to(rootdir: str) -&gt; None</code>","text":"<p>Convert a configuration object to contain relative paths (for saving).</p> <p>Parameters:</p> Name Type Description Default <code>rootdir</code> <code>str</code> <p>The path to be used as base for the relative paths.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.relative_to(\"testing/data/erosion\")\n</code></pre> Source code in <code>src/dfastbe/io.py</code> <pre><code>def relative_to(self, rootdir: str) -&gt; None:\n    \"\"\"Convert a configuration object to contain relative paths (for saving).\n\n    Args:\n        rootdir (str): The path to be used as base for the relative paths.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.relative_to(\"testing/data/erosion\")\n\n        ```\n    \"\"\"\n    if \"General\" in self.config:\n        self.parameter_relative_to(\"General\", \"RiverKM\", rootdir)\n        self.parameter_relative_to(\"General\", \"BankDir\", rootdir)\n        self.parameter_relative_to(\"General\", \"FigureDir\", rootdir)\n\n    if \"Detect\" in self.config:\n        self.parameter_relative_to(\"Detect\", \"SimFile\", rootdir)\n\n        i = 0\n        while True:\n            i = i + 1\n            line_i = f\"Line{i}\"\n            if line_i in self.config[\"Detect\"]:\n                self.parameter_relative_to(\"Detect\", line_i, rootdir)\n            else:\n                break\n\n    if \"Erosion\" in self.config:\n        self.parameter_relative_to(\"Erosion\", \"RiverAxis\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"Fairway\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"OutputDir\", rootdir)\n\n        self.parameter_relative_to(\"Erosion\", \"ShipType\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"VShip\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"NShip\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"NWave\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"Draught\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"Wave0\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"Wave1\", rootdir)\n\n        self.parameter_relative_to(\"Erosion\", \"BankType\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"ProtectionLevel\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"Slope\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"Reed\", rootdir)\n\n        n_level = self.get_int(\"Erosion\", \"NLevel\", default=0)\n        for i in range(1, n_level + 1):\n            self.parameter_relative_to(\"Erosion\", f\"SimFile{i}\", rootdir)\n            self.parameter_relative_to(\"Erosion\", f\"ShipType{i}\", rootdir)\n            self.parameter_relative_to(\"Erosion\", f\"VShip{i}\", rootdir)\n            self.parameter_relative_to(\"Erosion\", f\"NShip{i}\", rootdir)\n            self.parameter_relative_to(\"Erosion\", f\"NWave{i}\", rootdir)\n            self.parameter_relative_to(\"Erosion\", f\"Draught{i}\", rootdir)\n            self.parameter_relative_to(\"Erosion\", f\"Slope{i}\", rootdir)\n            self.parameter_relative_to(\"Erosion\", f\"Reed{i}\", rootdir)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.resolve","title":"<code>resolve(rootdir: str)</code>","text":"<p>Convert a configuration object to contain absolute paths (for editing).</p> <p>Parameters:</p> Name Type Description Default <code>rootdir</code> <code>str</code> <p>The path to be used as base for the absolute paths.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.resolve(\"tests/data/erosion\")\n</code></pre> Source code in <code>src/dfastbe/io.py</code> <pre><code>def resolve(self, rootdir: str):\n    \"\"\"Convert a configuration object to contain absolute paths (for editing).\n\n    Args:\n        rootdir (str): The path to be used as base for the absolute paths.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.resolve(\"tests/data/erosion\")\n\n        ```\n    \"\"\"\n    if \"General\" in self.config:\n        self.resolve_parameter(\"General\", \"RiverKM\", rootdir)\n        self.resolve_parameter(\"General\", \"BankDir\", rootdir)\n        self.resolve_parameter(\"General\", \"FigureDir\", rootdir)\n\n    if \"Detect\" in self.config:\n        self.resolve_parameter(\"Detect\", \"SimFile\", rootdir)\n        i = 0\n        while True:\n            i = i + 1\n            line_i = \"Line\" + str(i)\n            if line_i in self.config[\"Detect\"]:\n                self.resolve_parameter(\"Detect\", line_i, rootdir)\n            else:\n                break\n\n    if \"Erosion\" in self.config:\n        self.resolve_parameter(\"Erosion\", \"RiverAxis\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"Fairway\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"OutputDir\", rootdir)\n\n        self.resolve_parameter(\"Erosion\", \"ShipType\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"VShip\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"NShip\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"NWave\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"Draught\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"Wave0\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"Wave1\", rootdir)\n\n        self.resolve_parameter(\"Erosion\", \"BankType\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"ProtectionLevel\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"Slope\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"Reed\", rootdir)\n\n        n_level = self.get_int(\"Erosion\", \"NLevel\", default=0)\n        for i in range(1, n_level + 1):\n            self.resolve_parameter(\"Erosion\", f\"SimFile{i}\", rootdir)\n            self.resolve_parameter(\"Erosion\", f\"ShipType{i}\", rootdir)\n            self.resolve_parameter(\"Erosion\", f\"VShip{i}\", rootdir)\n            self.resolve_parameter(\"Erosion\", f\"NShip{i}\", rootdir)\n            self.resolve_parameter(\"Erosion\", f\"NWave{i}\", rootdir)\n            self.resolve_parameter(\"Erosion\", f\"Draught{i}\", rootdir)\n            self.resolve_parameter(\"Erosion\", f\"Slope{i}\", rootdir)\n            self.resolve_parameter(\"Erosion\", f\"Reed{i}\", rootdir)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.resolve_parameter","title":"<code>resolve_parameter(group: str, key: str, rootdir: str)</code>","text":"<p>Convert a parameter value to contain an absolute path.</p> <p>Determine whether the string represents a number. If not, try to convert to an absolute path.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group in the configuration.</p> required <code>key</code> <code>str</code> <p>Name of the key in the configuration.</p> required <code>rootdir</code> <code>str</code> <p>The path to be used as base for the absolute paths.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.resolve_parameter(\"General\", \"RiverKM\", \"tests/data/erosion\")\n</code></pre> Source code in <code>src/dfastbe/io.py</code> <pre><code>def resolve_parameter(self, group: str, key: str, rootdir: str):\n    \"\"\"Convert a parameter value to contain an absolute path.\n\n    Determine whether the string represents a number.\n    If not, try to convert to an absolute path.\n\n    Args:\n        group (str): Name of the group in the configuration.\n        key (str): Name of the key in the configuration.\n        rootdir (str): The path to be used as base for the absolute paths.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.resolve_parameter(\"General\", \"RiverKM\", \"tests/data/erosion\")\n\n        ```\n    \"\"\"\n    if key in self.config[group]:\n        val_str = self.config[group][key]\n        try:\n            float(val_str)\n        except ValueError:\n            self.config[group][key] = absolute_path(rootdir, val_str)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFile.write","title":"<code>write(filename: str) -&gt; None</code>","text":"<p>Pretty print a configParser object (configuration file) to file.</p> <p>Pretty prints a <code>configparser</code> object to a file. Aligns the equal signs for all keyword/value pairs, adds a two-space indentation to all keyword lines, and adds an empty line before the start of a new block.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of the configuration file to be written.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from dfastbe.io import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdirname:\n...     config_file.write(f\"{tmpdirname}/meuse_manual_out.cfg\")\n</code></pre> Source code in <code>src/dfastbe/io.py</code> <pre><code>def write(self, filename: str) -&gt; None:\n    \"\"\"Pretty print a configParser object (configuration file) to file.\n\n    Pretty prints a `configparser` object to a file. Aligns the equal signs for\n    all keyword/value pairs, adds a two-space indentation to all keyword lines,\n    and adds an empty line before the start of a new block.\n\n    Args:\n        filename (str): Name of the configuration file to be written.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; import tempfile\n        &gt;&gt;&gt; from dfastbe.io import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdirname:\n        ...     config_file.write(f\"{tmpdirname}/meuse_manual_out.cfg\")\n\n        ```\n    \"\"\"\n    sections = self.config.sections()\n    max_length = 0\n    for section in sections:\n        options = self.config.options(section)\n        max_length = max(max_length, *[len(option) for option in options])\n\n    with open(filename, \"w\") as configfile:\n        for index, section in enumerate(sections):\n            if index &gt; 0:\n                configfile.write(\"\\n\")\n            configfile.write(f\"[{section}]\\n\")\n\n            for option in self.config.options(section):\n                configfile.write(\n                    f\"  {option:&lt;{max_length}} = {self.config[section][option]}\\n\"\n                )\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ConfigFileError","title":"<code>ConfigFileError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for configuration file errors.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>class ConfigFileError(Exception):\n    \"\"\"Custom exception for configuration file errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/io.html#dfastbe.io.RiverData","title":"<code>RiverData</code>","text":"<p>River data class.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>class RiverData:\n    \"\"\"River data class.\"\"\"\n\n    def __init__(self, config_file: ConfigFile):\n        \"\"\"River Data initialization.\n\n        Args:\n            config_file : ConfigFile\n                Configuration file with settings for the analysis.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io import ConfigFile, RiverData\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; river_data = RiverData(config_file)\n            No message found for read_chainage\n            No message found for clip_chainage\n\n            ```\n        \"\"\"\n        self.config_file = config_file\n        self.profile: LineString = config_file.get_xy_km()\n        self.station_bounds: Tuple = config_file.get_km_bounds()\n        self.start_station: float = self.station_bounds[0]\n        self.end_station: float = self.station_bounds[1]\n        log_text(\n            \"clip_chainage\", data={\"low\": self.start_station, \"high\": self.end_station}\n        )\n        self.masked_profile: LineString = self.mask_profile(self.station_bounds)\n        self.masked_profile_arr = np.array(self.masked_profile.coords)\n\n    @property\n    def bank_search_lines(self) -&gt; List[LineString]:\n        \"\"\"Get the bank search lines.\n\n        Returns:\n            List[LineString]: List of bank search lines.\n        \"\"\"\n        return self.config_file.get_search_lines()\n\n    @property\n    def num_search_lines(self) -&gt; int:\n        \"\"\"Number of river bank search lines.\"\"\"\n        return len(self.bank_search_lines)\n\n    def mask_profile(self, bounds: Tuple[float, float]) -&gt; LineString:\n        \"\"\"\n        Clip a chainage line to the relevant reach.\n\n        Args:\n            bounds (Tuple[float, float]): Lower and upper limit for the chainage.\n\n        Returns:\n            LineString: Clipped river chainage line.\n        \"\"\"\n        xy_km = self.profile\n        start_i = None\n        end_i = None\n        for i, c in enumerate(xy_km.coords):\n            if start_i is None and c[2] &gt;= bounds[0]:\n                start_i = i\n            if c[2] &gt;= bounds[1]:\n                end_i = i\n                break\n\n        if start_i is None:\n            raise Exception(\n                \"Lower chainage bound {} is larger than the maximum chainage {} available\".format(\n                    bounds[0], xy_km.coords[-1][2]\n                )\n            )\n        elif start_i == 0:\n            # lower bound (potentially) clipped to available reach\n            if xy_km.coords[0][2] - bounds[0] &gt; 0.1:\n                raise Exception(\n                    \"Lower chainage bound {} is smaller than the minimum chainage {} available\".format(\n                        bounds[0], xy_km.coords[0][2]\n                    )\n                )\n            x0 = None\n        else:\n            alpha = (bounds[0] - xy_km.coords[start_i - 1][2]) / (\n                xy_km.coords[start_i][2] - xy_km.coords[start_i - 1][2]\n            )\n            x0 = tuple(\n                (c1 + alpha * (c2 - c1))\n                for c1, c2 in zip(xy_km.coords[start_i - 1], xy_km.coords[start_i])\n            )\n            if alpha &gt; 0.9:\n                # value close to the first node (start_i), so let's skip that one\n                start_i = start_i + 1\n\n        if end_i is None:\n            if bounds[1] - xy_km.coords[-1][2] &gt; 0.1:\n                raise Exception(\n                    \"Upper chainage bound {} is larger than the maximum chainage {} available\".format(\n                        bounds[1], xy_km.coords[-1][2]\n                    )\n                )\n            # else kmbounds[1] matches chainage of last point\n            if x0 is None:\n                # whole range available selected\n                pass\n            else:\n                xy_km = LineString([x0] + xy_km.coords[start_i:])\n        elif end_i == 0:\n            raise Exception(\n                \"Upper chainage bound {} is smaller than the minimum chainage {} available\".format(\n                    bounds[1], xy_km.coords[0][2]\n                )\n            )\n        else:\n            alpha = (bounds[1] - xy_km.coords[end_i - 1][2]) / (\n                xy_km.coords[end_i][2] - xy_km.coords[end_i - 1][2]\n            )\n            x1 = tuple(\n                (c1 + alpha * (c2 - c1))\n                for c1, c2 in zip(xy_km.coords[end_i - 1], xy_km.coords[end_i])\n            )\n            if alpha &lt; 0.1:\n                # value close to the previous point (end_i - 1), so let's skip that one\n                end_i = end_i - 1\n            if x0 is None:\n                xy_km = LineString(xy_km.coords[:end_i] + [x1])\n            else:\n                xy_km = LineString([x0] + xy_km.coords[start_i:end_i] + [x1])\n        return xy_km\n\n    def clip_search_lines(\n        self,\n        max_river_width: float = MAX_RIVER_WIDTH,\n    ) -&gt; Tuple[List[LineString], float]:\n        \"\"\"\n        Clip the list of lines to the envelope of certain size surrounding a reference line.\n\n        Arg:\n            max_river_width: float\n                Maximum distance away from river_profile.\n\n        Returns:\n            List[LineString]: List of clipped search lines.\n            float: Maximum distance from any point within line to reference line.\n        \"\"\"\n        search_lines = self.bank_search_lines\n        profile_buffer = self.masked_profile.buffer(max_river_width, cap_style=2)\n\n        # The algorithm uses simplified geometries for determining the distance between lines for speed.\n        # Stay accurate to within about 1 m\n        profile_simplified = self.masked_profile.simplify(1)\n\n        max_distance = 0\n        for ind in range(self.num_search_lines):\n            # Clip the bank search lines to the reach of interest (indicated by the reference line).\n            search_lines[ind] = search_lines[ind].intersection(profile_buffer)\n\n            # If the bank search line breaks into multiple parts, select the part closest to the reference line.\n            if search_lines[ind].geom_type == \"MultiLineString\":\n                distance_min = max_river_width\n                i_min = 0\n                for i in range(len(search_lines[ind])):\n                    line_simplified = search_lines[ind][i].simplify(1)\n                    distance_min_i = line_simplified.distance(profile_simplified)\n                    if distance_min_i &lt; distance_min:\n                        distance_min = distance_min_i\n                        i_min = i\n                search_lines[ind] = search_lines[ind][i_min]\n\n            # Determine the maximum distance from a point on this line to the reference line.\n            line_simplified = search_lines[ind].simplify(1)\n            max_distance = max(\n                [Point(c).distance(profile_simplified) for c in line_simplified.coords]\n            )\n\n            # Increase the value of max_distance by 2 to account for error introduced by using simplified lines.\n            max_distance = max(max_distance, max_distance + 2)\n\n        return search_lines, max_distance\n\n    def read_river_axis(self):\n        river_axis_file = self.config_file.get_str(\"Erosion\", \"RiverAxis\")\n        log_text(\"read_river_axis\", data={\"file\": river_axis_file})\n        river_axis = XYCModel.read(river_axis_file)\n        return river_axis\n</code></pre>"},{"location":"api/io.html#dfastbe.io.RiverData.bank_search_lines","title":"<code>bank_search_lines: List[LineString]</code>  <code>property</code>","text":"<p>Get the bank search lines.</p> <p>Returns:</p> Type Description <code>List[LineString]</code> <p>List[LineString]: List of bank search lines.</p>"},{"location":"api/io.html#dfastbe.io.RiverData.num_search_lines","title":"<code>num_search_lines: int</code>  <code>property</code>","text":"<p>Number of river bank search lines.</p>"},{"location":"api/io.html#dfastbe.io.RiverData.__init__","title":"<code>__init__(config_file: ConfigFile)</code>","text":"<p>River Data initialization.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <p>ConfigFile Configuration file with settings for the analysis.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io import ConfigFile, RiverData\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; river_data = RiverData(config_file)\nNo message found for read_chainage\nNo message found for clip_chainage\n</code></pre> Source code in <code>src/dfastbe/io.py</code> <pre><code>def __init__(self, config_file: ConfigFile):\n    \"\"\"River Data initialization.\n\n    Args:\n        config_file : ConfigFile\n            Configuration file with settings for the analysis.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io import ConfigFile, RiverData\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; river_data = RiverData(config_file)\n        No message found for read_chainage\n        No message found for clip_chainage\n\n        ```\n    \"\"\"\n    self.config_file = config_file\n    self.profile: LineString = config_file.get_xy_km()\n    self.station_bounds: Tuple = config_file.get_km_bounds()\n    self.start_station: float = self.station_bounds[0]\n    self.end_station: float = self.station_bounds[1]\n    log_text(\n        \"clip_chainage\", data={\"low\": self.start_station, \"high\": self.end_station}\n    )\n    self.masked_profile: LineString = self.mask_profile(self.station_bounds)\n    self.masked_profile_arr = np.array(self.masked_profile.coords)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.RiverData.clip_search_lines","title":"<code>clip_search_lines(max_river_width: float = MAX_RIVER_WIDTH) -&gt; Tuple[List[LineString], float]</code>","text":"<p>Clip the list of lines to the envelope of certain size surrounding a reference line.</p> Arg <p>max_river_width: float     Maximum distance away from river_profile.</p> <p>Returns:</p> Name Type Description <code>List[LineString]</code> <p>List[LineString]: List of clipped search lines.</p> <code>float</code> <code>float</code> <p>Maximum distance from any point within line to reference line.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def clip_search_lines(\n    self,\n    max_river_width: float = MAX_RIVER_WIDTH,\n) -&gt; Tuple[List[LineString], float]:\n    \"\"\"\n    Clip the list of lines to the envelope of certain size surrounding a reference line.\n\n    Arg:\n        max_river_width: float\n            Maximum distance away from river_profile.\n\n    Returns:\n        List[LineString]: List of clipped search lines.\n        float: Maximum distance from any point within line to reference line.\n    \"\"\"\n    search_lines = self.bank_search_lines\n    profile_buffer = self.masked_profile.buffer(max_river_width, cap_style=2)\n\n    # The algorithm uses simplified geometries for determining the distance between lines for speed.\n    # Stay accurate to within about 1 m\n    profile_simplified = self.masked_profile.simplify(1)\n\n    max_distance = 0\n    for ind in range(self.num_search_lines):\n        # Clip the bank search lines to the reach of interest (indicated by the reference line).\n        search_lines[ind] = search_lines[ind].intersection(profile_buffer)\n\n        # If the bank search line breaks into multiple parts, select the part closest to the reference line.\n        if search_lines[ind].geom_type == \"MultiLineString\":\n            distance_min = max_river_width\n            i_min = 0\n            for i in range(len(search_lines[ind])):\n                line_simplified = search_lines[ind][i].simplify(1)\n                distance_min_i = line_simplified.distance(profile_simplified)\n                if distance_min_i &lt; distance_min:\n                    distance_min = distance_min_i\n                    i_min = i\n            search_lines[ind] = search_lines[ind][i_min]\n\n        # Determine the maximum distance from a point on this line to the reference line.\n        line_simplified = search_lines[ind].simplify(1)\n        max_distance = max(\n            [Point(c).distance(profile_simplified) for c in line_simplified.coords]\n        )\n\n        # Increase the value of max_distance by 2 to account for error introduced by using simplified lines.\n        max_distance = max(max_distance, max_distance + 2)\n\n    return search_lines, max_distance\n</code></pre>"},{"location":"api/io.html#dfastbe.io.RiverData.mask_profile","title":"<code>mask_profile(bounds: Tuple[float, float]) -&gt; LineString</code>","text":"<p>Clip a chainage line to the relevant reach.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Tuple[float, float]</code> <p>Lower and upper limit for the chainage.</p> required <p>Returns:</p> Name Type Description <code>LineString</code> <code>LineString</code> <p>Clipped river chainage line.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def mask_profile(self, bounds: Tuple[float, float]) -&gt; LineString:\n    \"\"\"\n    Clip a chainage line to the relevant reach.\n\n    Args:\n        bounds (Tuple[float, float]): Lower and upper limit for the chainage.\n\n    Returns:\n        LineString: Clipped river chainage line.\n    \"\"\"\n    xy_km = self.profile\n    start_i = None\n    end_i = None\n    for i, c in enumerate(xy_km.coords):\n        if start_i is None and c[2] &gt;= bounds[0]:\n            start_i = i\n        if c[2] &gt;= bounds[1]:\n            end_i = i\n            break\n\n    if start_i is None:\n        raise Exception(\n            \"Lower chainage bound {} is larger than the maximum chainage {} available\".format(\n                bounds[0], xy_km.coords[-1][2]\n            )\n        )\n    elif start_i == 0:\n        # lower bound (potentially) clipped to available reach\n        if xy_km.coords[0][2] - bounds[0] &gt; 0.1:\n            raise Exception(\n                \"Lower chainage bound {} is smaller than the minimum chainage {} available\".format(\n                    bounds[0], xy_km.coords[0][2]\n                )\n            )\n        x0 = None\n    else:\n        alpha = (bounds[0] - xy_km.coords[start_i - 1][2]) / (\n            xy_km.coords[start_i][2] - xy_km.coords[start_i - 1][2]\n        )\n        x0 = tuple(\n            (c1 + alpha * (c2 - c1))\n            for c1, c2 in zip(xy_km.coords[start_i - 1], xy_km.coords[start_i])\n        )\n        if alpha &gt; 0.9:\n            # value close to the first node (start_i), so let's skip that one\n            start_i = start_i + 1\n\n    if end_i is None:\n        if bounds[1] - xy_km.coords[-1][2] &gt; 0.1:\n            raise Exception(\n                \"Upper chainage bound {} is larger than the maximum chainage {} available\".format(\n                    bounds[1], xy_km.coords[-1][2]\n                )\n            )\n        # else kmbounds[1] matches chainage of last point\n        if x0 is None:\n            # whole range available selected\n            pass\n        else:\n            xy_km = LineString([x0] + xy_km.coords[start_i:])\n    elif end_i == 0:\n        raise Exception(\n            \"Upper chainage bound {} is smaller than the minimum chainage {} available\".format(\n                bounds[1], xy_km.coords[0][2]\n            )\n        )\n    else:\n        alpha = (bounds[1] - xy_km.coords[end_i - 1][2]) / (\n            xy_km.coords[end_i][2] - xy_km.coords[end_i - 1][2]\n        )\n        x1 = tuple(\n            (c1 + alpha * (c2 - c1))\n            for c1, c2 in zip(xy_km.coords[end_i - 1], xy_km.coords[end_i])\n        )\n        if alpha &lt; 0.1:\n            # value close to the previous point (end_i - 1), so let's skip that one\n            end_i = end_i - 1\n        if x0 is None:\n            xy_km = LineString(xy_km.coords[:end_i] + [x1])\n        else:\n            xy_km = LineString([x0] + xy_km.coords[start_i:end_i] + [x1])\n    return xy_km\n</code></pre>"},{"location":"api/io.html#dfastbe.io.SimulationFilesError","title":"<code>SimulationFilesError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for configuration file errors.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>class SimulationFilesError(Exception):\n    \"\"\"Custom exception for configuration file errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/io.html#dfastbe.io.absolute_path","title":"<code>absolute_path(rootdir: str, path: str) -&gt; str</code>","text":"<p>Convert a relative path to an absolute path.</p> <p>Parameters:</p> Name Type Description Default <code>rootdir</code> <code>str</code> <p>Any relative paths should be given relative to this location.</p> required <code>path</code> <code>str</code> <p>A relative or absolute location.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>An absolute location.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def absolute_path(rootdir: str, path: str) -&gt; str:\n    \"\"\"\n    Convert a relative path to an absolute path.\n\n    Args:\n        rootdir (str): Any relative paths should be given relative to this location.\n        path (str): A relative or absolute location.\n\n    Returns:\n        str: An absolute location.\n    \"\"\"\n    if not path:\n        return path\n    root_path = Path(rootdir).resolve()\n    target_path = Path(path)\n\n    if target_path.is_absolute():\n        return str(target_path)\n\n    resolved_path = (root_path / target_path).resolve()\n    return str(resolved_path)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.clip_simulation_data","title":"<code>clip_simulation_data(sim: SimulationObject, river_profile: LineString, max_distance: float) -&gt; SimulationObject</code>","text":"<p>Clip the simulation mesh and data to the area of interest sufficiently close to the reference line.</p>"},{"location":"api/io.html#dfastbe.io.clip_simulation_data--arguments","title":"Arguments","text":"<p>sim : SimulationObject     Simulation data: mesh, bed levels, water levels, velocities, etc. river_profile : LineString     Reference line. max_distance : float     Maximum distance between the reference line and a point in the area of     interest defined based on the search lines for the banks and the search     distance.</p>"},{"location":"api/io.html#dfastbe.io.clip_simulation_data--returns","title":"Returns","text":"<p>sim1 : SimulationObject     Clipped simulation data: mesh, bed levels, water levels, velocities, etc.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def clip_simulation_data(\n    sim: SimulationObject, river_profile: LineString, max_distance: float\n) -&gt; SimulationObject:\n    \"\"\"\n    Clip the simulation mesh and data to the area of interest sufficiently close to the reference line.\n\n    Arguments\n    ---------\n    sim : SimulationObject\n        Simulation data: mesh, bed levels, water levels, velocities, etc.\n    river_profile : LineString\n        Reference line.\n    max_distance : float\n        Maximum distance between the reference line and a point in the area of\n        interest defined based on the search lines for the banks and the search\n        distance.\n\n    Returns\n    -------\n    sim1 : SimulationObject\n        Clipped simulation data: mesh, bed levels, water levels, velocities, etc.\n    \"\"\"\n    xy_buffer = river_profile.buffer(max_distance + max_distance)\n    bbox = xy_buffer.envelope.exterior\n    x_min = bbox.coords[0][0]\n    x_max = bbox.coords[1][0]\n    y_min = bbox.coords[0][1]\n    y_max = bbox.coords[2][1]\n\n    prepare(xy_buffer)\n    x = sim[\"x_node\"]\n    y = sim[\"y_node\"]\n    nnodes = x.shape\n    keep = (x &gt; x_min) &amp; (x &lt; x_max) &amp; (y &gt; y_min) &amp; (y &lt; y_max)\n    for i in range(x.size):\n        if keep[i] and not xy_buffer.contains(Point((x[i], y[i]))):\n            keep[i] = False\n\n    fnc = sim[\"facenode\"]\n    keep_face = keep[fnc].all(axis=1)\n    renum = np.zeros(nnodes, dtype=int)\n    renum[keep] = range(sum(keep))\n    sim[\"facenode\"] = renum[fnc[keep_face]]\n\n    sim[\"x_node\"] = x[keep]\n    sim[\"y_node\"] = y[keep]\n    if sim[\"zb_location\"] == \"node\":\n        sim[\"zb_val\"] = sim[\"zb_val\"][keep]\n    else:\n        sim[\"zb_val\"] = sim[\"zb_val\"][keep_face]\n\n    sim[\"nnodes\"] = sim[\"nnodes\"][keep_face]\n    sim[\"zw_face\"] = sim[\"zw_face\"][keep_face]\n    sim[\"h_face\"] = sim[\"h_face\"][keep_face]\n    sim[\"ucx_face\"] = sim[\"ucx_face\"][keep_face]\n    sim[\"ucy_face\"] = sim[\"ucy_face\"][keep_face]\n    sim[\"chz_face\"] = sim[\"chz_face\"][keep_face]\n\n    return sim\n</code></pre>"},{"location":"api/io.html#dfastbe.io.copy_ugrid","title":"<code>copy_ugrid(srcname: str, meshname: str, dstname: str) -&gt; None</code>","text":"<p>Copy UGRID mesh data from one netCDF file to another.</p> <p>Copy UGRID mesh data (mesh variable, all attributes, all variables that the UGRID attributes depend on) from source file to destination file.</p>"},{"location":"api/io.html#dfastbe.io.copy_ugrid--arguments","title":"Arguments","text":"<p>srcname : str     Name of source file. meshname : str     Name of the UGRID mesh to be copied from source to destination. dstname : str     Name of destination file, or dataset object representing the destination     file.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def copy_ugrid(srcname: str, meshname: str, dstname: str) -&gt; None:\n    \"\"\"\n    Copy UGRID mesh data from one netCDF file to another.\n\n    Copy UGRID mesh data (mesh variable, all attributes, all variables that the\n    UGRID attributes depend on) from source file to destination file.\n\n    Arguments\n    ---------\n    srcname : str\n        Name of source file.\n    meshname : str\n        Name of the UGRID mesh to be copied from source to destination.\n    dstname : str\n        Name of destination file, or dataset object representing the destination\n        file.\n    \"\"\"\n    # open source and destination files\n    src = netCDF4.Dataset(srcname)\n    dst = netCDF4.Dataset(dstname, \"w\", format=\"NETCDF4\")\n\n    # locate source mesh\n    mesh = src.variables[meshname]\n\n    # copy mesh variable\n    copy_var(src, meshname, dst)\n    atts = [\n        \"face_node_connectivity\",\n        \"edge_node_connectivity\",\n        \"edge_face_connectivity\",\n        \"face_coordinates\",\n        \"edge_coordinates\",\n        \"node_coordinates\",\n    ]\n    for att in atts:\n        try:\n            varlist = mesh.getncattr(att).split()\n        except:\n            varlist = []\n        for varname in varlist:\n            copy_var(src, varname, dst)\n\n            # check if variable has bounds attribute, if so copy those as well\n            var = src.variables[varname]\n            atts2 = [\"bounds\"]\n            for att2 in atts2:\n                try:\n                    varlist2 = var.getncattr(att2).split()\n                except:\n                    varlist2 = []\n                for varname2 in varlist2:\n                    copy_var(src, varname2, dst)\n\n    # close files\n    src.close()\n    dst.close()\n</code></pre>"},{"location":"api/io.html#dfastbe.io.copy_var","title":"<code>copy_var(src: netCDF4.Dataset, varname: str, dst: netCDF4.Dataset) -&gt; None</code>","text":"<p>Copy a single variable from one netCDF file to another.</p> <p>Copy a single netCDF variable including all attributes from source file to destination file. Create dimensions as necessary.</p>"},{"location":"api/io.html#dfastbe.io.copy_var--arguments","title":"Arguments","text":"<p>src : netCDF4.Dataset     Dataset object representing the source file. varname : str     Name of the netCDF variable to be copied from source to destination. dst : netCDF4.Dataset     Dataset object representing the destination file.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def copy_var(src: netCDF4.Dataset, varname: str, dst: netCDF4.Dataset) -&gt; None:\n    \"\"\"\n    Copy a single variable from one netCDF file to another.\n\n    Copy a single netCDF variable including all attributes from source file to\n    destination file. Create dimensions as necessary.\n\n    Arguments\n    ---------\n    src : netCDF4.Dataset\n        Dataset object representing the source file.\n    varname : str\n        Name of the netCDF variable to be copied from source to destination.\n    dst : netCDF4.Dataset\n        Dataset object representing the destination file.\n    \"\"\"\n    # locate the variable to be copied\n    srcvar = src.variables[varname]\n\n    # copy dimensions\n    for name in srcvar.dimensions:\n        dimension = src.dimensions[name]\n        if name not in dst.dimensions.keys():\n            dst.createDimension(\n                name, (len(dimension) if not dimension.isunlimited() else None)\n            )\n\n    # copy variable\n    dstvar = dst.createVariable(varname, srcvar.datatype, srcvar.dimensions)\n\n    # copy variable attributes all at once via dictionary\n    dstvar.setncatts(srcvar.__dict__)\n    dstvar[:] = srcvar[:]\n</code></pre>"},{"location":"api/io.html#dfastbe.io.get_filename","title":"<code>get_filename(key: str) -&gt; str</code>","text":"<p>Query the global dictionary of texts for a file name.</p> <p>The file name entries in the global dictionary have a prefix \"filename_\" which will be added to the key by this routine.</p>"},{"location":"api/io.html#dfastbe.io.get_filename--arguments","title":"Arguments","text":"<p>key : str     The key string used to query the dictionary.</p>"},{"location":"api/io.html#dfastbe.io.get_filename--results","title":"Results","text":"<p>filename : str     File name.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def get_filename(key: str) -&gt; str:\n    \"\"\"\n    Query the global dictionary of texts for a file name.\n\n    The file name entries in the global dictionary have a prefix \"filename_\"\n    which will be added to the key by this routine.\n\n    Arguments\n    ---------\n    key : str\n        The key string used to query the dictionary.\n\n    Results\n    -------\n    filename : str\n        File name.\n    \"\"\"\n    filename = get_text(\"filename_\" + key)[0]\n    return filename\n</code></pre>"},{"location":"api/io.html#dfastbe.io.get_kmval","title":"<code>get_kmval(filename: str, key: str, positive: bool, valid: Optional[List[float]])</code>","text":"<p>Read a parameter file, check its contents and return arrays of chainages and values.</p>"},{"location":"api/io.html#dfastbe.io.get_kmval--arguments","title":"Arguments","text":"<p>filename : str     Name of the parameter file to be read. key : str     Name of the quantity that we're reading. positive : bool     Flag specifying whether all values are accepted (if False), or only positive values (if True). valid : Optional[List[float]]     Optional list of valid values.</p>"},{"location":"api/io.html#dfastbe.io.get_kmval--raises","title":"Raises","text":"<p>Exception     If negative values are read while values are required to be positive (positive = True).     If some values are not valid when cross validated against the valid list (valid is not None).     If the chainage values in the file are not strictly increasing.</p>"},{"location":"api/io.html#dfastbe.io.get_kmval--returns","title":"Returns","text":"<p>km_thr : Optional[np.ndarray]     Array containing the chainage of the midpoints between the values. val : np.ndarray     Array containing the values.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def get_kmval(filename: str, key: str, positive: bool, valid: Optional[List[float]]):\n    \"\"\"\n    Read a parameter file, check its contents and return arrays of chainages and values.\n\n    Arguments\n    ---------\n    filename : str\n        Name of the parameter file to be read.\n    key : str\n        Name of the quantity that we're reading.\n    positive : bool\n        Flag specifying whether all values are accepted (if False), or only positive values (if True).\n    valid : Optional[List[float]]\n        Optional list of valid values.\n\n    Raises\n    ------\n    Exception\n        If negative values are read while values are required to be positive (positive = True).\n        If some values are not valid when cross validated against the valid list (valid is not None).\n        If the chainage values in the file are not strictly increasing.\n\n    Returns\n    -------\n    km_thr : Optional[np.ndarray]\n        Array containing the chainage of the midpoints between the values.\n    val : np.ndarray\n        Array containing the values.\n    \"\"\"\n    # print(\"Trying to read: \",filename)\n    points = pd.read_csv(\n        filename,\n        names=[\"Chainage\", \"Val\"],\n        skipinitialspace=True,\n        delim_whitespace=True,\n    )\n    # nPnts = len(P.Chainage)\n    km = points.Chainage.to_numpy()\n    val = points.Val.to_numpy()\n\n    if len(km.shape) == 0:\n        km = km[None]\n        val = val[None]\n\n    if positive and (val &lt; 0).any():\n        raise ValueError(f'Values of \"{key}\" in {filename} should be positive. Negative value read for chainage(s): {km[val &lt; 0]}')\n\n    if len(km) == 1:\n        km_thr = None\n    else:\n        if not (km[1:] &gt; km[:-1]).all():\n            raise ValueError(\n                f\"Chainage values are not increasing in the file {filename} read for {key}.\"\n            )\n        km_thr = km[1:]\n\n    return km_thr, val\n</code></pre>"},{"location":"api/io.html#dfastbe.io.get_mesh_and_facedim_names","title":"<code>get_mesh_and_facedim_names(filename: str) -&gt; Tuple[str, str]</code>","text":"<p>Obtain the names of 2D mesh and face dimension from netCDF UGRID file.</p>"},{"location":"api/io.html#dfastbe.io.get_mesh_and_facedim_names--arguments","title":"Arguments","text":"<p>filename : str     Name of the netCDF file.</p>"},{"location":"api/io.html#dfastbe.io.get_mesh_and_facedim_names--raises","title":"Raises","text":"<p>Exception     If there is not one mesh in the netCDF file.</p>"},{"location":"api/io.html#dfastbe.io.get_mesh_and_facedim_names--returns","title":"Returns","text":"<p>tuple : Tuple[str, str]     Name of the 2D mesh variable     Name of the face dimension of that 2D mesh</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def get_mesh_and_facedim_names(filename: str) -&gt; Tuple[str, str]:\n    \"\"\"\n    Obtain the names of 2D mesh and face dimension from netCDF UGRID file.\n\n    Arguments\n    ---------\n    filename : str\n        Name of the netCDF file.\n\n    Raises\n    ------\n    Exception\n        If there is not one mesh in the netCDF file.\n\n    Returns\n    -------\n    tuple : Tuple[str, str]\n        Name of the 2D mesh variable\n        Name of the face dimension of that 2D mesh\n    \"\"\"\n    # open file\n    rootgrp = netCDF4.Dataset(filename)\n\n    # locate 2d mesh variable\n    mesh2d = rootgrp.get_variables_by_attributes(\n        cf_role=\"mesh_topology\", topology_dimension=2\n    )\n    if len(mesh2d) != 1:\n        raise Exception(\n            \"Currently only one 2D mesh supported ... this file contains {} 2D meshes.\".format(\n                len(mesh2d)\n            )\n        )\n\n    #\n    facenodeconnect_varname = mesh2d[0].face_node_connectivity\n    fnc = rootgrp.get_variables_by_attributes(name=facenodeconnect_varname)[0]\n\n    # default\n    facedim = fnc.dimensions[0]\n    return mesh2d[0].name, facedim\n</code></pre>"},{"location":"api/io.html#dfastbe.io.get_text","title":"<code>get_text(key: str) -&gt; List[str]</code>","text":"<p>Query the global dictionary of texts via a string key.</p> <p>Query the global dictionary PROGTEXTS by means of a string key and return the list of strings contained in the dictionary. If the dictionary doesn't include the key, a default string is returned.</p>"},{"location":"api/io.html#dfastbe.io.get_text--parameters","title":"Parameters","text":"<p>key : str     The key string used to query the dictionary.</p>"},{"location":"api/io.html#dfastbe.io.get_text--returns","title":"Returns","text":"<p>text : List[str]     The list of strings returned contain the text stored in the dictionary     for the key. If the key isn't available in the dictionary, the routine     returns the default string \"No message found for \" Source code in <code>src/dfastbe/io.py</code> <pre><code>def get_text(key: str) -&gt; List[str]:\n    \"\"\"\n    Query the global dictionary of texts via a string key.\n\n    Query the global dictionary PROGTEXTS by means of a string key and return\n    the list of strings contained in the dictionary. If the dictionary doesn't\n    include the key, a default string is returned.\n\n    Parameters\n    ----------\n    key : str\n        The key string used to query the dictionary.\n\n    Returns\n    -------\n    text : List[str]\n        The list of strings returned contain the text stored in the dictionary\n        for the key. If the key isn't available in the dictionary, the routine\n        returns the default string \"No message found for &lt;key&gt;\"\n    \"\"\"\n\n    global PROGTEXTS\n\n    try:\n        str_value = PROGTEXTS[key]\n    except:\n        str_value = [\"No message found for \" + key]\n    return str_value\n</code></pre>"},{"location":"api/io.html#dfastbe.io.load_program_texts","title":"<code>load_program_texts(file_name: Union[str, Path]) -&gt; None</code>","text":"<p>Load texts from a configuration file, and store globally for access.</p> <p>This routine reads the text file \"file_name\", and detects the keywords indicated by lines starting with [ and ending with ]. The content is placed in a global dictionary PROGTEXTS which may be queried using the routine \"get_text\". These routines are used to implement multi-language support.</p>"},{"location":"api/io.html#dfastbe.io.load_program_texts--arguments","title":"Arguments","text":"<p>file_name : str     The name of the file to be read and parsed.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def load_program_texts(file_name: Union[str, Path]) -&gt; None:\n    \"\"\"Load texts from a configuration file, and store globally for access.\n\n    This routine reads the text file \"file_name\", and detects the keywords\n    indicated by lines starting with [ and ending with ]. The content is\n    placed in a global dictionary PROGTEXTS which may be queried using the\n    routine \"get_text\". These routines are used to implement multi-language support.\n\n    Arguments\n    ---------\n    file_name : str\n        The name of the file to be read and parsed.\n    \"\"\"\n    global PROGTEXTS\n\n    all_lines = open(file_name, \"r\").read().splitlines()\n    data: Dict[str, List[str]] = {}\n    text: List[str] = []\n    key = None\n    for line in all_lines:\n        r_line = line.strip()\n        if r_line.startswith(\"[\") and r_line.endswith(\"]\"):\n            if key is not None:\n                data[key] = text\n            key = r_line[1:-1]\n            text = []\n        else:\n            text.append(line)\n    if key in data.keys():\n        raise ValueError(f\"Duplicate entry for {key} in {file_name}.\")\n\n    if key is not None:\n        data[key] = text\n\n    PROGTEXTS = data\n</code></pre>"},{"location":"api/io.html#dfastbe.io.log_text","title":"<code>log_text(key: str, file: Optional[TextIO] = None, data: Dict[str, Any] = {}, repeat: int = 1, indent: str = '') -&gt; None</code>","text":"<p>Write a text to standard out or file.</p>"},{"location":"api/io.html#dfastbe.io.log_text--arguments","title":"Arguments","text":"<p>key : str     The key for the text to show to the user. file : Optional[TextIO]     The file to write to (None for writing to standard out). data : Dict[str, Any]     A dictionary used for placeholder expansions (default empty). repeat : int     The number of times that the same text should be repeated (default 1). indent : str     String to use for each line as indentation (default empty).</p>"},{"location":"api/io.html#dfastbe.io.log_text--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def log_text(\n    key: str,\n    file: Optional[TextIO] = None,\n    data: Dict[str, Any] = {},\n    repeat: int = 1,\n    indent: str = \"\",\n) -&gt; None:\n    \"\"\"\n    Write a text to standard out or file.\n\n    Arguments\n    ---------\n    key : str\n        The key for the text to show to the user.\n    file : Optional[TextIO]\n        The file to write to (None for writing to standard out).\n    data : Dict[str, Any]\n        A dictionary used for placeholder expansions (default empty).\n    repeat : int\n        The number of times that the same text should be repeated (default 1).\n    indent : str\n        String to use for each line as indentation (default empty).\n\n    Returns\n    -------\n    None\n    \"\"\"\n    str_value = get_text(key)\n    for _ in range(repeat):\n        for s in str_value:\n            sexp = s.format(**data)\n            if file is None:\n                print(indent + sexp)\n            else:\n                file.write(indent + sexp + \"\\n\")\n</code></pre>"},{"location":"api/io.html#dfastbe.io.move_parameter_location","title":"<code>move_parameter_location(config: ConfigParser, group1: str, key1: str, group2: str, key2: Optional[str] = None, convert: Optional[Callable[[str], str]] = None) -&gt; ConfigParser</code>","text":"<p>Move a parameter from one group/keyword to another.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <p>ConfigParser Original settings for the D-FAST Bank Erosion analysis.</p> required <code>group1</code> <p>str Name of the group in the original configuration.</p> required <code>key1</code> <p>str Name of the keyword in the original configuration.</p> required <code>group2</code> <p>str Name of the group in the target configuration.</p> required <code>key2</code> <p>Optional[str] Name of the keyword in the target configuration (can be None if equal to the keyword in the original file).</p> <code>None</code> <code>convert</code> <code>Optional[Callable[[str], str]]</code> <p>Optional[Callable[[str], str]] Function to convert the original value into new value.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>config</code> <code>ConfigParser</code> <p>ConfigParser Updated settings for the D-FAST Bank Erosion analysis.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def move_parameter_location(\n    config: ConfigParser,\n    group1: str,\n    key1: str,\n    group2: str,\n    key2: Optional[str] = None,\n    convert: Optional[Callable[[str], str]] = None,\n) -&gt; ConfigParser:\n    \"\"\"\n    Move a parameter from one group/keyword to another.\n\n    Args:\n        config : ConfigParser\n            Original settings for the D-FAST Bank Erosion analysis.\n        group1 : str\n            Name of the group in the original configuration.\n        key1 : str\n            Name of the keyword in the original configuration.\n        group2 : str\n            Name of the group in the target configuration.\n        key2 : Optional[str]\n            Name of the keyword in the target configuration (can be None if equal to the keyword in the original file).\n        convert: Optional[Callable[[str], str]]\n            Function to convert the original value into new value.\n\n    Returns:\n        config : ConfigParser\n            Updated settings for the D-FAST Bank Erosion analysis.\n    \"\"\"\n    val2: str\n    if group1 in config.sections() and key1 in config[group1]:\n        if key2 is None:\n            key2 = key1\n        val1 = config[group1][key1]\n        if convert is None:\n            val2 = val1\n        else:\n            val2 = convert(val1)\n        config[group2][key2] = val2\n        config[group1].pop(key1)\n    return config\n</code></pre>"},{"location":"api/io.html#dfastbe.io.read_fm_map","title":"<code>read_fm_map(filename: str, varname: str, location: str = 'face') -&gt; np.ndarray</code>","text":"<p>Read the last time step of any quantity defined at faces from a D-Flow FM map-file.</p>"},{"location":"api/io.html#dfastbe.io.read_fm_map--arguments","title":"Arguments","text":"<p>filename : str     Name of the D-Flow FM map.nc file to read the data. varname : str     Name of the netCDF variable to be read. location : str     Name of the stagger location at which the data should be located     (default is \"face\")</p>"},{"location":"api/io.html#dfastbe.io.read_fm_map--raises","title":"Raises","text":"<p>Exception     If the data file doesn't include a 2D mesh.     If it cannot uniquely identify the variable to be read.</p>"},{"location":"api/io.html#dfastbe.io.read_fm_map--returns","title":"Returns","text":"<p>data     Data of the requested variable (for the last time step only if the variable is     time dependent).</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def read_fm_map(filename: str, varname: str, location: str = \"face\") -&gt; np.ndarray:\n    \"\"\"\n    Read the last time step of any quantity defined at faces from a D-Flow FM map-file.\n\n    Arguments\n    ---------\n    filename : str\n        Name of the D-Flow FM map.nc file to read the data.\n    varname : str\n        Name of the netCDF variable to be read.\n    location : str\n        Name of the stagger location at which the data should be located\n        (default is \"face\")\n\n    Raises\n    ------\n    Exception\n        If the data file doesn't include a 2D mesh.\n        If it cannot uniquely identify the variable to be read.\n\n    Returns\n    -------\n    data\n        Data of the requested variable (for the last time step only if the variable is\n        time dependent).\n    \"\"\"\n    # open file\n    rootgrp = netCDF4.Dataset(filename)\n\n    # locate 2d mesh variable\n    mesh2d = rootgrp.get_variables_by_attributes(\n        cf_role=\"mesh_topology\", topology_dimension=2\n    )\n    if len(mesh2d) != 1:\n        raise Exception(\n            \"Currently only one 2D mesh supported ... this file contains {} 2D meshes.\".format(\n                len(mesh2d)\n            )\n        )\n    meshname = mesh2d[0].name\n\n    # define a default start_index\n    start_index = 0\n\n    # locate the requested variable ... start with some special cases\n    if varname == \"x\":\n        # the x-coordinate or longitude\n        crdnames = mesh2d[0].getncattr(location + \"_coordinates\").split()\n        for n in crdnames:\n            stdname = rootgrp.variables[n].standard_name\n            if stdname == \"projection_x_coordinate\" or stdname == \"longitude\":\n                var = rootgrp.variables[n]\n                break\n\n    elif varname == \"y\":\n        # the y-coordinate or latitude\n        crdnames = mesh2d[0].getncattr(location + \"_coordinates\").split()\n        for n in crdnames:\n            stdname = rootgrp.variables[n].standard_name\n            if stdname == \"projection_y_coordinate\" or stdname == \"latitude\":\n                var = rootgrp.variables[n]\n                break\n\n    elif varname.endswith(\"connectivity\"):\n        # a mesh connectivity variable with corrected index\n        varname = mesh2d[0].getncattr(varname)\n        var = rootgrp.variables[varname]\n        if \"start_index\" in var.ncattrs():\n            start_index = var.getncattr(\"start_index\")\n\n    else:\n        # find any other variable by standard_name or long_name\n        var = rootgrp.get_variables_by_attributes(\n            standard_name=varname, mesh=meshname, location=location\n        )\n        if len(var) == 0:\n            var = rootgrp.get_variables_by_attributes(\n                long_name=varname, mesh=meshname, location=location\n            )\n        if len(var) != 1:\n            raise Exception(\n                'Expected one variable for \"{}\", but obtained {}.'.format(\n                    varname, len(var)\n                )\n            )\n        var = var[0]\n\n    # read data checking for time dimension\n    if var.get_dims()[0].isunlimited():\n        # assume that time dimension is unlimited and is the first dimension\n        # slice to obtain last time step\n        data = var[-1, :]\n    else:\n        data = var[...] - start_index\n\n    rootgrp.close()\n\n    return data\n</code></pre>"},{"location":"api/io.html#dfastbe.io.read_simulation_data","title":"<code>read_simulation_data(file_name: str, indent: str = '') -&gt; Tuple[SimulationObject, float]</code>","text":"<p>Read a default set of quantities from a UGRID netCDF file coming from D-Flow FM (or similar).</p>"},{"location":"api/io.html#dfastbe.io.read_simulation_data--arguments","title":"Arguments","text":"<p>file_name : str     Name of the simulation output file to be read. indent : str     String to use for each line as indentation (default empty).</p>"},{"location":"api/io.html#dfastbe.io.read_simulation_data--raises","title":"Raises","text":"<p>Exception     If the file is not recognized as a D-Flow FM map-file.</p>"},{"location":"api/io.html#dfastbe.io.read_simulation_data--returns","title":"Returns","text":"<p>sim : SimulationObject     Dictionary containing the data read from the simulation output file. dh0 : float     Threshold depth for detecting drying and flooding.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def read_simulation_data(\n    file_name: str, indent: str = \"\"\n) -&gt; Tuple[SimulationObject, float]:\n    \"\"\"\n    Read a default set of quantities from a UGRID netCDF file coming from D-Flow FM (or similar).\n\n    Arguments\n    ---------\n    file_name : str\n        Name of the simulation output file to be read.\n    indent : str\n        String to use for each line as indentation (default empty).\n\n    Raises\n    ------\n    Exception\n        If the file is not recognized as a D-Flow FM map-file.\n\n    Returns\n    -------\n    sim : SimulationObject\n        Dictionary containing the data read from the simulation output file.\n    dh0 : float\n        Threshold depth for detecting drying and flooding.\n    \"\"\"\n    dum = np.array([])\n    sim: SimulationObject = {\n        \"x_node\": dum,\n        \"y_node\": dum,\n        \"nnodes\": dum,\n        \"facenode\": dum,\n        \"zb_location\": dum,\n        \"zb_val\": dum,\n        \"zw_face\": dum,\n        \"h_face\": dum,\n        \"ucx_face\": dum,\n        \"ucy_face\": dum,\n        \"chz_face\": dum,\n    }\n    # determine the file type\n    name = Path(file_name).name\n    if name.endswith(\"map.nc\"):\n        log_text(\"read_grid\", indent=indent)\n        sim[\"x_node\"] = read_fm_map(file_name, \"x\", location=\"node\")\n        sim[\"y_node\"] = read_fm_map(file_name, \"y\", location=\"node\")\n        f_nc = read_fm_map(file_name, \"face_node_connectivity\")\n        if f_nc.mask.shape == ():\n            # all faces have the same number of nodes\n            sim[\"nnodes\"] = (\n                np.ones(f_nc.data.shape[0], dtype=int) * f_nc.data.shape[1]\n            )\n        else:\n            # varying number of nodes\n            sim[\"nnodes\"] = f_nc.mask.shape[1] - f_nc.mask.sum(axis=1)\n        f_nc.data[f_nc.mask] = 0\n\n        sim[\"facenode\"] = f_nc\n        log_text(\"read_bathymetry\", indent=indent)\n        sim[\"zb_location\"] = \"node\"\n        sim[\"zb_val\"] = read_fm_map(file_name, \"altitude\", location=\"node\")\n        log_text(\"read_water_level\", indent=indent)\n        sim[\"zw_face\"] = read_fm_map(file_name, \"Water level\")\n        log_text(\"read_water_depth\", indent=indent)\n        sim[\"h_face\"] = np.maximum(\n            read_fm_map(file_name, \"sea_floor_depth_below_sea_surface\"), 0.0\n        )\n        log_text(\"read_velocity\", indent=indent)\n        sim[\"ucx_face\"] = read_fm_map(file_name, \"sea_water_x_velocity\")\n        sim[\"ucy_face\"] = read_fm_map(file_name, \"sea_water_y_velocity\")\n        log_text(\"read_chezy\", indent=indent)\n        sim[\"chz_face\"] = read_fm_map(file_name, \"Chezy roughness\")\n\n        log_text(\"read_drywet\", indent=indent)\n        root_group = netCDF4.Dataset(file_name)\n        try:\n            file_source = root_group.converted_from\n            if file_source == \"SIMONA\":\n                dh0 = 0.1\n            else:\n                dh0 = 0.01\n        except:\n            dh0 = 0.01\n\n    elif name.startswith(\"SDS\"):\n        raise SimulationFilesError(\n            f\"WAQUA output files not yet supported. Unable to process {name}\"\n        )\n    elif name.startswith(\"trim\"):\n        raise SimulationFilesError(\n            f\"Delft3D map files not yet supported. Unable to process {name}\"\n        )\n    else:\n        raise SimulationFilesError(f\"Unable to determine file type for {name}\")\n\n    return sim, dh0\n</code></pre>"},{"location":"api/io.html#dfastbe.io.read_waqua_xyz","title":"<code>read_waqua_xyz(filename: str, cols: Tuple[int, ...] = (2,)) -&gt; np.ndarray</code>","text":"<p>Read data columns from a SIMONA XYZ file.</p>"},{"location":"api/io.html#dfastbe.io.read_waqua_xyz--arguments","title":"Arguments","text":"<p>filename : str     Name of file to be read. cols : Tuple[int]     List of column numbers for which to return the data.</p>"},{"location":"api/io.html#dfastbe.io.read_waqua_xyz--returns","title":"Returns","text":"<p>data : np.ndarray     Data read from the file.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def read_waqua_xyz(filename: str, cols: Tuple[int, ...] = (2,)) -&gt; np.ndarray:\n    \"\"\"\n    Read data columns from a SIMONA XYZ file.\n\n    Arguments\n    ---------\n    filename : str\n        Name of file to be read.\n    cols : Tuple[int]\n        List of column numbers for which to return the data.\n\n    Returns\n    -------\n    data : np.ndarray\n        Data read from the file.\n    \"\"\"\n    data = np.genfromtxt(filename, delimiter=\",\", skip_header=1, usecols=cols)\n    return data\n</code></pre>"},{"location":"api/io.html#dfastbe.io.relative_path","title":"<code>relative_path(rootdir: str, file: str) -&gt; str</code>","text":"<p>Convert an absolute path to a relative path.</p> <p>Parameters:</p> Name Type Description Default <code>rootdir</code> <code>str</code> <p>Any relative paths will be given relative to this location.</p> required <code>file</code> <code>str</code> <p>An absolute location.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A relative location if possible, otherwise the absolute location.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def relative_path(rootdir: str, file: str) -&gt; str:\n    \"\"\"\n    Convert an absolute path to a relative path.\n\n    Args:\n        rootdir (str): Any relative paths will be given relative to this location.\n        file (str): An absolute location.\n\n    Returns:\n        str: A relative location if possible, otherwise the absolute location.\n    \"\"\"\n    if not file:\n        return file\n\n    root_path = Path(rootdir).resolve()\n    file_path = Path(file).resolve()\n\n    try:\n        return str(file_path.relative_to(root_path))\n    except ValueError:\n        return str(file_path)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.sim2nc","title":"<code>sim2nc(oldfile: str) -&gt; str</code>","text":"<p>Convert an SDS file name to an NC file (mirrors sim2ugrid.m).</p> <p>Parameters:</p> Name Type Description Default <code>oldfile</code> <code>str</code> <p>Name of the original SIMONA SDS or Delft3D-FLOW TRIM file.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name of the netCDF file as created by sim2ugrid.m.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def sim2nc(oldfile: str) -&gt; str:\n    \"\"\"\n    Convert an SDS file name to an NC file (mirrors sim2ugrid.m).\n\n    Args:\n        oldfile (str):Name of the original SIMONA SDS or Delft3D-FLOW TRIM file.\n\n    Returns:\n        str: Name of the netCDF file as created by sim2ugrid.m.\n    \"\"\"\n    name = Path(oldfile).name\n    if name.startswith(\"SDS\"):\n        # SDS-case_map.nc\n        nc_file = f\"{oldfile}_map.nc\"\n    elif name.startswith(\"trim\"):\n        # trim-case_map.nc\n        nc_file = f\"{Path(oldfile).stem}_map.nc\"\n    else:\n        raise SimulationFilesError(f'Unable to determine file type for \"{oldfile}\"')\n    return nc_file\n</code></pre>"},{"location":"api/io.html#dfastbe.io.ugrid_add","title":"<code>ugrid_add(dstfile: str, varname: str, ldata: np.array, meshname: str, facedim: str, long_name: str = 'None', units: str = 'None') -&gt; None</code>","text":"<p>Add a new variable defined at faces to an existing UGRID netCDF file</p>"},{"location":"api/io.html#dfastbe.io.ugrid_add--arguments","title":"Arguments","text":"<p>dstfile : str     Name of netCDF file to write data to. varname : str     Name of netCDF variable to be written. ldata : np.array     Linear array containing the data to be written. meshname : str     Name of mesh variable in the netCDF file. facedim : str     Name of the face dimension of the selected mesh. long_name : str     Long descriptive name for the variable (\"None\" if no long name attribute     should be written). units : str     String indicating the unit (\"None\" if no unit attribute should be written).</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def ugrid_add(\n    dstfile: str,\n    varname: str,\n    ldata: np.array,\n    meshname: str,\n    facedim: str,\n    long_name: str = \"None\",\n    units: str = \"None\",\n) -&gt; None:\n    \"\"\"\n    Add a new variable defined at faces to an existing UGRID netCDF file\n\n    Arguments\n    ---------\n    dstfile : str\n        Name of netCDF file to write data to.\n    varname : str\n        Name of netCDF variable to be written.\n    ldata : np.array\n        Linear array containing the data to be written.\n    meshname : str\n        Name of mesh variable in the netCDF file.\n    facedim : str\n        Name of the face dimension of the selected mesh.\n    long_name : str\n        Long descriptive name for the variable (\"None\" if no long name attribute\n        should be written).\n    units : str\n        String indicating the unit (\"None\" if no unit attribute should be written).\n    \"\"\"\n    # open destination file\n    dst = netCDF4.Dataset(dstfile, \"a\")\n\n    # add variable and write data\n    var = dst.createVariable(varname, \"f8\", (facedim,))\n    var.mesh = meshname\n    var.location = \"face\"\n    if long_name != \"None\":\n        var.long_name = long_name\n    if units != \"None\":\n        var.units = units\n    var[:] = ldata[:]\n\n    # close destination file\n    dst.close()\n</code></pre>"},{"location":"api/io.html#dfastbe.io.write_csv","title":"<code>write_csv(data: Dict[str, np.ndarray], filename: str) -&gt; None</code>","text":"<p>Write a data to csv file.</p>"},{"location":"api/io.html#dfastbe.io.write_csv--arguments","title":"Arguments","text":"<p>data : Dict[str, np.ndarray]     Value(s) to be written. filename : str     Name of the file to be written.</p>"},{"location":"api/io.html#dfastbe.io.write_csv--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def write_csv(data: Dict[str, np.ndarray], filename: str) -&gt; None:\n    \"\"\"\n    Write a data to csv file.\n\n    Arguments\n    ---------\n    data : Dict[str, np.ndarray]\n        Value(s) to be written.\n    filename : str\n        Name of the file to be written.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    keys = [key for key in data.keys()]\n    header = \"\"\n    for i in range(len(keys)):\n        if i &lt; len(keys) - 1:\n            header = header + '\"' + keys[i] + '\", '\n        else:\n            header = header + '\"' + keys[i] + '\"'\n\n    data = np.column_stack([array for array in data.values()])\n    np.savetxt(filename, data, delimiter=\", \", header=header, comments=\"\")\n</code></pre>"},{"location":"api/io.html#dfastbe.io.write_km_eroded_volumes","title":"<code>write_km_eroded_volumes(km: np.ndarray, vol: np.ndarray, filename: str) -&gt; None</code>","text":"<p>Write a text file with eroded volume data binned per kilometre.</p>"},{"location":"api/io.html#dfastbe.io.write_km_eroded_volumes--arguments","title":"Arguments","text":"<p>km :     Array containing chainage values. vol :     Array containing erosion volume values. filename : str     Name of the file to be written.</p>"},{"location":"api/io.html#dfastbe.io.write_km_eroded_volumes--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def write_km_eroded_volumes(km: np.ndarray, vol: np.ndarray, filename: str) -&gt; None:\n    \"\"\"\n    Write a text file with eroded volume data binned per kilometre.\n\n    Arguments\n    ---------\n    km :\n        Array containing chainage values.\n    vol :\n        Array containing erosion volume values.\n    filename : str\n        Name of the file to be written.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    with open(filename, \"w\") as erofile:\n        for i in range(len(km)):\n            valstr = \"\\t\".join([\"{:.2f}\".format(x) for x in vol[i, :]])\n            erofile.write(\"{:.2f}\\t\".format(km[i]) + valstr + \"\\n\")\n</code></pre>"},{"location":"api/io.html#dfastbe.io.write_shp","title":"<code>write_shp(geom: GeoSeries, data: Dict[str, np.ndarray], filename: str) -&gt; None</code>","text":"<p>Write a shape file.</p> <p>Write a shape file for a given GeoSeries and dictionary of np arrays. The GeoSeries and all np should have equal length.</p>"},{"location":"api/io.html#dfastbe.io.write_shp--arguments","title":"Arguments","text":"<p>geom : geopandas.geoseries.GeoSeries     geopandas GeoSeries containing k geometries. data : Dict[str, np.ndarray]     Dictionary of quantities to be written, each np array should have length k. filename : str     Name of the file to be written.</p>"},{"location":"api/io.html#dfastbe.io.write_shp--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def write_shp(geom: GeoSeries, data: Dict[str, np.ndarray], filename: str) -&gt; None:\n    \"\"\"Write a shape file.\n\n    Write a shape file for a given GeoSeries and dictionary of np arrays.\n    The GeoSeries and all np should have equal length.\n\n    Arguments\n    ---------\n    geom : geopandas.geoseries.GeoSeries\n        geopandas GeoSeries containing k geometries.\n    data : Dict[str, np.ndarray]\n        Dictionary of quantities to be written, each np array should have length k.\n    filename : str\n        Name of the file to be written.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    df = pd.DataFrame(data)\n    GeoDataFrame(df, geometry=geom).to_file(filename)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.write_shp_pnt","title":"<code>write_shp_pnt(xy: np.ndarray, data: Dict[str, np.ndarray], filename: str, config_file: ConfigFile) -&gt; None</code>","text":"<p>Write a shape point file with x, y, and values.</p>"},{"location":"api/io.html#dfastbe.io.write_shp_pnt--arguments","title":"Arguments","text":"<p>xy : np.ndarray     N x 2 array containing x and y coordinates. data : Dict[str, np.ndarray]     Dictionary of quantities to be written, each np array should have length k. filename : str     Name of the file to be written.</p>"},{"location":"api/io.html#dfastbe.io.write_shp_pnt--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def write_shp_pnt(\n    xy: np.ndarray, data: Dict[str, np.ndarray], filename: str, config_file: ConfigFile\n) -&gt; None:\n    \"\"\"\n    Write a shape point file with x, y, and values.\n\n    Arguments\n    ---------\n    xy : np.ndarray\n        N x 2 array containing x and y coordinates.\n    data : Dict[str, np.ndarray]\n        Dictionary of quantities to be written, each np array should have length k.\n    filename : str\n        Name of the file to be written.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    xy_points = [Point(xy1) for xy1 in xy]\n    geom = GeoSeries(xy_points, crs=config_file.crs)\n    write_shp(geom, data, filename)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.write_simona_box","title":"<code>write_simona_box(filename: str, rdata: np.ndarray, firstm: int, firstn: int) -&gt; None</code>","text":"<p>Write a SIMONA BOX file.</p>"},{"location":"api/io.html#dfastbe.io.write_simona_box--arguments","title":"Arguments","text":"<p>filename : str     Name of the file to be written. rdata : np.ndarray     Two-dimensional np array containing the data to be written. firstm : int     Firt M index to be written. firstn : int     First N index to be written.</p> Source code in <code>src/dfastbe/io.py</code> <pre><code>def write_simona_box(\n    filename: str, rdata: np.ndarray, firstm: int, firstn: int\n) -&gt; None:\n    \"\"\"\n    Write a SIMONA BOX file.\n\n    Arguments\n    ---------\n    filename : str\n        Name of the file to be written.\n    rdata : np.ndarray\n        Two-dimensional np array containing the data to be written.\n    firstm : int\n        Firt M index to be written.\n    firstn : int\n        First N index to be written.\n    \"\"\"\n    # open the data file\n    boxfile = open(filename, \"w\")\n\n    # get shape and prepare block header; data will be written in blocks of 10\n    # N-lines\n    shp = np.shape(rdata)\n    mmax = shp[0]\n    nmax = shp[1]\n    boxheader = \"      BOX MNMN=({m1:4d},{n1:5d},{m2:5d},{n2:5d}), VARIABLE_VAL=\\n\"\n    nstep = 10\n\n    # Loop over all N-blocks and write data to file\n    for j in range(firstn, nmax, nstep):\n        k = min(nmax, j + nstep)\n        boxfile.write(boxheader.format(m1=firstm + 1, n1=j + 1, m2=mmax, n2=k))\n        nvalues = (mmax - firstm) * (k - j)\n        boxdata = (\"   \" + \"{:12.3f}\" * (k - j) + \"\\n\") * (mmax - firstm)\n        values = tuple(rdata[firstm:mmax, j:k].reshape(nvalues))\n        boxfile.write(boxdata.format(*values))\n\n    # close the file\n    boxfile.close()\n</code></pre>"},{"location":"api/kernel.html","title":"kernel","text":""},{"location":"api/kernel.html#kernel_1","title":"kernel","text":""},{"location":"api/kernel.html#dfastbe.kernel","title":"<code>dfastbe.kernel</code>","text":"<p>Copyright (C) 2020 Stichting Deltares.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation version 2.1.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, see http://www.gnu.org/licenses/.</p> <p>contact: delft3d.support@deltares.nl Stichting Deltares P.O. Box 177 2600 MH Delft, The Netherlands</p> <p>All indications and logos of, and references to, \"Delft3D\" and \"Deltares\" are registered trademarks of Stichting Deltares, and remain the property of Stichting Deltares. All rights reserved.</p> <p>INFORMATION This file is part of D-FAST Bank Erosion: https://github.com/Deltares/D-FAST_Bank_Erosion</p>"},{"location":"api/kernel.html#dfastbe.kernel.comp_erosion","title":"<code>comp_erosion(velocity: numpy.ndarray, bankheight: numpy.ndarray, linesize: numpy.ndarray, zfw: numpy.ndarray, zfw_ini: numpy.ndarray, Nship: numpy.ndarray, vship: numpy.ndarray, nwave: numpy.ndarray, ship_type: numpy.ndarray, Tship: numpy.ndarray, Teros: float, mu_slope: numpy.ndarray, mu_reed: numpy.ndarray, distance_fw: numpy.ndarray, hfw: numpy.ndarray, chezy: numpy.ndarray, erosion_inputs: ErosionInputs, rho: float, g: float, ib: int) -&gt; [numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray]</code>","text":"<p>Compute the bank erosion during a specific discharge level.</p>"},{"location":"api/kernel.html#dfastbe.kernel.comp_erosion--arguments","title":"Arguments","text":"<p>velocity : numpy.ndarray     Array containing flow velocity magnitude [m/s] bankheight : numpy.ndarray     Array containing bank height linesize : numpy.ndarray     Array containing length of line segment [m] zfw : numpy.ndarray     Array containing water levels at fairway [m] zfw_ini : numpy.ndarray     Array containing reference water levels at fairway [m] tauc : numpy.ndarray     Array containing critical shear stress [N/m2] Nship : numpy.ndarray     Array containing number of ships [-] vship : numpy.ndarray     Array containing ship velocity [m/s] nwave : numpy.ndarray     Array containing number of waves per ship [-] ship_type : numpy.ndarray     Array containing ship type [-] Tship : numpy.ndarray     Array containing ship draught [m] Teros : float     Erosion period [yr] mu_slope : numpy.ndarray     Array containing  mu_reed : numpy.ndarray     Array containing  distance_fw : numpy.ndarray     Array containing distance from bank to fairway [m] dfw0 : numpy.ndarray     Array containing distance from fairway at which wave reduction starts [m] dfw1 : numpy.ndarray     Array containing distance from fairway at which all waves are gone [m] hfw : numpy.ndarray     Array containing water depth at fairway [m] chezy : numpy.ndarray     Array containing Chezy values [m0.5/s] zss : numpy.ndarray     Array containing bank protection height [m] rho : float     Water density [kg/m3] g : float     Gravitational acceleration [m/s2]</p>"},{"location":"api/kernel.html#dfastbe.kernel.comp_erosion--returns","title":"Returns","text":"<p>dn : numpy.ndarray     Total bank erosion distance [m] dv : numpy.ndarray     Total bank erosion volume [m] dn_ship : numpy.ndarray     Bank erosion distance due to shipping [m] dn_flow : numpy.ndarray     Bank erosion distance due to current [m] shipmwavemax : numpy.ndarray     Maximum bank level subject to ship waves [m] shipwavemin : numpy.ndarray     Minimum bank level subject to ship waves [m]</p> Source code in <code>src/dfastbe/kernel.py</code> <pre><code>def comp_erosion(\n    velocity: numpy.ndarray,\n    bankheight: numpy.ndarray,\n    linesize: numpy.ndarray,\n    zfw: numpy.ndarray,\n    zfw_ini: numpy.ndarray,\n    Nship: numpy.ndarray,\n    vship: numpy.ndarray,\n    nwave: numpy.ndarray,\n    ship_type: numpy.ndarray,\n    Tship: numpy.ndarray,\n    Teros: float,\n    mu_slope: numpy.ndarray,\n    mu_reed: numpy.ndarray,\n    distance_fw: numpy.ndarray,\n    hfw: numpy.ndarray,\n    chezy: numpy.ndarray,\n    erosion_inputs: \"ErosionInputs\",\n    rho: float,\n    g: float,\n    ib: int,\n) -&gt; [\n    numpy.ndarray,\n    numpy.ndarray,\n    numpy.ndarray,\n    numpy.ndarray,\n    numpy.ndarray,\n    numpy.ndarray,\n]:\n    \"\"\"\n    Compute the bank erosion during a specific discharge level.\n\n    Arguments\n    ---------\n    velocity : numpy.ndarray\n        Array containing flow velocity magnitude [m/s]\n    bankheight : numpy.ndarray\n        Array containing bank height\n    linesize : numpy.ndarray\n        Array containing length of line segment [m]\n    zfw : numpy.ndarray\n        Array containing water levels at fairway [m]\n    zfw_ini : numpy.ndarray\n        Array containing reference water levels at fairway [m]\n    tauc : numpy.ndarray\n        Array containing critical shear stress [N/m2]\n    Nship : numpy.ndarray\n        Array containing number of ships [-]\n    vship : numpy.ndarray\n        Array containing ship velocity [m/s]\n    nwave : numpy.ndarray\n        Array containing number of waves per ship [-]\n    ship_type : numpy.ndarray\n        Array containing ship type [-]\n    Tship : numpy.ndarray\n        Array containing ship draught [m]\n    Teros : float\n        Erosion period [yr]\n    mu_slope : numpy.ndarray\n        Array containing \n    mu_reed : numpy.ndarray\n        Array containing \n    distance_fw : numpy.ndarray\n        Array containing distance from bank to fairway [m]\n    dfw0 : numpy.ndarray\n        Array containing distance from fairway at which wave reduction starts [m]\n    dfw1 : numpy.ndarray\n        Array containing distance from fairway at which all waves are gone [m]\n    hfw : numpy.ndarray\n        Array containing water depth at fairway [m]\n    chezy : numpy.ndarray\n        Array containing Chezy values [m0.5/s]\n    zss : numpy.ndarray\n        Array containing bank protection height [m]\n    rho : float\n        Water density [kg/m3]\n    g : float\n        Gravitational acceleration [m/s2]\n\n    Returns\n    -------\n    dn : numpy.ndarray\n        Total bank erosion distance [m]\n    dv : numpy.ndarray\n        Total bank erosion volume [m]\n    dn_ship : numpy.ndarray\n        Bank erosion distance due to shipping [m]\n    dn_flow : numpy.ndarray\n        Bank erosion distance due to current [m]\n    shipmwavemax : numpy.ndarray\n        Maximum bank level subject to ship waves [m]\n    shipwavemin : numpy.ndarray\n        Minimum bank level subject to ship waves [m]\n    \"\"\"\n    eps = sys.float_info.epsilon\n    sec_year = 3600 * 24 * 365\n\n    # period of ship waves [s]\n    T = 0.51 * vship / g\n    # [s]\n    ts = T * Nship * nwave\n\n    # number of line segments\n    xlen = len(velocity)\n    # total erosion per segment\n    dn = numpy.zeros(xlen)\n    # erosion volume per segment\n    dv = numpy.zeros(xlen)\n    # total wave damping coefficient\n    mu_tot = numpy.zeros(xlen)\n\n    vel = velocity\n\n    # ship induced wave height at the beginning of the foreshore\n    H0 = comp_hw_ship_at_bank(\n        distance_fw,\n        erosion_inputs.wave_fairway_distance_0[ib],\n        erosion_inputs.wave_fairway_distance_1[ib],\n        hfw,\n        ship_type,\n        Tship,\n        vship,\n        g,\n    )\n    H0 = numpy.maximum(H0, eps)\n\n    # compute erosion parameters for each line part\n\n    # erosion coefficient\n    E = 0.2 * numpy.sqrt(erosion_inputs.tauc[ib]) * 1e-6\n\n    # critical velocity\n    velc = numpy.sqrt(erosion_inputs.tauc[ib] / rho * chezy**2 / g)\n\n    # strength\n    cE = 1.85e-4 / erosion_inputs.tauc[ib]\n\n    # total wavedamping coefficient\n    mu_tot = (mu_slope / H0) + mu_reed\n    # water level along bank line\n    ho_line_ship = numpy.minimum(zfw - erosion_inputs.bank_protection_level[ib], 2 * H0)\n    ho_line_flow = numpy.minimum(zfw - erosion_inputs.bank_protection_level[ib], hfw)\n    h_line_ship = numpy.maximum(bankheight - zfw + ho_line_ship, 0)\n    h_line_flow = numpy.maximum(bankheight - zfw + ho_line_flow, 0)\n\n    # compute displacement due to flow\n    crit_ratio = numpy.ones(velc.shape)\n    mask = (vel &gt; velc) &amp; (zfw &gt; erosion_inputs.bank_protection_level[ib])\n    crit_ratio[mask] = (vel[mask] / velc[mask]) ** 2\n    dn_flow = E * (crit_ratio - 1) * Teros * sec_year\n\n    # compute displacement due to shipwaves\n    shipwavemax = zfw + 0.5 * H0\n    shipwavemin = zfw - 2 * H0\n    mask = (shipwavemin &lt; zfw_ini) &amp; (zfw_ini &lt; shipwavemax)\n    # limit mu -&gt; 0\n\n    dn_ship = cE * H0 ** 2 * ts * Teros\n    dn_ship[~mask] = 0\n\n    # compute erosion volume\n    mask = (h_line_ship &gt; 0) &amp; (zfw &gt; erosion_inputs.bank_protection_level[ib])\n    dv_ship = dn_ship * linesize * h_line_ship\n    dv_ship[~mask] = 0.0\n    dn_ship[~mask] = 0.0\n\n    mask = (h_line_flow &gt; 0) &amp; (zfw &gt; erosion_inputs.bank_protection_level[ib])\n    dv_flow = dn_flow * linesize * h_line_flow\n    dv_flow[~mask] = 0.0\n    dn_flow[~mask] = 0.0\n\n    dn = dn_ship + dn_flow\n    dv = dv_ship + dv_flow\n\n    # print(\"  dv_flow total = \", dv_flow.sum())\n    # print(\"  dv_ship total = \", dv_ship.sum())\n    return dn, dv, dn_ship, dn_flow, shipwavemax, shipwavemin\n</code></pre>"},{"location":"api/kernel.html#dfastbe.kernel.comp_erosion_eq","title":"<code>comp_erosion_eq(bankheight: numpy.ndarray, linesize: numpy.ndarray, zfw_ini: numpy.ndarray, vship: numpy.ndarray, ship_type: numpy.ndarray, Tship: numpy.ndarray, mu_slope: numpy.ndarray, distance_fw: numpy.ndarray, hfw: numpy.ndarray, erosion_inputs: ErosionInputs, ib: int, g: float) -&gt; Tuple[numpy.ndarray, numpy.ndarray]</code>","text":"<p>Compute the equilibrium bank erosion.</p>"},{"location":"api/kernel.html#dfastbe.kernel.comp_erosion_eq--arguments","title":"Arguments","text":"<p>bankheight : numpy.ndarray     Array containing bank height [m] linesize : numpy.ndarray     Array containing length of line segment [m] zfw_ini : numpy.ndarray     Array containing water level at fairway [m] vship : numpy.ndarray     Array containing ship velocity [m/s] ship_type : numpy.ndarray     Array containing ship type [-] Tship : numpy.ndarray     Array containing ship draught [m] mu_slope : numpy.ndarray     Array containing slope [-] distance_fw : numpy.ndarray     Array containing distance from bank to fairway [m] dfw0 : numpy.ndarray     Array containing distance from fairway at which wave reduction starts [m] dfw1 : numpy.ndarray     Array containing distance from fairway at which all waves are gone [m] hfw : numpy.ndarray     Array containing water depth at the fairway [m] zss : numpy.ndarray     Array containing bank protection height [m] g : float     Gravitational acceleration [m/s2]</p>"},{"location":"api/kernel.html#dfastbe.kernel.comp_erosion_eq--returns","title":"Returns","text":"<p>dn_eq : numpy.ndarray      Equilibrium bank erosion distance [m] dv_eq : numpy.ndarray      Equilibrium bank erosion volume [m]</p> Source code in <code>src/dfastbe/kernel.py</code> <pre><code>def comp_erosion_eq(\n    bankheight: numpy.ndarray,\n    linesize: numpy.ndarray,\n    zfw_ini: numpy.ndarray,\n    vship: numpy.ndarray,\n    ship_type: numpy.ndarray,\n    Tship: numpy.ndarray,\n    mu_slope: numpy.ndarray,\n    distance_fw: numpy.ndarray,\n    hfw: numpy.ndarray,\n    erosion_inputs: \"ErosionInputs\",\n    ib: int,\n    g: float,\n) -&gt; Tuple[numpy.ndarray, numpy.ndarray]:\n    \"\"\"\n    Compute the equilibrium bank erosion.\n\n    Arguments\n    ---------\n    bankheight : numpy.ndarray\n        Array containing bank height [m]\n    linesize : numpy.ndarray\n        Array containing length of line segment [m]\n    zfw_ini : numpy.ndarray\n        Array containing water level at fairway [m]\n    vship : numpy.ndarray\n        Array containing ship velocity [m/s]\n    ship_type : numpy.ndarray\n        Array containing ship type [-]\n    Tship : numpy.ndarray\n        Array containing ship draught [m]\n    mu_slope : numpy.ndarray\n        Array containing slope [-]\n    distance_fw : numpy.ndarray\n        Array containing distance from bank to fairway [m]\n    dfw0 : numpy.ndarray\n        Array containing distance from fairway at which wave reduction starts [m]\n    dfw1 : numpy.ndarray\n        Array containing distance from fairway at which all waves are gone [m]\n    hfw : numpy.ndarray\n        Array containing water depth at the fairway [m]\n    zss : numpy.ndarray\n        Array containing bank protection height [m]\n    g : float\n        Gravitational acceleration [m/s2]\n\n    Returns\n    -------\n    dn_eq : numpy.ndarray\n         Equilibrium bank erosion distance [m]\n    dv_eq : numpy.ndarray\n         Equilibrium bank erosion volume [m]\n    \"\"\"\n    eps = sys.float_info.epsilon\n\n    # ship induced wave height at the beginning of the foreshore\n    H0 = comp_hw_ship_at_bank(\n        distance_fw,\n        erosion_inputs.wave_fairway_distance_0[ib],\n        erosion_inputs.wave_fairway_distance_1[ib],\n        hfw,\n        ship_type,\n        Tship,\n        vship,\n        g,\n    )\n    H0 = numpy.maximum(H0, eps)\n\n    zup = numpy.minimum(bankheight, zfw_ini + 2 * H0)\n    zdo = numpy.maximum(zfw_ini - 2 * H0, erosion_inputs.bank_protection_level[ib])\n    ht = numpy.maximum(zup - zdo, 0)\n    hs = numpy.maximum(bankheight - zfw_ini + 2 * H0, 0)\n    dn_eq = ht / mu_slope\n    dv_eq = (0.5 * ht + hs) * dn_eq * linesize\n\n    return dn_eq, dv_eq\n</code></pre>"},{"location":"api/kernel.html#dfastbe.kernel.comp_hw_ship_at_bank","title":"<code>comp_hw_ship_at_bank(distance_fw: numpy.ndarray, dfw0: numpy.ndarray, dfw1: numpy.ndarray, h_input: numpy.ndarray, ship_type: numpy.ndarray, Tship: numpy.ndarray, vship: numpy.ndarray, g: float) -&gt; numpy.ndarray</code>","text":"<p>Compute wave heights at bank due to passing ships.</p>"},{"location":"api/kernel.html#dfastbe.kernel.comp_hw_ship_at_bank--arguments","title":"Arguments","text":"<p>distance_fw : numpy.ndarray     Array containing distance from bank to fairway [m] dfw0 : numpy.ndarray     Array containing distance from fairway at which wave reduction starts [m] dfw1 : numpy.ndarray     Array containing distance from fairway at which all waves are gone [m] h_input : numpy.ndarray     Array containing the water depth at the fairway [m] ship_type : numpy.ndarray     Array containing the ship type [-] Tship : numpy.ndarray     Array containing draught of the ships [m] vship : numpy.ndarray     Array containing velocity of the ships [m/s] g : float     Gravitational acceleration [m/s2]</p>"},{"location":"api/kernel.html#dfastbe.kernel.comp_hw_ship_at_bank--returns","title":"Returns","text":"<p>h0 : numpy.ndarray     Array containing wave height at the bank [m]</p> Source code in <code>src/dfastbe/kernel.py</code> <pre><code>def comp_hw_ship_at_bank(\n    distance_fw: numpy.ndarray,\n    dfw0: numpy.ndarray,\n    dfw1: numpy.ndarray,\n    h_input: numpy.ndarray,\n    ship_type: numpy.ndarray,\n    Tship: numpy.ndarray,\n    vship: numpy.ndarray,\n    g: float,\n) -&gt; numpy.ndarray:\n    \"\"\"\n    Compute wave heights at bank due to passing ships.\n\n    Arguments\n    ---------\n    distance_fw : numpy.ndarray\n        Array containing distance from bank to fairway [m]\n    dfw0 : numpy.ndarray\n        Array containing distance from fairway at which wave reduction starts [m]\n    dfw1 : numpy.ndarray\n        Array containing distance from fairway at which all waves are gone [m]\n    h_input : numpy.ndarray\n        Array containing the water depth at the fairway [m]\n    ship_type : numpy.ndarray\n        Array containing the ship type [-]\n    Tship : numpy.ndarray\n        Array containing draught of the ships [m]\n    vship : numpy.ndarray\n        Array containing velocity of the ships [m/s]\n    g : float\n        Gravitational acceleration [m/s2]\n\n    Returns\n    -------\n    h0 : numpy.ndarray\n        Array containing wave height at the bank [m]\n    \"\"\"\n    h = numpy.copy(h_input)\n\n    a1 = numpy.zeros(len(distance_fw))\n    # multiple barge convoy set\n    a1[ship_type == 1] = 0.5\n    # RHK ship / motorship\n    a1[ship_type == 2] = 0.28 * Tship[ship_type == 2] ** 1.25\n    # towboat\n    a1[ship_type == 3] = 1\n\n    Froude = vship / numpy.sqrt(h * g)\n    Froude_limit = 0.8\n    high_Froude = Froude &gt; Froude_limit\n    h[high_Froude] = ((vship[high_Froude] / Froude_limit) ** 2) / g\n    Froude[high_Froude] = Froude_limit\n\n    A = 0.5 * (1 + numpy.cos((distance_fw - dfw1) / (dfw0 - dfw1) * numpy.pi))\n    A[distance_fw &lt; dfw1] = 1\n    A[distance_fw &gt; dfw0] = 0\n\n    h0 = a1 * h * (distance_fw / h) ** (-1 / 3) * Froude ** 4 * A\n    return h0\n</code></pre>"},{"location":"api/kernel.html#dfastbe.kernel.get_bbox","title":"<code>get_bbox(xykm: numpy.ndarray, buffer: float = 0.1) -&gt; Tuple[float, float, float, float]</code>","text":"<p>Derive the bounding box from a line.</p>"},{"location":"api/kernel.html#dfastbe.kernel.get_bbox--arguments","title":"Arguments","text":"<p>xybm : numpy.ndarray     An N x M array containing x- and y-coordinates as first two M entries buffer : float     Buffer fraction surrounding the tight bounding box</p>"},{"location":"api/kernel.html#dfastbe.kernel.get_bbox--results","title":"Results","text":"<p>bbox : Tuple[float, float, float, float]     Tuple bounding box consisting of [min x, min y, max x, max y)</p> Source code in <code>src/dfastbe/kernel.py</code> <pre><code>def get_bbox(\n    xykm: numpy.ndarray, buffer: float = 0.1\n) -&gt; Tuple[float, float, float, float]:\n    \"\"\"\n    Derive the bounding box from a line.\n\n    Arguments\n    ---------\n    xybm : numpy.ndarray\n        An N x M array containing x- and y-coordinates as first two M entries\n    buffer : float\n        Buffer fraction surrounding the tight bounding box\n\n    Results\n    -------\n    bbox : Tuple[float, float, float, float]\n        Tuple bounding box consisting of [min x, min y, max x, max y)\n    \"\"\"\n    x = xykm[:, 0]\n    y = xykm[:, 1]\n    xmin = x.min()\n    ymin = y.min()\n    xmax = x.max()\n    ymax = y.max()\n    d = buffer * max(xmax - xmin, ymax - ymin)\n    bbox = (xmin - d, ymin - d, xmax + d, ymax + d)\n    return bbox\n</code></pre>"},{"location":"api/kernel.html#dfastbe.kernel.get_km_bins","title":"<code>get_km_bins(km_bin: Tuple[float, float, float], type: int = 2, adjust: bool = False) -&gt; numpy.ndarray</code>","text":"<p>Get an array of representative chainage values.</p>"},{"location":"api/kernel.html#dfastbe.kernel.get_km_bins--arguments","title":"Arguments","text":"<p>km_bin : Tuple[float, float, float]     Tuple containing (start, end, step) for the chainage bins type : int     Type of characteristic chainage values returned         0: all bounds (N+1 values)         1: lower bounds (N values)         2: upper bounds (N values) - default         3: mid points (N values) adjust : bool     Flag indicating whether the step size should be adjusted to include an integer number of steps</p>"},{"location":"api/kernel.html#dfastbe.kernel.get_km_bins--returns","title":"Returns","text":"<p>km : numpy.ndarray     Array containing the chainage bin upper bounds</p> Source code in <code>src/dfastbe/kernel.py</code> <pre><code>def get_km_bins(km_bin: Tuple[float, float, float], type: int = 2, adjust: bool = False) -&gt; numpy.ndarray:\n    \"\"\"\n    Get an array of representative chainage values.\n\n    Arguments\n    ---------\n    km_bin : Tuple[float, float, float]\n        Tuple containing (start, end, step) for the chainage bins\n    type : int\n        Type of characteristic chainage values returned\n            0: all bounds (N+1 values)\n            1: lower bounds (N values)\n            2: upper bounds (N values) - default\n            3: mid points (N values)\n    adjust : bool\n        Flag indicating whether the step size should be adjusted to include an integer number of steps\n\n    Returns\n    -------\n    km : numpy.ndarray\n        Array containing the chainage bin upper bounds\n    \"\"\"\n    km_step = km_bin[2]\n    nbins = int(math.ceil((km_bin[1] - km_bin[0]) / km_step))\n\n    lb = 0\n    ub = nbins + 1\n    dx = 0.0\n\n    if adjust:\n        km_step = (km_bin[1] - km_bin[0]) / nbins\n\n    if type == 0:\n        # all bounds\n        pass\n    elif type == 1:\n        # lower bounds\n        ub = ub - 1\n    elif type == 2:\n        # upper bounds\n        lb = lb + 1\n    elif type == 3:\n        # midpoint values\n        ub = ub - 1\n        dx = km_bin[2] / 2\n\n    km = km_bin[0] + dx + numpy.arange(lb, ub) * km_step\n\n    return km\n</code></pre>"},{"location":"api/kernel.html#dfastbe.kernel.get_km_eroded_volume","title":"<code>get_km_eroded_volume(bank_km_mid: numpy.ndarray, dv: numpy.ndarray, km_bin: Tuple[float, float, float]) -&gt; numpy.ndarray</code>","text":"<p>Accumulate the erosion volumes per chainage bin.</p>"},{"location":"api/kernel.html#dfastbe.kernel.get_km_eroded_volume--arguments","title":"Arguments","text":"<p>bank_km_mid : numpy.ndarray     Array containing the chainage per bank segment [km] dv : numpy.ndarray     Array containing the eroded volume per bank segment [m3] km_bin : Tuple[float, float, float]     Tuple containing (start, end, step) for the chainage bins</p>"},{"location":"api/kernel.html#dfastbe.kernel.get_km_eroded_volume--returns","title":"Returns","text":"<p>dvol : numpy.ndarray     Array containing the accumulated eroded volume per chainage bin.</p> Source code in <code>src/dfastbe/kernel.py</code> <pre><code>def get_km_eroded_volume(\n    bank_km_mid: numpy.ndarray, dv: numpy.ndarray, km_bin: Tuple[float, float, float]\n) -&gt; numpy.ndarray:\n    \"\"\"\n    Accumulate the erosion volumes per chainage bin.\n\n    Arguments\n    ---------\n    bank_km_mid : numpy.ndarray\n        Array containing the chainage per bank segment [km]\n    dv : numpy.ndarray\n        Array containing the eroded volume per bank segment [m3]\n    km_bin : Tuple[float, float, float]\n        Tuple containing (start, end, step) for the chainage bins\n\n    Returns\n    -------\n    dvol : numpy.ndarray\n        Array containing the accumulated eroded volume per chainage bin.\n    \"\"\"\n    km_step = km_bin[2]\n    nbins = int(math.ceil((km_bin[1] - km_bin[0]) / km_step))\n\n    bin_idx = numpy.rint((bank_km_mid - km_bin[0] - km_step / 2.0) / km_step).astype(\n        numpy.int64\n    )\n    dvol_temp = numpy.bincount(bin_idx, weights=dv)\n    length = int((km_bin[1] - km_bin[0]) / km_bin[2])\n    if len(dvol_temp) == length:\n       dvol = dvol_temp\n    else:\n       dvol = numpy.zeros((length,))\n       dvol[:len(dvol_temp)] = dvol_temp\n    return dvol\n</code></pre>"},{"location":"api/kernel.html#dfastbe.kernel.get_zoom_extends","title":"<code>get_zoom_extends(km_min: float, km_max: float, zoom_km_step: float, bank_crds: List[numpy.ndarray], bank_km: List[numpy.ndarray]) -&gt; [List[Tuple[float, float]], List[Tuple[float, float, float, float]]]</code>","text":"<p>Zoom .</p>"},{"location":"api/kernel.html#dfastbe.kernel.get_zoom_extends--arguments","title":"Arguments","text":"<p>km_min : float     Minimum value for the chainage range of interest. km_max : float     Maximum value for the chainage range of interest. zoom_km_step : float     Preferred chainage length of zoom box. bank_crds : List[numpy.ndarray]     List of N x 2 numpy arrays of coordinates per bank. bank_km : List[numpy.ndarray]     List of N numpy arrays of chainage values per bank.</p>"},{"location":"api/kernel.html#dfastbe.kernel.get_zoom_extends--returns","title":"Returns","text":"<p>kmzoom : List[Tuple[float, float]]     Zoom ranges for plots with chainage along x-axis. xyzoom : List[Tuple[float, float, float, float]]     Zoom ranges for xy-plots.</p> Source code in <code>src/dfastbe/kernel.py</code> <pre><code>def get_zoom_extends(km_min: float, km_max: float, zoom_km_step: float, bank_crds: List[numpy.ndarray], bank_km: List[numpy.ndarray]) -&gt; [List[Tuple[float, float]], List[Tuple[float, float, float, float]]]:\n    \"\"\"\n    Zoom .\n\n    Arguments\n    ---------\n    km_min : float\n        Minimum value for the chainage range of interest.\n    km_max : float\n        Maximum value for the chainage range of interest.\n    zoom_km_step : float\n        Preferred chainage length of zoom box.\n    bank_crds : List[numpy.ndarray]\n        List of N x 2 numpy arrays of coordinates per bank.\n    bank_km : List[numpy.ndarray]\n        List of N numpy arrays of chainage values per bank.\n\n    Returns\n    -------\n    kmzoom : List[Tuple[float, float]]\n        Zoom ranges for plots with chainage along x-axis.\n    xyzoom : List[Tuple[float, float, float, float]]\n        Zoom ranges for xy-plots.\n    \"\"\"\n\n    zoom_km_bin = (km_min, km_max, zoom_km_step)\n    zoom_km_bnd = get_km_bins(zoom_km_bin, type=0, adjust=True)\n    eps = 0.1 * zoom_km_step\n\n    kmzoom: List[Tuple[float, float]] = []\n    xyzoom: List[Tuple[float, float, float, float]] = []\n    inf = float('inf')\n    for i in range(len(zoom_km_bnd)-1):\n        km_min = zoom_km_bnd[i] - eps\n        km_max = zoom_km_bnd[i + 1] + eps\n        kmzoom.append((km_min, km_max))\n\n        xmin = inf\n        xmax = -inf\n        ymin = inf\n        ymax = -inf\n        for ib in range(len(bank_km)):\n            irange = (bank_km[ib] &gt;= km_min) &amp; (bank_km[ib] &lt;= km_max)\n            range_crds = bank_crds[ib][irange, :]\n            x = range_crds[:, 0]\n            y = range_crds[:, 1]\n            if len(x) &gt; 0:\n                xmin = min(xmin, min(x))\n                xmax = max(xmax, max(x))\n                ymin = min(ymin, min(y))\n                ymax = max(ymax, max(y))\n        xyzoom.append((xmin, xmax, ymin, ymax))\n\n    return kmzoom, xyzoom\n</code></pre>"},{"location":"api/kernel.html#dfastbe.kernel.moving_avg","title":"<code>moving_avg(xi: numpy.ndarray, yi: numpy.ndarray, dx: float) -&gt; numpy.ndarray</code>","text":"<p>Perform a moving average for given averaging distance.</p>"},{"location":"api/kernel.html#dfastbe.kernel.moving_avg--arguments","title":"Arguments","text":"<p>xi : numpy.ndarray     Array containing the distance - should be monotonically increasing or decreasing [m or equivalent] yi : numpy.ndarray     Array containing the values to be average [arbitrary] dx: float     Averaging distance [same unit as x]</p>"},{"location":"api/kernel.html#dfastbe.kernel.moving_avg--returns","title":"Returns","text":"<p>yo : numpy.ndarray     Array containing the averaged values [same unit as y].</p> Source code in <code>src/dfastbe/kernel.py</code> <pre><code>def moving_avg(xi: numpy.ndarray, yi: numpy.ndarray, dx: float) -&gt; numpy.ndarray:\n    \"\"\"\n    Perform a moving average for given averaging distance.\n\n    Arguments\n    ---------\n    xi : numpy.ndarray\n        Array containing the distance - should be monotonically increasing or decreasing [m or equivalent]\n    yi : numpy.ndarray\n        Array containing the values to be average [arbitrary]\n    dx: float\n        Averaging distance [same unit as x]\n\n    Returns\n    -------\n    yo : numpy.ndarray\n        Array containing the averaged values [same unit as y].\n    \"\"\"\n    dx2 = dx / 2.0\n    nx = len(xi)\n    if xi[0] &lt; xi[-1]:\n        x = xi\n        y = yi\n    else:\n        x = xi[::-1]\n        y = yi[::-1]\n    ym = numpy.zeros(y.shape)\n    di = numpy.zeros(y.shape)\n    j0 = 1\n    for i in range(nx):\n        for j in range(j0, nx):\n            dxj = x[j] - x[j - 1]\n            if x[i] - x[j] &gt; dx2:\n                # point j is too far back for point i and further\n                j0 = j + 1\n            elif x[j] - x[i] &gt; dx2:\n                # point j is too far ahead; wrap up and continue\n                d0 = (x[i] + dx2) - x[j - 1]\n                ydx2 = y[j - 1] + (y[j] - y[j - 1]) * d0 / dxj\n                ym[i] += (y[j - 1] + ydx2) / 2.0 * d0\n                di[i] += d0\n                break\n            elif x[i] - x[j - 1] &gt; dx2:\n                # point j is ok, but j-1 is too far back, so let's start\n                d0 = x[j] - (x[i] - dx2)\n                ydx2 = y[j] + (y[j - 1] - y[j]) * d0 / dxj\n                ym[i] += (y[j] + ydx2) / 2.0 * d0\n                di[i] += d0\n            else:\n                # segment right in the middle\n                ym[i] += (y[j] + y[j - 1]) / 2.0 * dxj\n                di[i] += dxj\n    yo = ym / di\n    if xi[0] &lt; xi[-1]:\n        return yo\n    else:\n        return yo[::-1]\n</code></pre>"},{"location":"api/plotting.html","title":"plotting","text":""},{"location":"api/plotting.html#plotting_1","title":"plotting","text":""},{"location":"api/plotting.html#dfastbe.plotting","title":"<code>dfastbe.plotting</code>","text":"<p>Copyright (C) 2020 Stichting Deltares.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation version 2.1.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, see http://www.gnu.org/licenses/.</p> <p>contact: delft3d.support@deltares.nl Stichting Deltares P.O. Box 177 2600 MH Delft, The Netherlands</p> <p>All indications and logos of, and references to, \"Delft3D\" and \"Deltares\" are registered trademarks of Stichting Deltares, and remain the property of Stichting Deltares. All rights reserved.</p> <p>INFORMATION This file is part of D-FAST Bank Erosion: https://github.com/Deltares/D-FAST_Bank_Erosion</p>"},{"location":"api/plotting.html#dfastbe.plotting.chainage_markers","title":"<code>chainage_markers(xykm: numpy.ndarray, ax: matplotlib.axes.Axes, ndec: int = 1, scale: float = 1000) -&gt; None</code>","text":"<p>Add markers indicating the river chainage to a plot.</p>"},{"location":"api/plotting.html#dfastbe.plotting.chainage_markers--arguments","title":"Arguments","text":"<p>xykm : numpy.ndarray     Array containing the x, y, and chainage; unit m for x and y, km for chainage. ax : matplotlib.axes.Axes     Axes object in which to add the markers. ndec : int     Number of decimals used for marks. scale: float     Indicates whether the axes are in m (1) or km (1000).</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def chainage_markers(\n    xykm: numpy.ndarray, ax: matplotlib.axes.Axes, ndec: int = 1, scale: float = 1000\n) -&gt; None:\n    \"\"\"\n    Add markers indicating the river chainage to a plot.\n\n    Arguments\n    ---------\n    xykm : numpy.ndarray\n        Array containing the x, y, and chainage; unit m for x and y, km for chainage.\n    ax : matplotlib.axes.Axes\n        Axes object in which to add the markers.\n    ndec : int\n        Number of decimals used for marks.\n    scale: float\n        Indicates whether the axes are in m (1) or km (1000).\n    \"\"\"\n    step = 10 ** (-ndec)\n    labelstr = \" {:.\" + str(ndec) + \"f}\"\n    km_rescaled = xykm[:, 2] / step\n    mask = numpy.isclose(numpy.round(km_rescaled), km_rescaled)\n    ax.plot(\n        xykm[mask, 0] / scale,\n        xykm[mask, 1] / scale,\n        linestyle=\"None\",\n        marker=\"+\",\n        color=\"k\",\n    )\n    for i in numpy.nonzero(mask)[0]:\n        ax.text(\n            xykm[i, 0] / scale,\n            xykm[i, 1] / scale,\n            labelstr.format(xykm[i, 2]),\n            fontsize=\"x-small\",\n            clip_on=True,\n        )\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.get_colors","title":"<code>get_colors(cmap_name: str, n: int) -&gt; List[Tuple[float, float, float]]</code>","text":"<p>Obtain N colors from the specified colormap.</p>"},{"location":"api/plotting.html#dfastbe.plotting.get_colors--arguments","title":"Arguments","text":"<p>cmap_name : str     Name of the color map. n : int     Number of colors to be returned.</p>"},{"location":"api/plotting.html#dfastbe.plotting.get_colors--returns","title":"Returns","text":"<p>clrcyc : List[Tuple[float, float, float]]     List of colour tuplets.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def get_colors(cmap_name: str, n: int) -&gt; List[Tuple[float, float, float]]:\n    \"\"\"\n    Obtain N colors from the specified colormap.\n\n    Arguments\n    ---------\n    cmap_name : str\n        Name of the color map.\n    n : int\n        Number of colors to be returned.\n\n    Returns\n    -------\n    clrcyc : List[Tuple[float, float, float]]\n        List of colour tuplets.\n    \"\"\"\n    cmap = matplotlib.cm.get_cmap(cmap_name)\n    clrs = [cmap(i / (n - 1)) for i in range(n)]\n    return clrs\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.plot1_waterdepth_and_banklines","title":"<code>plot1_waterdepth_and_banklines(bbox: Tuple[float, float, float, float], xykm: numpy.ndarray, banklines: geopandas.geodataframe.GeoDataFrame, fn: numpy.ndarray, nnodes: numpy.ndarray, xn: numpy.ndarray, yn: numpy.ndarray, h: numpy.ndarray, hmax: float, xlabel_txt: str, ylabel_txt: str, title_txt: str, waterdepth_txt: str) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]</code>","text":"<p>Create the bank erosion plot with water depths and initial bank lines.</p> Tuple[float, float, float, float] <p>Tuple containing boundary limits (xmin, ymin, xmax, ymax); unit m.</p> <p>xykm : numpy.ndarray     Array containing the x, y, and chainage; unit m for x and y, km for chainage. banklines : geopandas.geodataframe.GeoDataFrame     Pandas object containing the bank lines.</p> numpy.ndarray <p>N x M array listing the nodes (max M) per face (total N) of the mesh.</p> <p>nnodes : numpy.ndarray     Number of nodes per face (max M). xn : numpy.ndarray     X-coordinates of the mesh nodes. yn : numpy.ndarray     Y-coordinates of the mesh nodes. h : numpy.ndarray     Array of water depth values. hmax : float     Water depth value to be used as upper limit for coloring. xlabel_txt : str     Label for the x-axis. ylabel_txt : str     Label for the y-axis. title_txt : str     Label for the axes title. waterdepth_txt : str     Label for the color bar.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot1_waterdepth_and_banklines--results","title":"Results","text":"<p>fig : matplotlib.figure.Figure     Figure object. ax : matplotlib.axes.Axes     Axes object.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def plot1_waterdepth_and_banklines(\n    bbox: Tuple[float, float, float, float],\n    xykm: numpy.ndarray,\n    banklines: geopandas.geodataframe.GeoDataFrame,\n    fn: numpy.ndarray,\n    nnodes: numpy.ndarray,\n    xn: numpy.ndarray,\n    yn: numpy.ndarray,\n    h: numpy.ndarray,\n    hmax: float,\n    xlabel_txt: str,\n    ylabel_txt: str,\n    title_txt: str,\n    waterdepth_txt: str,\n) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]:\n    \"\"\"\n    Create the bank erosion plot with water depths and initial bank lines.\n\n    bbox : Tuple[float, float, float, float]\n        Tuple containing boundary limits (xmin, ymin, xmax, ymax); unit m.\n    xykm : numpy.ndarray\n        Array containing the x, y, and chainage; unit m for x and y, km for chainage.\n    banklines : geopandas.geodataframe.GeoDataFrame\n        Pandas object containing the bank lines.\n\n    fn : numpy.ndarray\n        N x M array listing the nodes (max M) per face (total N) of the mesh.\n    nnodes : numpy.ndarray\n        Number of nodes per face (max M).\n    xn : numpy.ndarray\n        X-coordinates of the mesh nodes.\n    yn : numpy.ndarray\n        Y-coordinates of the mesh nodes.\n    h : numpy.ndarray\n        Array of water depth values.\n    hmax : float\n        Water depth value to be used as upper limit for coloring.\n    xlabel_txt : str\n        Label for the x-axis.\n    ylabel_txt : str\n        Label for the y-axis.\n    title_txt : str\n        Label for the axes title.\n    waterdepth_txt : str\n        Label for the color bar.\n\n    Results\n    -------\n    fig : matplotlib.figure.Figure\n        Figure object.\n    ax : matplotlib.axes.Axes\n        Axes object.\n    \"\"\"\n    fig, ax = matplotlib.pyplot.subplots()\n    setsize(fig)\n    ax.set_aspect(1)\n    #\n    scale = 1000\n    chainage_markers(xykm, ax, ndec=0, scale=scale)\n    ax.plot(xykm[:, 0] / scale, xykm[:, 1] / scale, linestyle=\"--\", color=\"k\")\n    for bl in banklines.geometry:\n        bp = numpy.array(bl.coords)\n        ax.plot(bp[:, 0] / scale, bp[:, 1] / scale, color=\"k\")\n    p = plot_mesh_patches(ax, fn, nnodes, xn, yn, h, 0, hmax)\n    cbar = fig.colorbar(p, ax=ax, shrink=0.5, drawedges=False, label=waterdepth_txt)\n    #\n    set_bbox(ax, bbox)\n    ax.set_xlabel(xlabel_txt)\n    ax.set_ylabel(ylabel_txt)\n    ax.grid(True)\n    ax.set_title(title_txt)\n    return fig, ax\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.plot2_eroded_distance_and_equilibrium","title":"<code>plot2_eroded_distance_and_equilibrium(bbox: Tuple[float, float, float, float], xykm: numpy.ndarray, bank_crds: List[numpy.ndarray], dn_tot: List[numpy.ndarray], to_right: List[bool], dnav: numpy.ndarray, xy_eq: List[numpy.ndarray], xe: numpy.ndarray, ye: numpy.ndarray, xlabel_txt: str, ylabel_txt: str, title_txt: str, erosion_txt: str, eroclr_txt: str, eqbank_txt: str) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]</code>","text":"<p>Create the bank erosion plot with predicted bank line shift and equilibrium bank line.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot2_eroded_distance_and_equilibrium--arguments","title":"Arguments","text":"<p>bbox : Tuple[float, float, float, float]     Tuple containing boundary limits (xmin, ymin, xmax, ymax); unit m. xykm : numpy.ndarray     Array containing the x, y, and chainage; unit m for x and y, km for chainage. bank_crds : List[numpy.ndarray]     List of N arrays containing the x- and y-coordinates of the original     bank lines. dn_tot : List[numpy.ndarray]     List of N arrays containing the total erosion distance values. to_right : List[bool]     List of N booleans indicating whether the bank is on the right. dnav : numpy.ndarray     Array of N average erosion distance values. xy_eq : List[numpy.ndarray]     List of N arrays containing the x- and y-coordinates of the equilibrium     bank line. xe : numpy.ndarray     M x 2 array of begin/end x-coordinates of mesh edges. ye : numpy.ndarray     M x 2 array of begin/end y-coordinates of mesh edges. xlabel_txt : str     Label for the x-axis. ylabel_txt : str     Label for the y-axis. title_txt : str     Label for the axes title. erosion_txt : str     Label for the shaded eroded area. eroclr_txt : str     Label for the color bar. eqbank_txt : str     Label for the equilibrium bank position.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot2_eroded_distance_and_equilibrium--results","title":"Results","text":"<p>fig : matplotlib.figure.Figure     Figure object. ax : matplotlib.axes.Axes     Axes object.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def plot2_eroded_distance_and_equilibrium(\n    bbox: Tuple[float, float, float, float],\n    xykm: numpy.ndarray,\n    bank_crds: List[numpy.ndarray],\n    dn_tot: List[numpy.ndarray],\n    to_right: List[bool],\n    dnav: numpy.ndarray,\n    xy_eq: List[numpy.ndarray],\n    xe: numpy.ndarray,\n    ye: numpy.ndarray,\n    xlabel_txt: str,\n    ylabel_txt: str,\n    title_txt: str,\n    erosion_txt: str,\n    eroclr_txt: str,\n    eqbank_txt: str,\n) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]:\n    \"\"\"\n    Create the bank erosion plot with predicted bank line shift and equilibrium bank line.\n\n    Arguments\n    ---------\n    bbox : Tuple[float, float, float, float]\n        Tuple containing boundary limits (xmin, ymin, xmax, ymax); unit m.\n    xykm : numpy.ndarray\n        Array containing the x, y, and chainage; unit m for x and y, km for chainage.\n    bank_crds : List[numpy.ndarray]\n        List of N arrays containing the x- and y-coordinates of the original\n        bank lines.\n    dn_tot : List[numpy.ndarray]\n        List of N arrays containing the total erosion distance values.\n    to_right : List[bool]\n        List of N booleans indicating whether the bank is on the right.\n    dnav : numpy.ndarray\n        Array of N average erosion distance values.\n    xy_eq : List[numpy.ndarray]\n        List of N arrays containing the x- and y-coordinates of the equilibrium\n        bank line.\n    xe : numpy.ndarray\n        M x 2 array of begin/end x-coordinates of mesh edges.\n    ye : numpy.ndarray\n        M x 2 array of begin/end y-coordinates of mesh edges.\n    xlabel_txt : str\n        Label for the x-axis.\n    ylabel_txt : str\n        Label for the y-axis.\n    title_txt : str\n        Label for the axes title.\n    erosion_txt : str\n        Label for the shaded eroded area.\n    eroclr_txt : str\n        Label for the color bar.\n    eqbank_txt : str\n        Label for the equilibrium bank position.\n\n    Results\n    -------\n    fig : matplotlib.figure.Figure\n        Figure object.\n    ax : matplotlib.axes.Axes\n        Axes object.\n    \"\"\"\n    scale = 1000\n    fig, ax = matplotlib.pyplot.subplots()\n    setsize(fig)\n    ax.set_aspect(1)\n    #\n    # plot_mesh(ax, xe, ye, scale=scale)\n    chainage_markers(xykm, ax, ndec=0, scale=scale)\n    dnav_max = dnav.max()\n    for ib in range(len(xy_eq)):\n        ax.plot(\n            xy_eq[ib][:, 0] / scale, xy_eq[ib][:, 1] / scale, linewidth=1, color=\"k\"\n        )\n        #\n        if to_right[ib]:\n            bankc = bank_crds[ib]\n            dnc = dn_tot[ib]\n        else:\n            bankc = bank_crds[ib][::-1]\n            dnc = dn_tot[ib][::-1]\n        nbp = len(bankc)\n        #\n        dxy = bankc[1:] - bankc[:-1]\n        ds = numpy.sqrt((dxy ** 2).sum(axis=1))\n        dxy = dxy * (dn_tot[ib] / ds).reshape((nbp - 1, 1))\n        #\n        x = numpy.zeros(((nbp - 1) * 4,))\n        x[0::4] = bankc[:-1, 0]\n        x[1::4] = bankc[1:, 0]\n        x[2::4] = bankc[:-1, 0] + dxy[:, 1]\n        x[3::4] = bankc[1:, 0] + dxy[:, 1]\n        #\n        y = numpy.zeros(((nbp - 1) * 4,))\n        y[0::4] = bankc[:-1, 1]\n        y[1::4] = bankc[1:, 1]\n        y[2::4] = bankc[:-1, 1] - dxy[:, 0]\n        y[3::4] = bankc[1:, 1] - dxy[:, 0]\n        #\n        tfn = numpy.zeros(((nbp - 1) * 2, 3))\n        tfn[0::2, 0] = [4 * i for i in range(nbp - 1)]\n        tfn[0::2, 1] = tfn[0::2, 0] + 1\n        tfn[0::2, 2] = tfn[0::2, 0] + 2\n        #\n        tfn[1::2, 0] = tfn[0::2, 0] + 1\n        tfn[1::2, 1] = tfn[0::2, 0] + 2\n        tfn[1::2, 2] = tfn[0::2, 0] + 3\n        #\n        tval = numpy.zeros(((nbp - 1) * 2,))\n        tval[0::2] = dnc\n        tval[1::2] = dnc\n        #\n        colors = [\"lawngreen\", \"gold\", \"darkorange\"]\n        cmap = matplotlib.colors.LinearSegmentedColormap.from_list(\"mycmap\", colors)\n        p = ax.tripcolor(\n            x / scale,\n            y / scale,\n            tfn,\n            facecolors=tval,\n            edgecolors=\"face\",\n            linewidth=0.5,\n            cmap=cmap,\n            vmin=0,\n            vmax=2 * dnav_max,\n        )\n    #\n    cbar = fig.colorbar(\n        p, ax=ax, shrink=0.5, drawedges=False, label=eroclr_txt\n    )\n    #\n    shaded = matplotlib.patches.Patch(color=\"gold\", linewidth=0.5)\n    eqbank = matplotlib.lines.Line2D([], [], color=\"k\", linewidth=1)\n    handles = [shaded, eqbank]\n    labels = [erosion_txt, eqbank_txt]\n    #\n    set_bbox(ax, bbox)\n    ax.set_xlabel(xlabel_txt)\n    ax.set_ylabel(ylabel_txt)\n    ax.grid(True)\n    ax.set_title(title_txt)\n    ax.legend(handles, labels, loc=\"upper right\")\n    return fig, ax\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.plot3_eroded_volume","title":"<code>plot3_eroded_volume(km_mid: numpy.ndarray, km_step: float, chainage_txt: str, dv: List[List[numpy.ndarray]], ylabel_txt: str, title_txt: str, qlabel: str, banklabel: str) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]</code>","text":"<p>Create the bank erosion plot with total eroded volume subdivided per discharge level.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot3_eroded_volume--arguments","title":"Arguments","text":"<p>km_mid : numpy.ndarray     Array containing the mid points for the chainage bins. km_step : float     Bin width. chainage_txt : str     Label for the horizontal chainage axes. dv : List[List[numpy.ndarray]]     List of nQ lists of N arrays containing the total erosion distance values ylabel_txt : str     Label for the vertical erosion volume axes. title_txt : str     Label for axes title. qlabel : str     Label for discharge level. banklabel : str     Label for bank id.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot3_eroded_volume--results","title":"Results","text":"<p>fig : matplotlib.figure.Figure     Figure object. ax : matplotlib.axes.Axes     Axes object.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def plot3_eroded_volume(\n    km_mid: numpy.ndarray,\n    km_step: float,\n    chainage_txt: str,\n    dv: List[List[numpy.ndarray]],\n    ylabel_txt: str,\n    title_txt: str,\n    qlabel: str,\n    banklabel: str,\n) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]:\n    \"\"\"\n    Create the bank erosion plot with total eroded volume subdivided per discharge level.\n\n    Arguments\n    ---------\n    km_mid : numpy.ndarray\n        Array containing the mid points for the chainage bins.\n    km_step : float\n        Bin width.\n    chainage_txt : str\n        Label for the horizontal chainage axes.\n    dv : List[List[numpy.ndarray]]\n        List of nQ lists of N arrays containing the total erosion distance values\n    ylabel_txt : str\n        Label for the vertical erosion volume axes.\n    title_txt : str\n        Label for axes title.\n    qlabel : str\n        Label for discharge level.\n    banklabel : str\n        Label for bank id.\n\n    Results\n    -------\n    fig : matplotlib.figure.Figure\n        Figure object.\n    ax : matplotlib.axes.Axes\n        Axes object.\n    \"\"\"\n    fig, ax = matplotlib.pyplot.subplots()\n    setsize(fig)\n    #\n    plot3_stacked_per_discharge(ax, km_mid + 0.2 * km_step, km_step, dv, qlabel, 0.4)\n    plot3_stacked_per_bank(ax, km_mid - 0.2 * km_step, km_step, dv, banklabel, 0.4)\n    #\n    ax.set_xlabel(chainage_txt)\n    ax.set_ylabel(ylabel_txt)\n    ax.grid(True)\n    ax.set_title(title_txt)\n    ax.legend(loc=\"upper right\")\n    return fig, ax\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.plot3_eroded_volume_subdivided_1","title":"<code>plot3_eroded_volume_subdivided_1(km_mid: numpy.ndarray, km_step: float, chainage_txt: str, dv: List[List[numpy.ndarray]], ylabel_txt: str, title_txt: str, qlabel: str) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]</code>","text":"<p>Create the bank erosion plot with total eroded volume subdivided per discharge level.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot3_eroded_volume_subdivided_1--arguments","title":"Arguments","text":"<p>km_mid : numpy.ndarray     Array containing the mid points for the chainage bins. km_step : float     Bin width. chainage_txt : str     Label for the horizontal chainage axes. dv : List[List[numpy.ndarray]]     List of nQ lists of N arrays containing the total erosion distance values ylabel_txt : str     Label for the vertical erosion volume axes. title_txt : str     Label for axes title. qlabel : str     Label for discharge level.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot3_eroded_volume_subdivided_1--results","title":"Results","text":"<p>fig : matplotlib.figure.Figure     Figure object. ax : matplotlib.axes.Axes     Axes object.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def plot3_eroded_volume_subdivided_1(\n    km_mid: numpy.ndarray,\n    km_step: float,\n    chainage_txt: str,\n    dv: List[List[numpy.ndarray]],\n    ylabel_txt: str,\n    title_txt: str,\n    qlabel: str,\n) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]:\n    \"\"\"\n    Create the bank erosion plot with total eroded volume subdivided per discharge level.\n\n    Arguments\n    ---------\n    km_mid : numpy.ndarray\n        Array containing the mid points for the chainage bins.\n    km_step : float\n        Bin width.\n    chainage_txt : str\n        Label for the horizontal chainage axes.\n    dv : List[List[numpy.ndarray]]\n        List of nQ lists of N arrays containing the total erosion distance values\n    ylabel_txt : str\n        Label for the vertical erosion volume axes.\n    title_txt : str\n        Label for axes title.\n    qlabel : str\n        Label for discharge level.\n\n    Results\n    -------\n    fig : matplotlib.figure.Figure\n        Figure object.\n    ax : matplotlib.axes.Axes\n        Axes object.\n    \"\"\"\n    fig, ax = matplotlib.pyplot.subplots()\n    setsize(fig)\n    #\n    plot3_stacked_per_discharge(ax, km_mid, km_step, dv, qlabel, 0.8)\n    #\n    ax.set_xlabel(chainage_txt)\n    ax.set_ylabel(ylabel_txt)\n    ax.grid(True)\n    ax.set_title(title_txt)\n    ax.legend(loc=\"upper right\")\n    return fig, ax\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.plot3_eroded_volume_subdivided_2","title":"<code>plot3_eroded_volume_subdivided_2(km_mid: numpy.ndarray, km_step: float, chainage_txt: str, dv: List[List[numpy.ndarray]], ylabel_txt: str, title_txt: str, banklabel: str) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]</code>","text":"<p>Create the bank erosion plot with total eroded volume subdivided per bank.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot3_eroded_volume_subdivided_2--arguments","title":"Arguments","text":"<p>km_mid : numpy.ndarray     Array containing the mid points for the chainage bins. km_step : float     Bin width. chainage_txt : str     Label for the horizontal chainage axes. dv : List[List[numpy.ndarray]]     List of nQ lists of N arrays containing the total erosion distance values ylabel_txt : str     Label for the vertical erosion volume axes. title_txt : str     Label for axes title. banklabel : str     Label for bank id.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot3_eroded_volume_subdivided_2--results","title":"Results","text":"<p>fig : matplotlib.figure.Figure     Figure object. ax : matplotlib.axes.Axes     Axes object.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def plot3_eroded_volume_subdivided_2(\n    km_mid: numpy.ndarray,\n    km_step: float,\n    chainage_txt: str,\n    dv: List[List[numpy.ndarray]],\n    ylabel_txt: str,\n    title_txt: str,\n    banklabel: str,\n) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]:\n    \"\"\"\n    Create the bank erosion plot with total eroded volume subdivided per bank.\n\n    Arguments\n    ---------\n    km_mid : numpy.ndarray\n        Array containing the mid points for the chainage bins.\n    km_step : float\n        Bin width.\n    chainage_txt : str\n        Label for the horizontal chainage axes.\n    dv : List[List[numpy.ndarray]]\n        List of nQ lists of N arrays containing the total erosion distance values\n    ylabel_txt : str\n        Label for the vertical erosion volume axes.\n    title_txt : str\n        Label for axes title.\n    banklabel : str\n        Label for bank id.\n\n    Results\n    -------\n    fig : matplotlib.figure.Figure\n        Figure object.\n    ax : matplotlib.axes.Axes\n        Axes object.\n    \"\"\"\n    fig, ax = matplotlib.pyplot.subplots()\n    setsize(fig)\n    #\n    plot3_stacked_per_bank(ax, km_mid, km_step, dv, banklabel, 0.8)\n    #\n    ax.set_xlabel(chainage_txt)\n    ax.set_ylabel(ylabel_txt)\n    ax.grid(True)\n    ax.set_title(title_txt)\n    ax.legend(loc=\"upper right\")\n    return fig, ax\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.plot3_stacked_per_bank","title":"<code>plot3_stacked_per_bank(ax: matplotlib.axes.Axes, km_mid: numpy.ndarray, km_step: float, dv: List[List[numpy.ndarray]], banklabel: str, wfrac: float) -&gt; None</code>","text":"<p>Add a stacked plot of bank erosion with total eroded volume subdivided per bank to the selected axes.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot3_stacked_per_bank--arguments","title":"Arguments","text":"<p>fig : matplotlib.figure.Figure     Figure object. ax : matplotlib.axes.Axes     Axes object. km_mid : numpy.ndarray     Array containing the mid points for the chainage bins. km_step : float     Bin width. dv : List[List[numpy.ndarray]]     List of nQ lists of N arrays containing the total erosion distance values banklabel : str     Label for bank id. wfrac : float     Width fraction for the stacked column.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot3_stacked_per_bank--results","title":"Results","text":"<p>None</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def plot3_stacked_per_bank(\n   ax: matplotlib.axes.Axes,\n   km_mid: numpy.ndarray,\n   km_step: float,\n   dv: List[List[numpy.ndarray]],\n   banklabel: str,\n   wfrac: float,\n) -&gt; None:\n    \"\"\"\n    Add a stacked plot of bank erosion with total eroded volume subdivided per bank to the selected axes.\n\n    Arguments\n    ---------\n    fig : matplotlib.figure.Figure\n        Figure object.\n    ax : matplotlib.axes.Axes\n        Axes object.\n    km_mid : numpy.ndarray\n        Array containing the mid points for the chainage bins.\n    km_step : float\n        Bin width.\n    dv : List[List[numpy.ndarray]]\n        List of nQ lists of N arrays containing the total erosion distance values\n    banklabel : str\n        Label for bank id.\n    wfrac : float\n        Width fraction for the stacked column.\n\n    Results\n    -------\n    None\n    \"\"\"\n    n_banklines = len(dv[0])\n    clrs = get_colors(\"plasma\", n_banklines + 1)\n    for ib in range(n_banklines):\n        for iq in range(len(dv)):\n            if iq == 0:\n                dvq = dv[iq][ib].copy()\n            else:\n                dvq = dvq + dv[iq][ib]\n        if ib == 0:\n            ax.bar(\n                km_mid,\n                dvq,\n                width=wfrac * km_step,\n                color=clrs[ib],\n                label=banklabel.format(ib=ib + 1),\n            )\n            cumdv = dvq\n        else:\n            ax.bar(\n                km_mid,\n                dvq,\n                width=wfrac * km_step,\n                bottom=cumdv,\n                color=clrs[ib],\n                label=banklabel.format(ib=ib + 1),\n            )\n            cumdv = cumdv + dvq\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.plot3_stacked_per_discharge","title":"<code>plot3_stacked_per_discharge(ax: matplotlib.axes.Axes, km_mid: numpy.ndarray, km_step: float, dv: List[List[numpy.ndarray]], qlabel: str, wfrac: float) -&gt; None</code>","text":"<p>Add a stacked plot of bank erosion with total eroded volume subdivided per discharge level to the selected axes.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot3_stacked_per_discharge--arguments","title":"Arguments","text":"<p>fig : matplotlib.figure.Figure     Figure object. ax : matplotlib.axes.Axes     Axes object. km_mid : numpy.ndarray     Array containing the mid points for the chainage bins. km_step : float     Bin width. dv : List[List[numpy.ndarray]]     List of nQ lists of N arrays containing the total erosion distance values qlabel : str     Label for discharge level. wfrac : float     Width fraction for the stacked column.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot3_stacked_per_discharge--results","title":"Results","text":"<p>None</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def plot3_stacked_per_discharge(\n   ax: matplotlib.axes.Axes,\n   km_mid: numpy.ndarray,\n   km_step: float,\n   dv: List[List[numpy.ndarray]],\n   qlabel: str,\n   wfrac: float,\n) -&gt; None:\n    \"\"\"\n    Add a stacked plot of bank erosion with total eroded volume subdivided per discharge level to the selected axes.\n\n    Arguments\n    ---------\n    fig : matplotlib.figure.Figure\n        Figure object.\n    ax : matplotlib.axes.Axes\n        Axes object.\n    km_mid : numpy.ndarray\n        Array containing the mid points for the chainage bins.\n    km_step : float\n        Bin width.\n    dv : List[List[numpy.ndarray]]\n        List of nQ lists of N arrays containing the total erosion distance values\n    qlabel : str\n        Label for discharge level.\n    wfrac : float\n        Width fraction for the stacked column.\n\n    Results\n    -------\n    None\n    \"\"\"\n    n_levels = len(dv)\n    clrs = get_colors(\"Blues\", n_levels + 1)\n    for iq in range(n_levels):\n        for ib in range(len(dv[iq])):\n            if ib == 0:\n                dvq = dv[iq][ib].copy()\n            else:\n                dvq = dvq + dv[iq][ib]\n        if iq == 0:\n            ax.bar(\n                km_mid,\n                dvq,\n                width=wfrac * km_step,\n                color=clrs[iq + 1],\n                label=qlabel.format(iq=iq + 1),\n            )\n            cumdv = dvq\n        else:\n            ax.bar(\n                km_mid,\n                dvq,\n                width=wfrac * km_step,\n                bottom=cumdv,\n                color=clrs[iq + 1],\n                label=qlabel.format(iq=iq + 1),\n            )\n            cumdv = cumdv + dvq\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.plot4_eroded_volume_eq","title":"<code>plot4_eroded_volume_eq(km_mid: numpy.ndarray, km_step: float, chainage_txt: str, vol_eq: numpy.ndarray, ylabel_txt: str, title_txt: str) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]</code>","text":"<p>Create the bank erosion plot with equilibrium eroded volume.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot4_eroded_volume_eq--arguments","title":"Arguments","text":"<p>km_mid : numpy.ndarray     Array containing the mid points for the chainage bins. km_step : float     Bin width. chainage_txt : str     Label for the horizontal chainage axes. vol_eq : numpy.ndarray     Array containing the equilibrium eroded volume per bin. ylabel_txt : str     Label for the vertical erosion volume axes. title_txt : str     Label for axes title.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot4_eroded_volume_eq--results","title":"Results","text":"<p>fig : matplotlib.figure.Figure     Figure object. ax : matplotlib.axes.Axes     Axes object.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def plot4_eroded_volume_eq(\n    km_mid: numpy.ndarray,\n    km_step: float,\n    chainage_txt: str,\n    vol_eq: numpy.ndarray,\n    ylabel_txt: str,\n    title_txt: str,\n) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]:\n    \"\"\"\n    Create the bank erosion plot with equilibrium eroded volume.\n\n    Arguments\n    ---------\n    km_mid : numpy.ndarray\n        Array containing the mid points for the chainage bins.\n    km_step : float\n        Bin width.\n    chainage_txt : str\n        Label for the horizontal chainage axes.\n    vol_eq : numpy.ndarray\n        Array containing the equilibrium eroded volume per bin.\n    ylabel_txt : str\n        Label for the vertical erosion volume axes.\n    title_txt : str\n        Label for axes title.\n\n    Results\n    -------\n    fig : matplotlib.figure.Figure\n        Figure object.\n    ax : matplotlib.axes.Axes\n        Axes object.\n    \"\"\"\n    fig, ax = matplotlib.pyplot.subplots()\n    setsize(fig)\n    #\n    tvol = numpy.zeros(km_mid.shape)\n    for i in range(len(km_mid)):\n        tvol[i] = vol_eq[i].sum()\n    ax.bar(km_mid, tvol, width=0.8 * km_step)\n    #\n    ax.set_xlabel(chainage_txt)\n    ax.set_ylabel(ylabel_txt)\n    ax.grid(True)\n    ax.set_title(title_txt)\n    return fig, ax\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.plot5series_waterlevels_per_bank","title":"<code>plot5series_waterlevels_per_bank(bank_km_mid: List[numpy.ndarray], chainage_txt: str, waterlevel: List[List[numpy.ndarray]], shipwavemax: List[List[numpy.ndarray]], shipwavemin: List[List[numpy.ndarray]], waterlevelq_txt: str, avg_waterlevel_txt: str, shipwave_txt: str, bankheight: List[numpy.ndarray], bankheight_txt: str, bankprotect: List[numpy.ndarray], bankprotect_txt: str, elevation_txt: str, title_txt: str, elevation_unit: str) -&gt; [List[matplotlib.figure.Figure], List[matplotlib.axes.Axes]]</code>","text":"<p>Create the bank erosion plots with water levels, bank height and bank protection height along each bank.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot5series_waterlevels_per_bank--arguments","title":"Arguments","text":"<p>bank_km_mid : List[numpy.ndarray]     List of arrays containing the chainage values per bank (segment) [km]. chainage_txt : str     Label for the horizontal chainage axes. waterlevel : List[List[numpy.ndarray]]     List of arrays containing the water levels per bank (point) [elevation_unit]. shipmwavemax : numpy.ndarray     Maximum bank level subject to ship waves [m] shipwavemin : numpy.ndarray     Minimum bank level subject to ship waves [m] waterlevelq_txt : str     Label for the water level per discharge level. avg_waterlevel_txt : str     Label for the average water level. shipwave_txt : str     Label for the elevation range influenced by ship waves. bankheight : List[numpy.ndarray]     List of arrays containing the bank heights per bank (segment) [elevation_unit]. bankheight_txt : str     Label for the bank height. bankprotect : List[numpy.ndarray]     List of arrays containing the bank protection height per bank (point) [elevation_unit]. bankprotect_txt : str     Label for the bank protection height. elevation_txt : str     General label for elevation data. title_txt : str     Label for the axes title. elevation_unit : str     Unit used for all elevation data.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot5series_waterlevels_per_bank--results","title":"Results","text":"<p>figlist : List[matplotlib.figure.Figure]     List of figure objects, one per bank. axlist : List[matplotlib.axes.Axes]     List of axes objects, one per bank.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def plot5series_waterlevels_per_bank(\n    bank_km_mid: List[numpy.ndarray],\n    chainage_txt: str,\n    waterlevel: List[List[numpy.ndarray]],\n    shipwavemax: List[List[numpy.ndarray]],\n    shipwavemin: List[List[numpy.ndarray]],\n    waterlevelq_txt: str,\n    avg_waterlevel_txt: str,\n    shipwave_txt: str,\n    bankheight: List[numpy.ndarray],\n    bankheight_txt: str,\n    bankprotect: List[numpy.ndarray],\n    bankprotect_txt: str,\n    elevation_txt: str,\n    title_txt: str,\n    elevation_unit: str,\n) -&gt; [List[matplotlib.figure.Figure], List[matplotlib.axes.Axes]]:\n    \"\"\"\n    Create the bank erosion plots with water levels, bank height and bank protection height along each bank.\n\n    Arguments\n    ---------\n    bank_km_mid : List[numpy.ndarray]\n        List of arrays containing the chainage values per bank (segment) [km].\n    chainage_txt : str\n        Label for the horizontal chainage axes.\n    waterlevel : List[List[numpy.ndarray]]\n        List of arrays containing the water levels per bank (point) [elevation_unit].\n    shipmwavemax : numpy.ndarray\n        Maximum bank level subject to ship waves [m]\n    shipwavemin : numpy.ndarray\n        Minimum bank level subject to ship waves [m]\n    waterlevelq_txt : str\n        Label for the water level per discharge level.\n    avg_waterlevel_txt : str\n        Label for the average water level.\n    shipwave_txt : str\n        Label for the elevation range influenced by ship waves.\n    bankheight : List[numpy.ndarray]\n        List of arrays containing the bank heights per bank (segment) [elevation_unit].\n    bankheight_txt : str\n        Label for the bank height.\n    bankprotect : List[numpy.ndarray]\n        List of arrays containing the bank protection height per bank (point) [elevation_unit].\n    bankprotect_txt : str\n        Label for the bank protection height.\n    elevation_txt : str\n        General label for elevation data.\n    title_txt : str\n        Label for the axes title.\n    elevation_unit : str\n        Unit used for all elevation data.\n\n    Results\n    -------\n    figlist : List[matplotlib.figure.Figure]\n        List of figure objects, one per bank.\n    axlist : List[matplotlib.axes.Axes]\n        List of axes objects, one per bank.\n    \"\"\"\n    n_banklines = len(bank_km_mid)\n    n_levels = len(waterlevel)\n    figlist: List[matplotlib.figure.Figure] = []\n    axlist: List[matplotlib.axes.Axes] = []\n    clrs = get_colors(\"Blues\", n_levels + 1)\n    for ib in range(n_banklines):\n        fig, ax = matplotlib.pyplot.subplots()\n        setsize(fig)\n        bk = bank_km_mid[ib]\n        #\n        for iq in range(n_levels):\n            # shaded range of influence for ship waves\n            ax.fill_between(\n                bk,\n                shipwavemin[iq][ib],\n                shipwavemax[iq][ib],\n                color=clrs[iq + 1],\n                alpha=0.1,\n            )\n            ax.plot(\n                bk,\n                shipwavemax[iq][ib],\n                color=clrs[iq + 1],\n                linestyle=\"--\",\n                linewidth=0.5,\n            )\n            ax.plot(\n                bk,\n                shipwavemin[iq][ib],\n                color=clrs[iq + 1],\n                linestyle=\"--\",\n                linewidth=0.5,\n            )\n            # water level line itself\n            ax.plot(\n                bk,\n                waterlevel[iq][ib],\n                color=clrs[iq + 1],\n                label=waterlevelq_txt.format(iq=iq + 1),\n            )\n            if iq == 0:\n                wl_avg = waterlevel[iq][ib].copy()\n            else:\n                wl_avg = wl_avg + waterlevel[iq][ib]\n        #\n        wl_avg = wl_avg / n_levels\n        ax.plot(\n            bk, wl_avg, color=(0.5, 0.5, 0.5), linewidth=2, label=avg_waterlevel_txt,\n        )\n        ax.plot(bk, bankheight[ib], color=(0.5, 0.5, 0.5), label=bankheight_txt)\n        ymin, ymax = ax.get_ylim()\n        #\n        # bank protection is only visually included in the plot\n        # if it is in the same range as the other quantities\n        # don't stretch the vertical scale to squeeze in a very low value.\n        #\n        ax.plot(\n            bk,\n            bankprotect[ib],\n            color=(0.5, 0.5, 0.5),\n            linestyle=\"--\",\n            label=bankprotect_txt,\n        )\n        ax.set_ylim(ymin=ymin, ymax=ymax)\n        #\n        handles, labels = ax.get_legend_handles_labels()\n        #\n        # use a slightly higher alpha for the legend to make it stand out better.\n        iq = int(n_levels/2)\n        shaded = matplotlib.patches.Patch(color=clrs[iq + 1], alpha=0.2)\n        handles = [*handles[:-3], shaded, *handles[-3:]]\n        labels = [*labels[:-3], shipwave_txt, *labels[-3:]]\n        #\n        ax.set_xlabel(chainage_txt)\n        ax.set_ylabel(elevation_txt + \" \" + elevation_unit)\n        ax.grid(True)\n        ax.set_title(title_txt.format(ib=ib + 1))\n        ax.legend(handles, labels, loc=\"upper right\")\n        figlist.append(fig)\n        axlist.append(ax)\n    return figlist, axlist\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.plot6series_velocity_per_bank","title":"<code>plot6series_velocity_per_bank(bank_km_mid: List[numpy.ndarray], chainage_txt: str, veloc: List[List[numpy.ndarray]], velocq_txt: str, tauc: List[numpy.ndarray], chezy: List[numpy.ndarray], rho: float, g: float, ucrit_txt: str, ylabel_txt: str, title_txt: str, veloc_unit: str) -&gt; [List[matplotlib.figure.Figure], List[matplotlib.axes.Axes]]</code>","text":"<p>Create the bank erosion plots with velocities and critical velocities along each bank.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot6series_velocity_per_bank--arguments","title":"Arguments","text":"<p>bank_km_mid : List[numpy.ndarray]     List of arrays containing the chainage values per bank (segment) [km]. chainage_txt : str     Label for the horizontal chainage axes. veloc: List[List[numpy.ndarray]]     List of arrays containing the velocities per bank (segment) [m/s]. velocq_txt: str,     Label for the velocity per discharge level. tauc: List[numpy.ndarray]     List of arrays containing the shear stresses per bank (point) [N/m2]. chezy: List[numpy.ndarray]     List of arrays containing the Chezy values per bank [m0.5/s]. rho: float     Water density [kg/m3]. g: float     Gravitational acceleration [m/s2]. ucrit_txt: str     Label for the critical velocity. ylabel_txt: str     Label for the vertical (velocity) axis. title_txt: str     Label for the axes title. veloc_unit: str     Unit used for all velocities.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot6series_velocity_per_bank--results","title":"Results","text":"<p>figlist : List[matplotlib.figure.Figure]     List of figure objects, one per bank. axlist : List[matplotlib.axes.Axes]     List of axes objects, one per bank.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def plot6series_velocity_per_bank(\n    bank_km_mid: List[numpy.ndarray],\n    chainage_txt: str,\n    veloc: List[List[numpy.ndarray]],\n    velocq_txt: str,\n    tauc: List[numpy.ndarray],\n    chezy: List[numpy.ndarray],\n    rho: float,\n    g: float,\n    ucrit_txt: str,\n    ylabel_txt: str,\n    title_txt: str,\n    veloc_unit: str,\n) -&gt; [List[matplotlib.figure.Figure], List[matplotlib.axes.Axes]]:\n    \"\"\"\n    Create the bank erosion plots with velocities and critical velocities along each bank.\n\n    Arguments\n    ---------\n    bank_km_mid : List[numpy.ndarray]\n        List of arrays containing the chainage values per bank (segment) [km].\n    chainage_txt : str\n        Label for the horizontal chainage axes.\n    veloc: List[List[numpy.ndarray]]\n        List of arrays containing the velocities per bank (segment) [m/s].\n    velocq_txt: str,\n        Label for the velocity per discharge level.\n    tauc: List[numpy.ndarray]\n        List of arrays containing the shear stresses per bank (point) [N/m2].\n    chezy: List[numpy.ndarray]\n        List of arrays containing the Chezy values per bank [m0.5/s].\n    rho: float\n        Water density [kg/m3].\n    g: float\n        Gravitational acceleration [m/s2].\n    ucrit_txt: str\n        Label for the critical velocity.\n    ylabel_txt: str\n        Label for the vertical (velocity) axis.\n    title_txt: str\n        Label for the axes title.\n    veloc_unit: str\n        Unit used for all velocities.\n\n    Results\n    -------\n    figlist : List[matplotlib.figure.Figure]\n        List of figure objects, one per bank.\n    axlist : List[matplotlib.axes.Axes]\n        List of axes objects, one per bank.\n    \"\"\"\n    n_banklines = len(bank_km_mid)\n    n_levels = len(veloc)\n    figlist: List[matplotlib.figure.Figure] = []\n    axlist: List[matplotlib.axes.Axes] = []\n    clrs = get_colors(\"Blues\", n_levels + 1)\n    for ib in range(n_banklines):\n        fig, ax = matplotlib.pyplot.subplots()\n        setsize(fig)\n        bk = bank_km_mid[ib]\n        #\n        velc = numpy.sqrt(tauc[ib] * chezy[ib] ** 2 / (rho * g))\n        ax.plot(bank_km_mid[ib], velc, color=\"k\", label=ucrit_txt)\n        for iq in range(n_levels):\n            ax.plot(\n                bk,\n                veloc[iq][ib],\n                color=clrs[iq + 1],\n                label=velocq_txt.format(iq=iq + 1),\n            )\n        #\n        ax.set_xlabel(chainage_txt)\n        ax.set_ylabel(ylabel_txt + \" \" + veloc_unit)\n        ax.grid(True)\n        ax.set_title(title_txt.format(ib=ib + 1))\n        ax.legend(loc=\"upper right\")\n        figlist.append(fig)\n        axlist.append(ax)\n    return figlist, axlist\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.plot7_banktype","title":"<code>plot7_banktype(bbox: Tuple[float, float, float, float], xykm: numpy.ndarray, bank_crds: List[numpy.ndarray], banktype: List[numpy.ndarray], taucls_str: List[str], xlabel_txt: str, ylabel_txt: str, title_txt: str) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]</code>","text":"<p>Create the bank erosion plot with colour-coded bank types.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot7_banktype--arguments","title":"Arguments","text":"<p>bbox : Tuple[float, float, float, float]     Tuple containing boundary limits (xmin, ymin, xmax, ymax); unit m. xykm : numpy.ndarray     Array containing the x, y, and chainage; unit m for x and y, km for chainage. bank_crds : List[numpy.ndarray]     List of N arrays containing the x- and y-coordinates of the oroginal     bank lines. banktype : List[numpy.ndarray]     List of N arrays containing the bank type values. taucls_str : List[str]     List of strings representing the distinct bank type classes. xlabel_txt : str     Label for the x-axis. ylabel_txt : str     Label for the y-axis. title_txt : str     Label for the axes title.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot7_banktype--results","title":"Results","text":"<p>fig : matplotlib.figure.Figure     Figure object. ax : matplotlib.axes.Axes     Axes object.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def plot7_banktype(\n    bbox: Tuple[float, float, float, float],\n    xykm: numpy.ndarray,\n    bank_crds: List[numpy.ndarray],\n    banktype: List[numpy.ndarray],\n    taucls_str: List[str],\n    xlabel_txt: str,\n    ylabel_txt: str,\n    title_txt: str,\n) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]:\n    \"\"\"\n    Create the bank erosion plot with colour-coded bank types.\n\n    Arguments\n    ---------\n    bbox : Tuple[float, float, float, float]\n        Tuple containing boundary limits (xmin, ymin, xmax, ymax); unit m.\n    xykm : numpy.ndarray\n        Array containing the x, y, and chainage; unit m for x and y, km for chainage.\n    bank_crds : List[numpy.ndarray]\n        List of N arrays containing the x- and y-coordinates of the oroginal\n        bank lines.\n    banktype : List[numpy.ndarray]\n        List of N arrays containing the bank type values.\n    taucls_str : List[str]\n        List of strings representing the distinct bank type classes.\n    xlabel_txt : str\n        Label for the x-axis.\n    ylabel_txt : str\n        Label for the y-axis.\n    title_txt : str\n        Label for the axes title.\n\n    Results\n    -------\n    fig : matplotlib.figure.Figure\n        Figure object.\n    ax : matplotlib.axes.Axes\n        Axes object.\n    \"\"\"\n    fig, ax = matplotlib.pyplot.subplots()\n    setsize(fig)\n    ax.set_aspect(1)\n    #\n    scale = 1000\n    chainage_markers(xykm, ax, ndec=0, scale=scale)\n    clrs = get_colors(\"plasma\", len(taucls_str) + 1)\n    for ib in range(len(bank_crds)):\n        for ibt in range(len(taucls_str)):\n            ibtEdges = numpy.nonzero(banktype[ib] == ibt)[0]\n            if len(ibtEdges) &gt; 0:\n                nedges = len(ibtEdges)\n                nx = max(3 * nedges - 1, 0)\n                x = numpy.zeros((nx,)) + numpy.nan\n                y = x.copy()\n                x[0::3] = bank_crds[ib][ibtEdges, 0].copy() / scale\n                y[0::3] = bank_crds[ib][ibtEdges, 1].copy() / scale\n                x[1::3] = bank_crds[ib][ibtEdges + 1, 0].copy() / scale\n                y[1::3] = bank_crds[ib][ibtEdges + 1, 1].copy() / scale\n                #\n                if ib == 0:\n                    ax.plot(x, y, color=clrs[ibt], label=taucls_str[ibt])\n                else:\n                    ax.plot(x, y, color=clrs[ibt])\n            else:\n                if ib == 0:\n                    ax.plot(\n                        numpy.nan, numpy.nan, color=clrs[ibt], label=taucls_str[ibt]\n                    )\n    #\n    set_bbox(ax, bbox)\n    ax.set_xlabel(xlabel_txt)\n    ax.set_ylabel(ylabel_txt)\n    ax.grid(True)\n    ax.set_title(title_txt)\n    ax.legend(loc=\"upper right\")\n    return fig, ax\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.plot8_eroded_distance","title":"<code>plot8_eroded_distance(bank_km_mid: List[numpy.ndarray], chainage_txt: str, dn_tot: List[numpy.ndarray], dn_tot_txt: str, dn_eq: List[numpy.ndarray], dn_eq_txt: str, dn_txt: str, dn_unit: str) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]</code>","text":"<p>Create the bank erosion plot with total and equilibrium eroded distance.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot8_eroded_distance--arguments","title":"Arguments","text":"<p>bank_km_mid : List[numpy.ndarray]     List of arrays containing the chainage values per bank (segment) [km]. chainage_txt : str     Label for the horizontal chainage axes. dn_tot : List[numpy.ndarray]     List of arrays containing the total bank erosion distance per bank (segment) [m]. dn_tot_txt : str     Label for the total bank erosion distance. dn_eq : List[numpy.ndarray]     List of arrays containing the equilibrium bank erosion distance per bank (segment) [m]. dn_eq_txt : str     Label for equilibrium bank erosion distance. dn_txt : str     General label for bank erosion distance. dn_unit: str     Unit used for bank erosion distance.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot8_eroded_distance--results","title":"Results","text":"<p>fig : matplotlib.figure.Figure     Figure object. ax : matplotlib.axes.Axes     Axes object.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def plot8_eroded_distance(\n    bank_km_mid: List[numpy.ndarray],\n    chainage_txt: str,\n    dn_tot: List[numpy.ndarray],\n    dn_tot_txt: str,\n    dn_eq: List[numpy.ndarray],\n    dn_eq_txt: str,\n    dn_txt: str,\n    dn_unit: str,\n) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]:\n    \"\"\"\n    Create the bank erosion plot with total and equilibrium eroded distance.\n\n    Arguments\n    ---------\n    bank_km_mid : List[numpy.ndarray]\n        List of arrays containing the chainage values per bank (segment) [km].\n    chainage_txt : str\n        Label for the horizontal chainage axes.\n    dn_tot : List[numpy.ndarray]\n        List of arrays containing the total bank erosion distance per bank (segment) [m].\n    dn_tot_txt : str\n        Label for the total bank erosion distance.\n    dn_eq : List[numpy.ndarray]\n        List of arrays containing the equilibrium bank erosion distance per bank (segment) [m].\n    dn_eq_txt : str\n        Label for equilibrium bank erosion distance.\n    dn_txt : str\n        General label for bank erosion distance.\n    dn_unit: str\n        Unit used for bank erosion distance.\n\n    Results\n    -------\n    fig : matplotlib.figure.Figure\n        Figure object.\n    ax : matplotlib.axes.Axes\n        Axes object.\n    \"\"\"\n    fig, ax = matplotlib.pyplot.subplots()\n    setsize(fig)\n    #\n    n_banklines = len(dn_tot)\n    clrs = get_colors(\"plasma\", n_banklines + 1)\n    for ib in range(n_banklines):\n        bk = bank_km_mid[ib]\n        ax.plot(bk, dn_tot[ib], color=clrs[ib], label=dn_tot_txt.format(ib=ib + 1))\n        ax.plot(\n            bk,\n            dn_eq[ib],\n            linestyle=\":\",\n            color=clrs[ib],\n            label=dn_eq_txt.format(ib=ib + 1),\n        )\n    #\n    ax.set_xlabel(chainage_txt)\n    ax.set_ylabel(dn_txt + \" \" + dn_unit)\n    ax.grid(True)\n    ax.set_title(dn_txt)\n    ax.legend(loc=\"upper right\")\n    return fig, ax\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.plot_detect1","title":"<code>plot_detect1(bbox: Tuple[float, float, float, float], xykm: numpy.ndarray, bankareas: List[Polygon], bank: List[LineString], fn: numpy.ndarray, nnodes: numpy.ndarray, xn: numpy.ndarray, yn: numpy.ndarray, h: numpy.ndarray, hmax: float, xlabel_txt: str, ylabel_txt: str, title_txt: str, waterdepth_txt: str, bankarea_txt: str, bankline_txt: str, config_file: ConfigFile) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]</code>","text":"<p>Create the bank line detection plot.</p> <p>The figure contains a map of the water depth, the chainage, and detected bank lines.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot_detect1--arguments","title":"Arguments","text":"<p>bbox : Tuple[float, float, float, float]     Tuple containing boundary limits (xmin, ymin, xmax, ymax); unit m. xykm : numpy.ndarray     Array containing the x, y, and chainage; unit m for x and y, km for chainage. bankareas : List[Polygon]     List of bank polygons. bank : List[LineString]     List of bank lines. fn : numpy.ndarray     N x M array listing the nodes (max M) per face (total N) of the mesh. nnodes : numpy.ndarray     Number of nodes per face (max M). xn : numpy.ndarray     X-coordinates of the mesh nodes. yn : numpy.ndarray     Y-coordinates of the mesh nodes. h : numpy.ndarray     Array of water depth values. hmax : float     Water depth value to be used as upper limit for coloring. xlabel_txt : str     Label for the x-axis. ylabel_txt : str     Label for the y-axis. title_txt : str     Label for the axes title. waterdepth_txt : str     Label for the color bar. bankarea_txt : str     Label for the bank search areas. bankline_txt : str     Label for the identified bank lines.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot_detect1--returns","title":"Returns","text":"<p>fig : matplotlib.figure.Figure:     Figure object. ax : matplotlib.axes.Axes     Axes object.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def plot_detect1(\n    bbox: Tuple[float, float, float, float],\n    xykm: numpy.ndarray,\n    bankareas: List[Polygon],\n    bank: List[LineString],\n    fn: numpy.ndarray,\n    nnodes: numpy.ndarray,\n    xn: numpy.ndarray,\n    yn: numpy.ndarray,\n    h: numpy.ndarray,\n    hmax: float,\n    xlabel_txt: str,\n    ylabel_txt: str,\n    title_txt: str,\n    waterdepth_txt: str,\n    bankarea_txt: str,\n    bankline_txt: str,\n    config_file: ConfigFile,\n) -&gt; [matplotlib.figure.Figure, matplotlib.axes.Axes]:\n    \"\"\"\n    Create the bank line detection plot.\n\n    The figure contains a map of the water depth, the chainage, and detected\n    bank lines.\n\n    Arguments\n    ---------\n    bbox : Tuple[float, float, float, float]\n        Tuple containing boundary limits (xmin, ymin, xmax, ymax); unit m.\n    xykm : numpy.ndarray\n        Array containing the x, y, and chainage; unit m for x and y, km for chainage.\n    bankareas : List[Polygon]\n        List of bank polygons.\n    bank : List[LineString]\n        List of bank lines.\n    fn : numpy.ndarray\n        N x M array listing the nodes (max M) per face (total N) of the mesh.\n    nnodes : numpy.ndarray\n        Number of nodes per face (max M).\n    xn : numpy.ndarray\n        X-coordinates of the mesh nodes.\n    yn : numpy.ndarray\n        Y-coordinates of the mesh nodes.\n    h : numpy.ndarray\n        Array of water depth values.\n    hmax : float\n        Water depth value to be used as upper limit for coloring.\n    xlabel_txt : str\n        Label for the x-axis.\n    ylabel_txt : str\n        Label for the y-axis.\n    title_txt : str\n        Label for the axes title.\n    waterdepth_txt : str\n        Label for the color bar.\n    bankarea_txt : str\n        Label for the bank search areas.\n    bankline_txt : str\n        Label for the identified bank lines.\n\n    Returns\n    -------\n    fig : matplotlib.figure.Figure:\n        Figure object.\n    ax : matplotlib.axes.Axes\n        Axes object.\n    \"\"\"\n    fig, ax = matplotlib.pyplot.subplots()\n    setsize(fig)\n    ax.set_aspect(1)\n    #\n    scale = 1 # using scale 1 here because of the geopandas plot commands\n    chainage_markers(xykm, ax, ndec=0, scale=scale)\n    p = plot_mesh_patches(ax, fn, nnodes, xn, yn, h, 0, hmax, scale=scale)\n    for b, bankarea in enumerate(bankareas):\n        geopandas.GeoSeries(bankarea, crs=config_file.crs).plot(\n            ax=ax, alpha=0.2, color=\"k\"\n        )\n        geopandas.GeoSeries(bank[b], crs=config_file.crs).plot(ax=ax, color=\"r\")\n    cbar = fig.colorbar(p, ax=ax, shrink=0.5, drawedges=False, label=waterdepth_txt)\n    #\n    shaded = matplotlib.patches.Patch(color=\"k\", alpha=0.2)\n    bankln = matplotlib.lines.Line2D([], [], color=\"r\")\n    handles = [shaded, bankln]\n    labels = [bankarea_txt, bankline_txt]\n    #\n    set_bbox(ax, bbox, scale=scale)\n    ax.set_xlabel(xlabel_txt)\n    ax.set_ylabel(ylabel_txt)\n    ax.grid(True)\n    ax.set_title(title_txt)\n    ax.legend(handles, labels, loc=\"upper right\")\n    return fig, ax\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.plot_mesh","title":"<code>plot_mesh(ax: matplotlib.axes.Axes, xe: numpy.ndarray, ye: numpy.ndarray, scale: float = 1000) -&gt; None</code>","text":"<p>Add a mesh to a plot.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot_mesh--arguments","title":"Arguments","text":"<p>ax : matplotlib.axes.Axes     Axes object in which to add the mesh. xe : numpy.ndarray     M x 2 array of begin/end x-coordinates of mesh edges. ye : numpy.ndarray     M x 2 array of begin/end y-coordinates of mesh edges. scale : float     Indicates whether the axes are in m (1) or km (1000).</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def plot_mesh(\n    ax: matplotlib.axes.Axes, xe: numpy.ndarray, ye: numpy.ndarray, scale: float = 1000\n) -&gt; None:\n    \"\"\"\n    Add a mesh to a plot.\n\n    Arguments\n    ---------\n    ax : matplotlib.axes.Axes\n        Axes object in which to add the mesh.\n    xe : numpy.ndarray\n        M x 2 array of begin/end x-coordinates of mesh edges.\n    ye : numpy.ndarray\n        M x 2 array of begin/end y-coordinates of mesh edges.\n    scale : float\n        Indicates whether the axes are in m (1) or km (1000).\n    \"\"\"\n    xe1 = xe[:, (0, 1, 1)] / scale\n    xe1[:, 2] = numpy.nan\n    xev = xe1.reshape((xe1.size,))\n\n    ye1 = ye[:, (0, 1, 1)] / scale\n    ye1[:, 2] = numpy.nan\n    yev = ye1.reshape((ye1.size,))\n\n    # to avoid OverflowError: In draw_path: Exceeded cell block limit\n    # plot the data in chunks ...\n    for i in range(0, len(xev), 3000):\n        ax.plot(\n            xev[i : i + 3000], yev[i : i + 3000], color=(0.5, 0.5, 0.5), linewidth=0.25\n        )\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.plot_mesh_patches","title":"<code>plot_mesh_patches(ax: matplotlib.axes.Axes, fn: numpy.ndarray, nnodes: numpy.ndarray, xn: numpy.ndarray, yn: numpy.ndarray, val: numpy.ndarray, minval: Optional[float] = None, maxval: Optional[float] = None, scale: float = 1000) -&gt; matplotlib.collections.PolyCollection</code>","text":"<p>Add a collection of patches to the plot one for every face of the mesh.</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot_mesh_patches--arguments","title":"Arguments","text":"<p>ax : matplotlib.axes.Axes     Axes object in which to add the mesh. fn : numpy.ndarray     N x M array listing the nodes (max M) per face (total N) of the mesh. nnodes : numpy.ndarray     Number of nodes per face (max M). xn : numpy.ndarray     X-coordinates of the mesh nodes. yn : numpy.ndarray     Y-coordinates of the mesh nodes. val : numpy.ndarray     Array of length N containing the value per face. minval : Optional[float]     Lower limit for the color scale. maxval : Optional[float]     Upper limit for the color scale. scale : float     Indicates whether the axes are in m (1) or km (1000).</p>"},{"location":"api/plotting.html#dfastbe.plotting.plot_mesh_patches--returns","title":"Returns","text":"<p>p : matplotlib.collections.PolyCollection     Patches object.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def plot_mesh_patches(\n    ax: matplotlib.axes.Axes,\n    fn: numpy.ndarray,\n    nnodes: numpy.ndarray,\n    xn: numpy.ndarray,\n    yn: numpy.ndarray,\n    val: numpy.ndarray,\n    minval: Optional[float] = None,\n    maxval: Optional[float] = None,\n    scale: float = 1000,\n) -&gt; matplotlib.collections.PolyCollection:\n    \"\"\"\n    Add a collection of patches to the plot one for every face of the mesh.\n\n    Arguments\n    ---------\n    ax : matplotlib.axes.Axes\n        Axes object in which to add the mesh.\n    fn : numpy.ndarray\n        N x M array listing the nodes (max M) per face (total N) of the mesh.\n    nnodes : numpy.ndarray\n        Number of nodes per face (max M).\n    xn : numpy.ndarray\n        X-coordinates of the mesh nodes.\n    yn : numpy.ndarray\n        Y-coordinates of the mesh nodes.\n    val : numpy.ndarray\n        Array of length N containing the value per face.\n    minval : Optional[float]\n        Lower limit for the color scale.\n    maxval : Optional[float]\n        Upper limit for the color scale.\n    scale : float\n        Indicates whether the axes are in m (1) or km (1000).\n\n    Returns\n    -------\n    p : matplotlib.collections.PolyCollection\n        Patches object.\n    \"\"\"\n    tfn_list = []\n    tval_list = []\n    for n in range(3, max(nnodes) + 1):\n        mask = nnodes &gt;= n\n        fn_masked = fn[mask, :]\n        tfn_list.append(fn_masked[:, (0, n - 2, n - 1)])\n        tval_list.append(val[mask])\n    tfn = numpy.concatenate(tfn_list, axis=0)\n    tval = numpy.concatenate(tval_list, axis=0)\n    # cmap = matplotlib.pyplot.get_cmap('Spectral')\n    if minval is None:\n        minval = numpy.min(tval)\n    if maxval is None:\n        maxval = numpy.max(tval)\n    p = ax.tripcolor(\n        xn / scale,\n        yn / scale,\n        tfn,\n        facecolors=tval,\n        cmap=\"Spectral\",\n        vmin=minval,\n        vmax=maxval,\n    )\n    return p\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.savefig","title":"<code>savefig(fig: matplotlib.figure.Figure, filename: str) -&gt; None</code>","text":"<p>Save a single figure to file.</p>"},{"location":"api/plotting.html#dfastbe.plotting.savefig--arguments","title":"Arguments","text":"<p>fig : matplotlib.figure.Figure     Figure to a be saved. filename : str     Name of the file to be written.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def savefig(fig: matplotlib.figure.Figure, filename: str) -&gt; None:\n    \"\"\"\n    Save a single figure to file.\n\n    Arguments\n    ---------\n    fig : matplotlib.figure.Figure\n        Figure to a be saved.\n    filename : str\n        Name of the file to be written.\n    \"\"\"\n    print(\"saving figure {file}\".format(file=filename))\n    matplotlib.pyplot.show(block=False)\n    fig.savefig(filename, dpi=300)\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.set_bbox","title":"<code>set_bbox(ax: matplotlib.axes.Axes, bbox: Tuple[float, float, float, float], scale: float = 1000) -&gt; None</code>","text":"<p>Specify the bounding limits of an axes object.</p>"},{"location":"api/plotting.html#dfastbe.plotting.set_bbox--arguments","title":"Arguments","text":"<p>ax : matplotlib.axes.Axes     Axes object to be adjusted.  bbox : Tuple[float, float, float, float]     Tuple containing boundary limits (xmin, ymin, xmax, ymax); unit m. scale: float     Indicates whether the axes are in m (1) or km (1000).</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def set_bbox(\n    ax: matplotlib.axes.Axes,\n    bbox: Tuple[float, float, float, float],\n    scale: float = 1000,\n) -&gt; None:\n    \"\"\"\n    Specify the bounding limits of an axes object.\n\n    Arguments\n    ---------\n    ax : matplotlib.axes.Axes\n        Axes object to be adjusted. \n    bbox : Tuple[float, float, float, float]\n        Tuple containing boundary limits (xmin, ymin, xmax, ymax); unit m.\n    scale: float\n        Indicates whether the axes are in m (1) or km (1000).\n    \"\"\"\n    ax.set_xlim(xmin=bbox[0] / scale, xmax=bbox[2] / scale)\n    ax.set_ylim(ymin=bbox[1] / scale, ymax=bbox[3] / scale)\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.setsize","title":"<code>setsize(fig: matplotlib.figure.Figure) -&gt; None</code>","text":"<p>Set the size of a figure.</p> <p>Currently the size is hardcoded, but functionality may be extended in the future.</p>"},{"location":"api/plotting.html#dfastbe.plotting.setsize--arguments","title":"Arguments","text":"<p>fig : matplotlib.figure.Figure     Figure to a be saved.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def setsize(fig: matplotlib.figure.Figure) -&gt; None:\n    \"\"\"\n    Set the size of a figure.\n\n    Currently the size is hardcoded, but functionality may be extended in the\n    future.\n\n    Arguments\n    ---------\n    fig : matplotlib.figure.Figure\n        Figure to a be saved.\n    \"\"\"\n    fig.set_size_inches(11.75, 8.25)  # a4\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.zoom_x_and_save","title":"<code>zoom_x_and_save(fig: matplotlib.figure.Figure, ax: matplotlib.axes.Axes, figbase: str, plot_ext: str, xzoom: List[Tuple[float, float]]) -&gt; None</code>","text":"<p>Zoom in on subregions of the x-axis and save the figure.</p>"},{"location":"api/plotting.html#dfastbe.plotting.zoom_x_and_save--arguments","title":"Arguments","text":"<p>fig : matplotlib.figure.Figure     Figure to be processed. ax : matplotlib.axes.Axes     Axes to be processed. fig_base : str     Base name of the figure to be saved. plot_ext : str     File extension of the figure to be saved. xzoom : List[list[float,float]]     Values at which to split the x-axis.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def zoom_x_and_save(fig: matplotlib.figure.Figure, ax: matplotlib.axes.Axes, figbase: str, plot_ext: str, xzoom: List[Tuple[float,float]]) -&gt; None:\n    \"\"\"\n    Zoom in on subregions of the x-axis and save the figure.\n\n    Arguments\n    ---------\n    fig : matplotlib.figure.Figure\n        Figure to be processed.\n    ax : matplotlib.axes.Axes\n        Axes to be processed.\n    fig_base : str\n        Base name of the figure to be saved.\n    plot_ext : str\n        File extension of the figure to be saved.\n    xzoom : List[list[float,float]]\n        Values at which to split the x-axis.\n    \"\"\"\n    xmin, xmax = ax.get_xlim()\n    for ix in range(len(xzoom)):\n        ax.set_xlim(xmin=xzoom[ix][0], xmax=xzoom[ix][1])\n        figfile = (\n            figbase\n            + \".sub\"\n            + str(ix + 1)\n            + plot_ext\n        )\n        savefig(fig, figfile)\n    ax.set_xlim(xmin=xmin, xmax=xmax)\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.zoom_xy_and_save","title":"<code>zoom_xy_and_save(fig: matplotlib.figure.Figure, ax: matplotlib.axes.Axes, figbase: str, plot_ext: str, xyzoom: List[Tuple[float, float, float, float]], scale: float = 1000) -&gt; None</code>","text":"<p>Zoom in on subregions in x,y-space and save the figure.</p>"},{"location":"api/plotting.html#dfastbe.plotting.zoom_xy_and_save--arguments","title":"Arguments","text":"<p>fig : matplotlib.figure.Figure     Figure to be processed. ax : matplotlib.axes.Axes     Axes to be processed. fig_base : str     Base name of the figure to be saved. plot_ext : str     File extension of the figure to be saved. xyzoom : List[List[float, float, float, float]]     List of xmin, xmax, ymin, ymax values to zoom into. scale: float     Indicates whether the axes are in m (1) or km (1000).</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def zoom_xy_and_save(fig: matplotlib.figure.Figure, ax: matplotlib.axes.Axes, figbase: str, plot_ext: str, xyzoom: List[Tuple[float, float, float, float]], scale: float = 1000) -&gt; None:\n    \"\"\"\n    Zoom in on subregions in x,y-space and save the figure.\n\n    Arguments\n    ---------\n    fig : matplotlib.figure.Figure\n        Figure to be processed.\n    ax : matplotlib.axes.Axes\n        Axes to be processed.\n    fig_base : str\n        Base name of the figure to be saved.\n    plot_ext : str\n        File extension of the figure to be saved.\n    xyzoom : List[List[float, float, float, float]]\n        List of xmin, xmax, ymin, ymax values to zoom into.\n    scale: float\n        Indicates whether the axes are in m (1) or km (1000).\n    \"\"\"\n    xmin, xmax = ax.get_xlim()\n    ymin, ymax = ax.get_ylim()\n\n    dx_zoom = 0\n    xy_ratio = (ymax - ymin) / (xmax - xmin)\n    for ix in range(len(xyzoom)):\n        xmin0 = xyzoom[ix][0]\n        xmax0 = xyzoom[ix][1]\n        ymin0 = xyzoom[ix][2]\n        ymax0 = xyzoom[ix][3]\n        dx = xmax0 - xmin0\n        dy = ymax0 - ymin0\n        if dy &lt; xy_ratio * dx:\n            # x range limiting\n            dx_zoom = max(dx_zoom, dx)\n        else:\n            # y range limiting\n            dx_zoom = max(dx_zoom, dy / xy_ratio)\n    dy_zoom = dx_zoom * xy_ratio\n\n    for ix in range(len(xyzoom)):\n        x0 = (xyzoom[ix][0] + xyzoom[ix][1]) / 2\n        y0 = (xyzoom[ix][2] + xyzoom[ix][3]) / 2\n        ax.set_xlim(xmin=(x0 - dx_zoom/2) / scale, xmax=(x0 + dx_zoom/2) / scale)\n        ax.set_ylim(ymin=(y0 - dy_zoom/2) / scale, ymax=(y0 + dy_zoom/2) / scale)\n        figfile = (\n            figbase\n            + \".sub\"\n            + str(ix + 1)\n            + plot_ext\n        )\n        savefig(fig, figfile)\n\n    ax.set_xlim(xmin=xmin, xmax=xmax)\n    ax.set_ylim(ymin=ymin, ymax=ymax)\n</code></pre>"},{"location":"architecture-design/main-components.html","title":"D-FAST Bank Erosion Architecture and Design","text":""},{"location":"architecture-design/main-components.html#repository-structure","title":"repository structure","text":"<pre><code>D-FAST_Bank_Erosion/\n\u251c\u2500\u2500\u2500.github\n\u2502   \u251c\u2500\u2500\u2500ISSUE_TEMPLATE\n\u2502   \u2514\u2500\u2500\u2500workflows\n\u251c\u2500\u2500\u2500docs\n\u2502   \u251c\u2500\u2500\u2500end-user-docs\n\u2502   \u2502   \u251c\u2500\u2500\u2500chapters\n\u2502   \u2502   \u251c\u2500\u2500\u2500cover\n\u2502   \u2502   \u2514\u2500\u2500\u2500figures\n\u2502   \u2514\u2500\u2500\u2500mkdocs\n\u2502       \u251c\u2500\u2500\u2500api\n\u2502       \u251c\u2500\u2500\u2500gui\n\u2502       \u2514\u2500\u2500\u2500guides\n\u251c\u2500\u2500\u2500examples\n\u2502   \u2514\u2500\u2500\u2500data\n\u251c\u2500\u2500\u2500src\n\u2502   \u2514\u2500\u2500\u2500dfastbe\n\u2502       \u2502   add.png\n\u2502       \u2502   bank_erosion.py\n\u2502       \u2502   bank_lines.py\n\u2502       \u2502   cmd.py\n\u2502       \u2502   D-FASTBE.png\n\u2502       \u2502   edit.png\n\u2502       \u2502   gui.py\n\u2502       \u2502   io.py\n\u2502       \u2502   io.py~\n\u2502       \u2502   kernel.py\n\u2502       \u2502   messages.NL.ini\n\u2502       \u2502   messages.UK.ini\n\u2502       \u2502   open.png\n\u2502       \u2502   plotting.py\n\u2502       \u2502   remove.png\n\u2502       \u2502   src.pyproj\n\u2502       \u2502   support.py\n\u2502       \u2502   utils.py\n\u2502       \u2502   __init__.py\n\u2502       \u2514\u2500\u2500\u2500__main__.py\n\u251c\u2500\u2500\u2500tests\n\u251c\u2500\u2500\u2500tests-dist\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 license.md\n</code></pre>"},{"location":"architecture-design/main-components.html#workflow-and-how-modules-interact","title":"Workflow and how modules interact:","text":"<pre><code>flowchart TD\n    subgraph CLI\n        main[\"__main__.py\"]\n    end\n\n    subgraph GUI\n        gui[\"gui.py\"]\n    end\n\n    subgraph Core\n        cmd[\"cmd.py\"]\n        bank_erosion[\"bank_erosion.py\"]\n        bank_lines[\"bank_lines.py\"]\n        kernel[\"kernel.py\"]\n    end\n\n    subgraph Data\n        io[\"io.py\"]\n        support[\"support.py\"]\n        utils[\"utils.py\"]\n    end\n\n    subgraph Plotting\n        plotting[\"plotting.py\"]\n    end\n\n    main --&gt; cmd\n    cmd --&gt;|parses config| io\n    cmd --&gt;|calculate erosion| bank_erosion\n    cmd --&gt;|starts analysis/Detect banks| bank_lines\n    gui --&gt; cmd\n    gui --&gt; bank_erosion\n    gui --&gt; io\n    bank_erosion --&gt; kernel\n    bank_erosion --&gt; io\n    bank_erosion --&gt; support\n    bank_erosion --&gt; plotting\n    bank_erosion --&gt; utils\n\n    kernel --&gt; support\n    kernel --&gt; utils\n\n    bank_lines --&gt; support\n    bank_lines --&gt; utils\n    bank_lines --&gt; io\n    bank_lines --&gt; plotting\n    bank_lines --&gt; kernel\n    bank_lines --&gt; utils\n\n    plotting --&gt; io\n    plotting --&gt; support\n    plotting --&gt; utils\n</code></pre> <pre><code>graph TD\n    subgraph Presentation_Layer\n        GUI[gui.py]\n        CLI[cmd.py &amp; __main__.py]\n    end\n\n    subgraph Application_Layer\n        AppLogic[bank_erosion.py]\n    end\n\n    subgraph Domain_Logic_Layer\n        Kernel[kernel.py]\n        BankDetection[bank_lines.py]\n    end\n\n    subgraph Data_Access_Layer\n        IO[io.py]\n        Support[support.py]\n        Utils[utils.py]\n    end\n\n    subgraph Config_Layer\n        ConfigManager[\"ConfigFile / RiverData\"]\n    end\n\n    CLI --&gt; AppLogic\n    GUI --&gt; AppLogic\n\n    AppLogic --&gt; Kernel\n    AppLogic --&gt; BankDetection\n    AppLogic --&gt; IO\n    AppLogic --&gt; Utils\n    AppLogic --&gt; Support\n    AppLogic --&gt; ConfigManager\n\n    Kernel --&gt; Support\n    BankDetection --&gt; Support\n    BankDetection --&gt; Utils\n    IO --&gt; ConfigManager</code></pre>"},{"location":"gui/gui.html","title":"gui","text":""},{"location":"gui/gui.html#gui_1","title":"gui","text":""},{"location":"gui/gui.html#dfastbe.gui","title":"<code>dfastbe.gui</code>","text":"<p>Copyright (C) 2020 Stichting Deltares.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation version 2.1.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, see http://www.gnu.org/licenses/.</p> <p>contact: delft3d.support@deltares.nl Stichting Deltares P.O. Box 177 2600 MH Delft, The Netherlands</p> <p>All indications and logos of, and references to, \"Delft3D\" and \"Deltares\" are registered trademarks of Stichting Deltares, and remain the property of Stichting Deltares. All rights reserved.</p> <p>INFORMATION This file is part of D-FAST Bank Erosion: https://github.com/Deltares/D-FAST_Bank_Erosion</p>"},{"location":"gui/gui.html#dfastbe.gui.activate_dialog","title":"<code>activate_dialog() -&gt; None</code>","text":"<p>Activate the user interface and run the program.</p>"},{"location":"gui/gui.html#dfastbe.gui.activate_dialog--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def activate_dialog() -&gt; None:\n    \"\"\"\n    Activate the user interface and run the program.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    app = dialog[\"application\"]\n    win = dialog[\"window\"]\n    win.show()\n    sys.exit(app.exec_())\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.addAnItem","title":"<code>addAnItem(key: str) -&gt; None</code>","text":"<p>Implements the actions for the add item button.</p>"},{"location":"gui/gui.html#dfastbe.gui.addAnItem--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def addAnItem(key: str) -&gt; None:\n    \"\"\"\n    Implements the actions for the add item button.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    \"\"\"\n    nItems = dialog[key].invisibleRootItem().childCount()\n    i = nItems + 1\n    istr = str(i)\n    if key == \"searchLines\":\n        fileName, dist = editASearchLine(key, istr)\n        c1 = QtWidgets.QTreeWidgetItem(dialog[\"searchLines\"], [istr, fileName, dist])\n    elif key == \"discharges\":\n        prob = str(1 / (nItems + 1))\n        fileName, prob = editADischarge(key, istr, prob=prob)\n        c1 = QtWidgets.QTreeWidgetItem(dialog[\"discharges\"], [istr, fileName, prob])\n        addTabForLevel(istr)\n        dialog[\"refLevel\"].validator().setTop(i)\n    dialog[key + \"Edit\"].setEnabled(True)\n    dialog[key + \"Remove\"].setEnabled(True)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.addBankTab","title":"<code>addBankTab(tabs: PyQt5.QtWidgets.QTabWidget, win: PyQt5.QtWidgets.QMainWindow) -&gt; None</code>","text":"<p>Create the tab for the general bank properties.</p>"},{"location":"gui/gui.html#dfastbe.gui.addBankTab--arguments","title":"Arguments","text":"<p>tabs : PyQt5.QtWidgets.QTabWidget     Tabs object to which the tab should be added. win : PyQt5.QtWidgets.QMainWindow     The window object in which the tab item is located.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def addBankTab(\n    tabs: PyQt5.QtWidgets.QTabWidget, win: PyQt5.QtWidgets.QMainWindow\n) -&gt; None:\n    \"\"\"\n    Create the tab for the general bank properties.\n\n    Arguments\n    ---------\n    tabs : PyQt5.QtWidgets.QTabWidget\n        Tabs object to which the tab should be added.\n    win : PyQt5.QtWidgets.QMainWindow\n        The window object in which the tab item is located.\n    \"\"\"\n    eParamsWidget = QtWidgets.QWidget()\n    eParamsLayout = QtWidgets.QGridLayout(eParamsWidget)\n    tabs.addTab(eParamsWidget, \"Bank Parameters\")\n\n    strength = QtWidgets.QLabel(\"Strength Parameter\")\n    eParamsLayout.addWidget(strength, 0, 0)\n    strengthPar = QtWidgets.QComboBox()\n    strengthPar.addItems((\"Bank Type\", \"Critical Shear Stress\"))\n    strengthPar.currentIndexChanged.connect(bankStrengthSwitch)\n    dialog[\"strengthPar\"] = strengthPar\n    eParamsLayout.addWidget(strengthPar, 0, 1, 1, 2)\n\n    generalParLayout(\n        eParamsLayout,\n        1,\n        \"bankType\",\n        \"Bank Type\",\n        selectList=[\n            \"0 (Beschermde oeverlijn)\",\n            \"1 (Begroeide oeverlijn)\",\n            \"2 (Goede klei)\",\n            \"3 (Matig / slechte klei)\",\n            \"4 (Zand)\",\n        ],\n    )\n    generalParLayout(eParamsLayout, 3, \"bankShear\", \"Critical Shear Stress [N/m2]\")\n    bankStrengthSwitch()\n    generalParLayout(eParamsLayout, 4, \"bankProtect\", \"Protection [m]\")\n    generalParLayout(eParamsLayout, 5, \"bankSlope\", \"Slope [-]\")\n    generalParLayout(eParamsLayout, 6, \"bankReed\", \"Reed [-]\")\n\n    addFilter(eParamsLayout, 7, \"velFilter\", \"Velocity Filter [km]\")\n    addFilter(eParamsLayout, 8, \"bedFilter\", \"Bank Elevation Filter [km]\")\n\n    stretch = QtWidgets.QSpacerItem(10, 10, 13, 7)\n    eParamsLayout.addItem(stretch, 9, 0)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.addCheckBox","title":"<code>addCheckBox(formLayout: PyQt5.QtWidgets.QFormLayout, key: str, labelString: str, isChecked: bool = False) -&gt; None</code>","text":"<p>Add a line of with checkbox control to a form layout.</p>"},{"location":"gui/gui.html#dfastbe.gui.addCheckBox--arguments","title":"Arguments","text":"<p>formLayout : PyQt5.QtWidgets.QFormLayout     Form layout object in which to position the edit controls. key : str     Short name of the parameter. labelString : str     String describing the parameter to be displayed as label. isChecked : bool     Initial state of the check box.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def addCheckBox(\n    formLayout: PyQt5.QtWidgets.QFormLayout,\n    key: str,\n    labelString: str,\n    isChecked: bool = False,\n) -&gt; None:\n    \"\"\"\n    Add a line of with checkbox control to a form layout.\n\n    Arguments\n    ---------\n    formLayout : PyQt5.QtWidgets.QFormLayout\n        Form layout object in which to position the edit controls.\n    key : str\n        Short name of the parameter.\n    labelString : str\n        String describing the parameter to be displayed as label.\n    isChecked : bool\n        Initial state of the check box.\n    \"\"\"\n    checkBox = QtWidgets.QCheckBox(\"\")\n    checkBox.setChecked(isChecked)\n    dialog[key + \"Edit\"] = checkBox\n\n    checkTxt = QtWidgets.QLabel(labelString)\n    dialog[key] = checkTxt\n    formLayout.addRow(checkTxt, checkBox)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.addDetectTab","title":"<code>addDetectTab(tabs: PyQt5.QtWidgets.QTabWidget, win: PyQt5.QtWidgets.QMainWindow, app: PyQt5.QtWidgets.QApplication) -&gt; None</code>","text":"<p>Create the tab for the bank line detection settings.</p>"},{"location":"gui/gui.html#dfastbe.gui.addDetectTab--arguments","title":"Arguments","text":"<p>tabs : PyQt5.QtWidgets.QTabWidget     Tabs object to which the tab should be added. win : PyQt5.QtWidgets.QMainWindow     The window object in which the tab item is located. app : PyQt5.QtWidgets.QApplication     The application object to which the window belongs, needed for font information.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def addDetectTab(\n    tabs: PyQt5.QtWidgets.QTabWidget,\n    win: PyQt5.QtWidgets.QMainWindow,\n    app: PyQt5.QtWidgets.QApplication,\n) -&gt; None:\n    \"\"\"\n    Create the tab for the bank line detection settings.\n\n    Arguments\n    ---------\n    tabs : PyQt5.QtWidgets.QTabWidget\n        Tabs object to which the tab should be added.\n    win : PyQt5.QtWidgets.QMainWindow\n        The window object in which the tab item is located.\n    app : PyQt5.QtWidgets.QApplication\n        The application object to which the window belongs, needed for font information.\n    \"\"\"\n    detectWidget = QtWidgets.QWidget()\n    detectLayout = QtWidgets.QFormLayout(detectWidget)\n    tabs.addTab(detectWidget, \"Detection\")\n\n    addOpenFileRow(detectLayout, \"simFile\", \"Simulation File\")\n\n    waterDepth = QtWidgets.QLineEdit(win)\n    waterDepth.setValidator(validator(\"positive_real\"))\n    dialog[\"waterDepth\"] = waterDepth\n    detectLayout.addRow(\"Water Depth [m]\", waterDepth)\n\n    searchLines = QtWidgets.QTreeWidget(win)\n    searchLines.setHeaderLabels([\"Index\", \"FileName\", \"Search Distance [m]\"])\n    searchLines.setFont(app.font())\n    searchLines.setColumnWidth(0, 50)\n    searchLines.setColumnWidth(1, 200)\n    # c1 = QtWidgets.QTreeWidgetItem(searchLines, [\"0\", \"test\\\\filename\", \"50\"])\n\n    slLayout = addRemoveEditLayout(searchLines, \"searchLines\")\n    detectLayout.addRow(\"Search Lines\", slLayout)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.addErosionTab","title":"<code>addErosionTab(tabs: PyQt5.QtWidgets.QTabWidget, win: PyQt5.QtWidgets.QMainWindow, app: PyQt5.QtWidgets.QApplication) -&gt; None</code>","text":"<p>Create the tab for the main bank erosion settings.</p>"},{"location":"gui/gui.html#dfastbe.gui.addErosionTab--arguments","title":"Arguments","text":"<p>tabs : PyQt5.QtWidgets.QTabWidget     Tabs object to which the tab should be added. win : PyQt5.QtWidgets.QMainWindow     The window object in which the tab item is located. app : PyQt5.QtWidgets.QApplication     The application object to which the window belongs, needed for font information.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def addErosionTab(\n    tabs: PyQt5.QtWidgets.QTabWidget,\n    win: PyQt5.QtWidgets.QMainWindow,\n    app: PyQt5.QtWidgets.QApplication,\n) -&gt; None:\n    \"\"\"\n    Create the tab for the main bank erosion settings.\n\n    Arguments\n    ---------\n    tabs : PyQt5.QtWidgets.QTabWidget\n        Tabs object to which the tab should be added.\n    win : PyQt5.QtWidgets.QMainWindow\n        The window object in which the tab item is located.\n    app : PyQt5.QtWidgets.QApplication\n        The application object to which the window belongs, needed for font information.\n    \"\"\"\n    erosionWidget = QtWidgets.QWidget()\n    erosionLayout = QtWidgets.QFormLayout(erosionWidget)\n    tabs.addTab(erosionWidget, \"Erosion\")\n\n    tErosion = QtWidgets.QLineEdit(win)\n    tErosion.setValidator(validator(\"positive_real\"))\n    dialog[\"tErosion\"] = tErosion\n    erosionLayout.addRow(\"Simulation Time [yr]\", tErosion)\n\n    addOpenFileRow(erosionLayout, \"riverAxis\", \"River Axis File\")\n\n    addOpenFileRow(erosionLayout, \"fairway\", \"Fairway File\")\n\n    discharges = QtWidgets.QTreeWidget(win)\n    discharges.setHeaderLabels([\"Level\", \"FileName\", \"Probability [-]\"])\n    discharges.setFont(app.font())\n    discharges.setColumnWidth(0, 50)\n    discharges.setColumnWidth(1, 250)\n    # c1 = QtWidgets.QTreeWidgetItem(discharges, [\"0\", \"test\\\\filename\", \"0.5\"])\n\n    disLayout = addRemoveEditLayout(discharges, \"discharges\")\n    erosionLayout.addRow(\"Discharges\", disLayout)\n\n    refLevel = QtWidgets.QLineEdit(win)\n    refLevel.setValidator(PyQt5.QtGui.QIntValidator(1, 1))\n    dialog[\"refLevel\"] = refLevel\n    erosionLayout.addRow(\"Reference Case\", refLevel)\n\n    chainageOutStep = QtWidgets.QLineEdit(win)\n    chainageOutStep.setValidator(validator(\"positive_real\"))\n    dialog[\"chainageOutStep\"] = chainageOutStep\n    erosionLayout.addRow(\"Chainage Output Step [km]\", chainageOutStep)\n\n    addOpenFileRow(erosionLayout, \"outDir\", \"Output Directory\")\n\n    newBankFile = QtWidgets.QLineEdit(win)\n    dialog[\"newBankFile\"] = newBankFile\n    erosionLayout.addRow(\"New Bank File Name\", newBankFile)\n\n    newEqBankFile = QtWidgets.QLineEdit(win)\n    dialog[\"newEqBankFile\"] = newEqBankFile\n    erosionLayout.addRow(\"New Eq Bank File Name\", newEqBankFile)\n\n    eroVol = QtWidgets.QLineEdit(win)\n    dialog[\"eroVol\"] = eroVol\n    erosionLayout.addRow(\"EroVol File Name\", eroVol)\n\n    eroVolEqui = QtWidgets.QLineEdit(win)\n    dialog[\"eroVolEqui\"] = eroVolEqui\n    erosionLayout.addRow(\"EroVolEqui File Name\", eroVolEqui)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.addFilter","title":"<code>addFilter(gridLayout: PyQt5.QtWidgets.QGridLayout, row: int, key: str, labelString: str) -&gt; None</code>","text":"<p>Add a line of controls for a filter</p>"},{"location":"gui/gui.html#dfastbe.gui.addFilter--arguments","title":"Arguments","text":"<p>gridLayout : PyQt5.QtWidgets.QGridLayout     Grid layout object in which to position the edit controls. row : int     Grid row number to be used for this parameter. key : str     Short name of the parameter. labelString : str     String describing the parameter to be displayed as label.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def addFilter(\n    gridLayout: PyQt5.QtWidgets.QGridLayout, row: int, key: str, labelString: str\n) -&gt; None:\n    \"\"\"\n    Add a line of controls for a filter\n\n    Arguments\n    ---------\n    gridLayout : PyQt5.QtWidgets.QGridLayout\n        Grid layout object in which to position the edit controls.\n    row : int\n        Grid row number to be used for this parameter.\n    key : str\n        Short name of the parameter.\n    labelString : str\n        String describing the parameter to be displayed as label.\n    \"\"\"\n\n    widthEdit = QtWidgets.QLineEdit(\"0.3\")\n    widthEdit.setValidator(validator(\"positive_real\"))\n    gridLayout.addWidget(widthEdit, row, 2)\n    dialog[key + \"Width\"] = widthEdit\n\n    useFilter = QtWidgets.QCheckBox(\"\")\n    useFilter.setChecked(False)\n    useFilter.stateChanged.connect(partial(updateFilter, key))\n    gridLayout.addWidget(useFilter, row, 1)\n    dialog[key + \"Active\"] = useFilter\n\n    filterTxt = QtWidgets.QLabel(labelString)\n    gridLayout.addWidget(filterTxt, row, 0)\n    dialog[key + \"Txt\"] = filterTxt\n\n    updateFilter(key)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.addGeneralTab","title":"<code>addGeneralTab(tabs: PyQt5.QtWidgets.QTabWidget, win: PyQt5.QtWidgets.QMainWindow) -&gt; None</code>","text":"<p>Create the tab for the general settings.</p> <p>These settings are used by both the bank line detection and the bank erosion analysis.</p>"},{"location":"gui/gui.html#dfastbe.gui.addGeneralTab--arguments","title":"Arguments","text":"<p>tabs : PyQt5.QtWidgets.QTabWidget     Tabs object to which the tab should be added. win : PyQt5.QtWidgets.QMainWindow     Windows in which the tab item is located.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def addGeneralTab(\n    tabs: PyQt5.QtWidgets.QTabWidget, win: PyQt5.QtWidgets.QMainWindow\n) -&gt; None:\n    \"\"\"\n    Create the tab for the general settings.\n\n    These settings are used by both the bank line detection and the bank\n    erosion analysis.\n\n    Arguments\n    ---------\n    tabs : PyQt5.QtWidgets.QTabWidget\n        Tabs object to which the tab should be added.\n    win : PyQt5.QtWidgets.QMainWindow\n        Windows in which the tab item is located.\n    \"\"\"\n    generalWidget = QtWidgets.QWidget()\n    generalLayout = QtWidgets.QFormLayout(generalWidget)\n    tabs.addTab(generalWidget, \"General\")\n\n    addOpenFileRow(generalLayout, \"chainFile\", \"Chain File\")\n\n    chainRange = QtWidgets.QWidget()\n    gridly = QtWidgets.QGridLayout(chainRange)\n    gridly.setContentsMargins(0, 0, 0, 0)\n\n    gridly.addWidget(QtWidgets.QLabel(\"From [km]\", win), 0, 0)\n    startRange = QtWidgets.QLineEdit(win)\n    dialog[\"startRange\"] = startRange\n    gridly.addWidget(startRange, 0, 1)\n    gridly.addWidget(QtWidgets.QLabel(\"To [km]\", win), 0, 2)\n    endRange = QtWidgets.QLineEdit(win)\n    dialog[\"endRange\"] = endRange\n    gridly.addWidget(endRange, 0, 3)\n\n    generalLayout.addRow(\"Study Range\", chainRange)\n\n    addOpenFileRow(generalLayout, \"bankDir\", \"Bank Directory\")\n\n    bankFileName = QtWidgets.QLineEdit(win)\n    dialog[\"bankFileName\"] = bankFileName\n    generalLayout.addRow(\"Bank File Name\", bankFileName)\n\n    addCheckBox(generalLayout, \"makePlots\", \"Create Figures\", True)\n    dialog[\"makePlotsEdit\"].stateChanged.connect(updatePlotting)\n\n    addCheckBox(generalLayout, \"savePlots\", \"Save Figures\", True)\n    dialog[\"savePlotsEdit\"].stateChanged.connect(updatePlotting)\n\n    zoomPlots = QtWidgets.QWidget()\n    gridly = QtWidgets.QGridLayout(zoomPlots)\n    gridly.setContentsMargins(0, 0, 0, 0)\n\n    saveZoomPlotsEdit = QtWidgets.QCheckBox(\"\", win)\n    saveZoomPlotsEdit.stateChanged.connect(updatePlotting)\n    saveZoomPlotsEdit.setChecked(False)\n    gridly.addWidget(saveZoomPlotsEdit, 0, 0)\n    dialog[\"saveZoomPlotsEdit\"] = saveZoomPlotsEdit\n\n    zoomPlotsRangeTxt = QtWidgets.QLabel(\"Zoom Range [km]\", win)\n    zoomPlotsRangeTxt.setEnabled(False)\n    gridly.addWidget(zoomPlotsRangeTxt, 0, 1)\n    dialog[\"zoomPlotsRangeTxt\"] = zoomPlotsRangeTxt\n\n    zoomPlotsRangeEdit = QtWidgets.QLineEdit(\"1.0\",win)\n    zoomPlotsRangeEdit.setValidator(validator(\"positive_real\"))\n    zoomPlotsRangeEdit.setEnabled(False)\n    gridly.addWidget(zoomPlotsRangeEdit, 0, 2)\n    dialog[\"zoomPlotsRangeEdit\"] = zoomPlotsRangeEdit\n\n    saveZoomPlots = QtWidgets.QLabel(\"Save Zoomed Figures\", win)\n    generalLayout.addRow(saveZoomPlots, zoomPlots)\n    dialog[\"saveZoomPlots\"] = saveZoomPlots\n\n    addOpenFileRow(generalLayout, \"figureDir\", \"Figure Directory\")\n    addCheckBox(generalLayout, \"closePlots\", \"Close Figures\")\n    addCheckBox(generalLayout, \"debugOutput\", \"Debug Output\")\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.addOpenFileRow","title":"<code>addOpenFileRow(formLayout: PyQt5.QtWidgets.QFormLayout, key: str, labelString: str) -&gt; None</code>","text":"<p>Add a line of controls for selecting a file or folder in a form layout.</p>"},{"location":"gui/gui.html#dfastbe.gui.addOpenFileRow--arguments","title":"Arguments","text":"<p>formLayout : PyQt5.QtWidgets.QFormLayout     Form layout object in which to position the edit controls. key : str     Short name of the parameter. labelString : str     String describing the parameter to be displayed as label.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def addOpenFileRow(\n    formLayout: PyQt5.QtWidgets.QFormLayout, key: str, labelString: str\n) -&gt; None:\n    \"\"\"\n    Add a line of controls for selecting a file or folder in a form layout.\n\n    Arguments\n    ---------\n    formLayout : PyQt5.QtWidgets.QFormLayout\n        Form layout object in which to position the edit controls.\n    key : str\n        Short name of the parameter.\n    labelString : str\n        String describing the parameter to be displayed as label.\n    \"\"\"\n    Label = QtWidgets.QLabel(labelString)\n    dialog[key] = Label\n    fLayout = openFileLayout(key + \"Edit\")\n    formLayout.addRow(Label, fLayout)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.addRemoveEditLayout","title":"<code>addRemoveEditLayout(mainWidget: PyQt5.QtWidgets.QWidget, key: str) -&gt; PyQt5.QtWidgets.QWidget</code>","text":"<p>Create a standard layout with list control and add, edit and remove buttons.</p>"},{"location":"gui/gui.html#dfastbe.gui.addRemoveEditLayout--arguments","title":"Arguments","text":"<p>mainWidget : PyQt5.QtWidgets.QWidget     Main object on which the add, edit and remove buttons should operate. key : str     Short name of the parameter.</p>"},{"location":"gui/gui.html#dfastbe.gui.addRemoveEditLayout--returns","title":"Returns","text":"<p>parent : PyQt5.QtWidgets.QWidget     Parent QtWidget that contains the add, edit and remove buttons.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def addRemoveEditLayout(\n    mainWidget: PyQt5.QtWidgets.QWidget, key: str\n) -&gt; PyQt5.QtWidgets.QWidget:\n    \"\"\"\n    Create a standard layout with list control and add, edit and remove buttons.\n\n    Arguments\n    ---------\n    mainWidget : PyQt5.QtWidgets.QWidget\n        Main object on which the add, edit and remove buttons should operate.\n    key : str\n        Short name of the parameter.\n\n    Returns\n    -------\n    parent : PyQt5.QtWidgets.QWidget\n        Parent QtWidget that contains the add, edit and remove buttons.\n    \"\"\"\n    parent = QtWidgets.QWidget()\n    gridly = QtWidgets.QGridLayout(parent)\n    gridly.setContentsMargins(0, 0, 0, 0)\n\n    dialog[key] = mainWidget\n    gridly.addWidget(mainWidget, 0, 0)\n\n    buttonBar = QtWidgets.QWidget()\n    buttonBarLayout = QtWidgets.QBoxLayout(QtWidgets.QBoxLayout.TopToBottom, buttonBar)\n    buttonBarLayout.setContentsMargins(0, 0, 0, 0)\n    gridly.addWidget(buttonBar, 0, 1)\n\n    addBtn = QtWidgets.QPushButton(getIcon(\"add.png\"), \"\")\n    addBtn.clicked.connect(partial(addAnItem, key))\n    dialog[key + \"Add\"] = addBtn\n    buttonBarLayout.addWidget(addBtn)\n\n    editBtn = QtWidgets.QPushButton(getIcon(\"edit.png\"), \"\")\n    editBtn.clicked.connect(partial(editAnItem, key))\n    editBtn.setEnabled(False)\n    dialog[key + \"Edit\"] = editBtn\n    buttonBarLayout.addWidget(editBtn)\n\n    delBtn = QtWidgets.QPushButton(getIcon(\"remove.png\"), \"\")\n    delBtn.clicked.connect(partial(removeAnItem, key))\n    delBtn.setEnabled(False)\n    dialog[key + \"Remove\"] = delBtn\n    buttonBarLayout.addWidget(delBtn)\n\n    stretch = QtWidgets.QSpacerItem(10, 10, 13, 7)\n    buttonBarLayout.addItem(stretch)\n\n    return parent\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.addShippingTab","title":"<code>addShippingTab(tabs: PyQt5.QtWidgets.QTabWidget, win: PyQt5.QtWidgets.QMainWindow) -&gt; None</code>","text":"<p>Create the tab for the general shipping settings.</p>"},{"location":"gui/gui.html#dfastbe.gui.addShippingTab--arguments","title":"Arguments","text":"<p>tabs : PyQt5.QtWidgets.QTabWidget     Tabs object to which the tab should be added. win : PyQt5.QtWidgets.QMainWindow     The window object in which the tab item is located.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def addShippingTab(\n    tabs: PyQt5.QtWidgets.QTabWidget, win: PyQt5.QtWidgets.QMainWindow\n) -&gt; None:\n    \"\"\"\n    Create the tab for the general shipping settings.\n\n    Arguments\n    ---------\n    tabs : PyQt5.QtWidgets.QTabWidget\n        Tabs object to which the tab should be added.\n    win : PyQt5.QtWidgets.QMainWindow\n        The window object in which the tab item is located.\n    \"\"\"\n    eParamsWidget = QtWidgets.QWidget()\n    eParamsLayout = QtWidgets.QGridLayout(eParamsWidget)\n    tabs.addTab(eParamsWidget, \"Shipping Parameters\")\n\n    generalParLayout(eParamsLayout, 0, \"shipType\", \"Ship Type\", selectList=shipTypes())\n    generalParLayout(eParamsLayout, 2, \"shipVeloc\", \"Velocity [m/s]\")\n    generalParLayout(eParamsLayout, 3, \"nShips\", \"# Ships [1/yr]\")\n    generalParLayout(eParamsLayout, 4, \"shipNWaves\", \"# Waves [1/ship]\")\n    generalParLayout(eParamsLayout, 5, \"shipDraught\", \"Draught [m]\")\n    generalParLayout(eParamsLayout, 6, \"wavePar0\", \"Wave0 [m]\")\n    generalParLayout(eParamsLayout, 7, \"wavePar1\", \"Wave1 [m]\")\n\n    stretch = QtWidgets.QSpacerItem(10, 10, 13, 7)\n    eParamsLayout.addItem(stretch, 8, 0)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.addTabForLevel","title":"<code>addTabForLevel(istr: str) -&gt; None</code>","text":"<p>Create the tab for the settings associated with simulation i.</p>"},{"location":"gui/gui.html#dfastbe.gui.addTabForLevel--arguments","title":"Arguments","text":"<p>istr : str     String representation of the simulation number.</p>"},{"location":"gui/gui.html#dfastbe.gui.addTabForLevel--arguments_1","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def addTabForLevel(istr: str) -&gt; None:\n    \"\"\"\n    Create the tab for the settings associated with simulation i.\n\n    Arguments\n    ---------\n    istr : str\n        String representation of the simulation number.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    newWidget = QtWidgets.QWidget()\n    newLayout = QtWidgets.QGridLayout(newWidget)\n    dialog[\"tabs\"].addTab(newWidget, \"Level \" + istr)\n\n    optionalParLayout(\n        newLayout, 0, istr + \"_shipType\", \"Ship Type\", selectList=shipTypes()\n    )\n    optionalParLayout(newLayout, 2, istr + \"_shipVeloc\", \"Velocity [m/s]\")\n    optionalParLayout(newLayout, 3, istr + \"_nShips\", \"# Ships [1/yr]\")\n    optionalParLayout(newLayout, 4, istr + \"_shipNWaves\", \"# Waves [1/ship]\")\n    optionalParLayout(newLayout, 5, istr + \"_shipDraught\", \"Draught [m]\")\n    optionalParLayout(newLayout, 6, istr + \"_bankSlope\", \"Slope [-]\")\n    optionalParLayout(newLayout, 7, istr + \"_bankReed\", \"Reed [-]\")\n\n    Label = QtWidgets.QLabel(\"EroVol File Name\")\n    dialog[istr + \"_eroVol\"] = Label\n    newLayout.addWidget(Label, 8, 0)\n    Edit = QtWidgets.QLineEdit()\n    dialog[istr + \"_eroVolEdit\"] = Edit\n    newLayout.addWidget(Edit, 8, 2)\n\n    stretch = QtWidgets.QSpacerItem(10, 10, 13, 7)\n    newLayout.addItem(stretch, 9, 0)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.bankStrengthSwitch","title":"<code>bankStrengthSwitch() -&gt; None</code>","text":"<p>Implements the dialog settings depending on the bank strength specification method.</p>"},{"location":"gui/gui.html#dfastbe.gui.bankStrengthSwitch--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def bankStrengthSwitch() -&gt; None:\n    \"\"\"\n    Implements the dialog settings depending on the bank strength specification method.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    type = dialog[\"strengthPar\"].currentText()\n    if type == \"Bank Type\":\n        dialog[\"bankType\"].setEnabled(True)\n        dialog[\"bankTypeType\"].setEnabled(True)\n        typeUpdatePar(\"bankType\")\n        dialog[\"bankShear\"].setEnabled(False)\n        dialog[\"bankShearType\"].setEnabled(False)\n        dialog[\"bankShearEdit\"].setText(\"\")\n        dialog[\"bankShearEdit\"].setEnabled(False)\n        dialog[\"bankShearEditFile\"].setEnabled(False)\n    elif type == \"Critical Shear Stress\":\n        dialog[\"bankShear\"].setEnabled(True)\n        dialog[\"bankShearType\"].setEnabled(True)\n        dialog[\"bankShearEdit\"].setEnabled(True)\n        typeUpdatePar(\"bankShear\")\n        dialog[\"bankType\"].setEnabled(False)\n        dialog[\"bankTypeType\"].setEnabled(False)\n        dialog[\"bankTypeSelect\"].setEnabled(False)\n        dialog[\"bankTypeEdit\"].setText(\"\")\n        dialog[\"bankTypeEdit\"].setEnabled(False)\n        dialog[\"bankTypeEditFile\"].setEnabled(False)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.close_dialog","title":"<code>close_dialog() -&gt; None</code>","text":"<p>Close the dialog and program.</p>"},{"location":"gui/gui.html#dfastbe.gui.close_dialog--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def close_dialog() -&gt; None:\n    \"\"\"\n    Close the dialog and program.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    matplotlib.pyplot.close(\"all\")\n    dialog[\"window\"].close()\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.close_edit","title":"<code>close_edit(hDialog: PyQt5.QtWidgets.QDialog) -&gt; None</code>","text":"<p>Generic close function for edit dialogs.</p>"},{"location":"gui/gui.html#dfastbe.gui.close_edit--arguments","title":"Arguments","text":"<p>hDialog : PyQt5.QtWidgets.QDialog     Dialog object to be closed.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def close_edit(hDialog: PyQt5.QtWidgets.QDialog) -&gt; None:\n    \"\"\"\n    Generic close function for edit dialogs.\n\n    Arguments\n    ---------\n    hDialog : PyQt5.QtWidgets.QDialog\n        Dialog object to be closed.\n    \"\"\"\n    hDialog.close()\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.createMenus","title":"<code>createMenus(menubar: PyQt5.QtWidgets.QMenuBar) -&gt; None</code>","text":"<p>Add the menus to the menubar.</p>"},{"location":"gui/gui.html#dfastbe.gui.createMenus--arguments","title":"Arguments","text":"<p>menubar : PyQt5.QtWidgets.QMenuBar     Menubar to which menus should be added.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def createMenus(menubar: PyQt5.QtWidgets.QMenuBar) -&gt; None:\n    \"\"\"\n    Add the menus to the menubar.\n\n    Arguments\n    ---------\n    menubar : PyQt5.QtWidgets.QMenuBar\n        Menubar to which menus should be added.\n    \"\"\"\n    menu = menubar.addMenu(gui_text(\"File\"))\n    item = menu.addAction(gui_text(\"Load\"))\n    item.triggered.connect(menu_load_configuration)\n    item = menu.addAction(gui_text(\"Save\"))\n    item.triggered.connect(menu_save_configuration)\n    menu.addSeparator()\n    item = menu.addAction(gui_text(\"Close\"))\n    item.triggered.connect(close_dialog)\n\n    menu = menubar.addMenu(gui_text(\"Help\"))\n    item = menu.addAction(gui_text(\"Manual\"))\n    item.triggered.connect(menu_open_manual)\n    menu.addSeparator()\n    item = menu.addAction(gui_text(\"Version\"))\n    item.triggered.connect(menu_about_self)\n    item = menu.addAction(gui_text(\"AboutQt\"))\n    item.triggered.connect(menu_about_qt)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.create_dialog","title":"<code>create_dialog() -&gt; None</code>","text":"<p>Construct the D-FAST Bank Erosion user interface.</p>"},{"location":"gui/gui.html#dfastbe.gui.create_dialog--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def create_dialog() -&gt; None:\n    \"\"\"\n    Construct the D-FAST Bank Erosion user interface.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    global dialog\n    dialog = {}\n\n    app = QtWidgets.QApplication(sys.argv)\n    app.setStyle(\"fusion\")\n    dialog[\"application\"] = app\n\n    win = QtWidgets.QMainWindow()\n    win.setGeometry(200, 200, 600, 300)\n    win.setWindowTitle(\"D-FAST Bank Erosion\")\n    dialog[\"window\"] = win\n\n    menubar = win.menuBar()\n    createMenus(menubar)\n\n    centralWidget = QtWidgets.QWidget()\n    layout = QtWidgets.QBoxLayout(2, centralWidget)\n    win.setCentralWidget(centralWidget)\n\n    tabs = QtWidgets.QTabWidget(win)\n    dialog[\"tabs\"] = tabs\n    layout.addWidget(tabs)\n\n    buttonBar = QtWidgets.QWidget(win)\n    buttonBarLayout = QtWidgets.QBoxLayout(QtWidgets.QBoxLayout.LeftToRight, buttonBar)\n    buttonBarLayout.setContentsMargins(0, 0, 0, 0)\n    layout.addWidget(buttonBar)\n\n    detect = QtWidgets.QPushButton(gui_text(\"action_detect\"), win)\n    detect.clicked.connect(run_detection)\n    buttonBarLayout.addWidget(detect)\n\n    erode = QtWidgets.QPushButton(gui_text(\"action_erode\"), win)\n    erode.clicked.connect(run_erosion)\n    buttonBarLayout.addWidget(erode)\n\n    done = QtWidgets.QPushButton(gui_text(\"action_close\"), win)\n    done.clicked.connect(close_dialog)\n    buttonBarLayout.addWidget(done)\n\n    addGeneralTab(tabs, win)\n    addDetectTab(tabs, win, app)\n    addErosionTab(tabs, win, app)\n    addShippingTab(tabs, win)\n    addBankTab(tabs, win)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.editADischarge","title":"<code>editADischarge(key: str, istr: str, fileName: str = '', prob: str = '')</code>","text":"<p>Create an edit dialog for simulation file and weighing.</p>"},{"location":"gui/gui.html#dfastbe.gui.editADischarge--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter. istr : str     String representation of the simulation in the list. fileName : str     Name of the simulation file. prob : str     String representation of the weight for this simulation.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def editADischarge(key: str, istr: str, fileName: str = \"\", prob: str = \"\"):\n    \"\"\"\n    Create an edit dialog for simulation file and weighing.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    istr : str\n        String representation of the simulation in the list.\n    fileName : str\n        Name of the simulation file.\n    prob : str\n        String representation of the weight for this simulation.\n    \"\"\"\n    editDialog = QtWidgets.QDialog()\n    setDialogSize(editDialog, 600, 100)\n    editDialog.setWindowFlags(\n        PyQt5.QtCore.Qt.WindowTitleHint | PyQt5.QtCore.Qt.WindowSystemMenuHint\n    )\n    editDialog.setWindowTitle(\"Edit Discharge\")\n    editLayout = QtWidgets.QFormLayout(editDialog)\n\n    label = QtWidgets.QLabel(istr)\n    editLayout.addRow(\"Level Nr\", label)\n\n    addOpenFileRow(editLayout, \"editDischarge\", \"Simulation File\")\n    dialog[\"editDischargeEdit\"].setText(fileName)\n\n    probability = QtWidgets.QLineEdit()\n    probability.setText(prob)\n    probability.setValidator(validator(\"positive_real\"))\n    editLayout.addRow(\"Probability [-]\", probability)\n\n    done = QtWidgets.QPushButton(\"Done\")\n    done.clicked.connect(partial(close_edit, editDialog))\n    # edit_SearchDistance.setValidator(validator(\"positive_real\"))\n    editLayout.addRow(\" \", done)\n\n    editDialog.exec()\n\n    fileName = dialog[\"editDischargeEdit\"].text()\n    prob = probability.text()\n    return fileName, prob\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.editASearchLine","title":"<code>editASearchLine(key: str, istr: str, fileName: str = '', dist: str = '50') -&gt; Tuple[str, str]</code>","text":"<p>Create an edit dialog for the search lines list.</p>"},{"location":"gui/gui.html#dfastbe.gui.editASearchLine--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter. istr : str     String representation of the search line in the list. fileName : str     Name of the search line file. dist : str     String representation of the search distance.</p>"},{"location":"gui/gui.html#dfastbe.gui.editASearchLine--returns","title":"Returns","text":"<p>fileName1 : str     Updated name of the search line file. dist1 : str     Updated string representation of the search distance.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def editASearchLine(\n    key: str, istr: str, fileName: str = \"\", dist: str = \"50\"\n) -&gt; Tuple[str, str]:\n    \"\"\"\n    Create an edit dialog for the search lines list.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    istr : str\n        String representation of the search line in the list.\n    fileName : str\n        Name of the search line file.\n    dist : str\n        String representation of the search distance.\n\n    Returns\n    -------\n    fileName1 : str\n        Updated name of the search line file.\n    dist1 : str\n        Updated string representation of the search distance.\n    \"\"\"\n    editDialog = QtWidgets.QDialog()\n    setDialogSize(editDialog, 600, 100)\n    editDialog.setWindowFlags(\n        PyQt5.QtCore.Qt.WindowTitleHint | PyQt5.QtCore.Qt.WindowSystemMenuHint\n    )\n    editDialog.setWindowTitle(\"Edit Search Line\")\n    editLayout = QtWidgets.QFormLayout(editDialog)\n\n    label = QtWidgets.QLabel(istr)\n    editLayout.addRow(\"Search Line Nr\", label)\n\n    addOpenFileRow(editLayout, \"editSearchLine\", \"Search Line File\")\n    dialog[\"editSearchLineEdit\"].setText(fileName)\n\n    searchDistance = QtWidgets.QLineEdit()\n    searchDistance.setText(dist)\n    searchDistance.setValidator(validator(\"positive_real\"))\n    editLayout.addRow(\"Search Distance [m]\", searchDistance)\n\n    done = QtWidgets.QPushButton(\"Done\")\n    done.clicked.connect(partial(close_edit, editDialog))\n    # edit_SearchDistance.setValidator(validator(\"positive_real\"))\n    editLayout.addRow(\" \", done)\n\n    editDialog.exec()\n\n    fileName = dialog[\"editSearchLineEdit\"].text()\n    dist = searchDistance.text()\n    return fileName, dist\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.editAnItem","title":"<code>editAnItem(key: str) -&gt; None</code>","text":"<p>Implements the actions for the edit item button.</p> <p>Dialog implemented in separate routines.</p>"},{"location":"gui/gui.html#dfastbe.gui.editAnItem--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def editAnItem(key: str) -&gt; None:\n    \"\"\"\n    Implements the actions for the edit item button.\n\n    Dialog implemented in separate routines.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    \"\"\"\n    selected = dialog[key].selectedItems()\n    root = dialog[key].invisibleRootItem()\n    if len(selected) &gt; 0:\n        istr = selected[0].text(0)\n        if key == \"searchLines\":\n            fileName = selected[0].text(1)\n            dist = selected[0].text(2)\n            fileName, dist = editASearchLine(key, istr, fileName=fileName, dist=dist)\n            selected[0].setText(1, fileName)\n            selected[0].setText(2, dist)\n        elif key == \"discharges\":\n            fileName = selected[0].text(1)\n            prob = selected[0].text(2)\n            fileName, prob = editADischarge(key, istr, fileName=fileName, prob=prob)\n            selected[0].setText(1, fileName)\n            selected[0].setText(2, prob)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.generalParLayout","title":"<code>generalParLayout(gridLayout: PyQt5.QtWidgets.QGridLayout, row: int, key: str, labelString: str, selectList: Optional[List[str]] = None) -&gt; None</code>","text":"<p>Add a line of controls for editing a general parameter.</p>"},{"location":"gui/gui.html#dfastbe.gui.generalParLayout--arguments","title":"Arguments","text":"<p>gridLayout : PyQt5.QtWidgets.QGridLayout     Grid layout object in which to position the edit controls. row : int     Grid row number to be used for this parameter. key : str     Short name of the parameter. labelString : str     String describing the parameter to be displayed as label. selectList : Optional[List[str]]     In case the parameter can only have a limited number of values: a list     of strings describing the options.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def generalParLayout(\n    gridLayout: PyQt5.QtWidgets.QGridLayout,\n    row: int,\n    key: str,\n    labelString: str,\n    selectList: Optional[List[str]] = None,\n) -&gt; None:\n    \"\"\"\n    Add a line of controls for editing a general parameter.\n\n    Arguments\n    ---------\n    gridLayout : PyQt5.QtWidgets.QGridLayout\n        Grid layout object in which to position the edit controls.\n    row : int\n        Grid row number to be used for this parameter.\n    key : str\n        Short name of the parameter.\n    labelString : str\n        String describing the parameter to be displayed as label.\n    selectList : Optional[List[str]]\n        In case the parameter can only have a limited number of values: a list\n        of strings describing the options.\n    \"\"\"\n    Label = QtWidgets.QLabel(labelString)\n    dialog[key] = Label\n    gridLayout.addWidget(Label, row, 0)\n\n    paramTypes = (\"Constant\", \"Variable\")\n    Type = QtWidgets.QComboBox()\n    Type.addItems(paramTypes)\n    Type.currentIndexChanged.connect(partial(typeUpdatePar, key))\n    dialog[key + \"Type\"] = Type\n    gridLayout.addWidget(Type, row, 1)\n\n    if selectList is None:\n        fLayout = openFileLayout(key + \"Edit\", enabled=False)\n        gridLayout.addWidget(fLayout, row, 2)\n    else:\n        Select = QtWidgets.QComboBox()\n        Select.addItems(selectList)\n        dialog[key + \"Select\"] = Select\n        gridLayout.addWidget(Select, row, 2)\n\n        fLayout = openFileLayout(key + \"Edit\", enabled=False)\n        dialog[key + \"Edit\"].setEnabled(False)\n        gridLayout.addWidget(fLayout, row + 1, 2)\n\n    typeUpdatePar(key)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.getIcon","title":"<code>getIcon(filename: str) -&gt; PyQt5.QtGui.QIcon</code>","text":"<p>Opens the icon file relative to the location of the program.</p>"},{"location":"gui/gui.html#dfastbe.gui.getIcon--arguments","title":"Arguments","text":"<p>filename : str     Name of the icon file.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def getIcon(filename: str) -&gt; PyQt5.QtGui.QIcon:\n    \"\"\"\n    Opens the icon file relative to the location of the program.\n\n    Arguments\n    ---------\n    filename : str\n        Name of the icon file.\n    \"\"\"\n    progloc = str(pathlib.Path(__file__).parent.absolute())\n    return PyQt5.QtGui.QIcon(progloc + os.path.sep + filename)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.get_configuration","title":"<code>get_configuration() -&gt; configparser.ConfigParser</code>","text":"<p>Extract a configuration from the GUI.</p>"},{"location":"gui/gui.html#dfastbe.gui.get_configuration--arguments","title":"Arguments","text":"<p>None</p>"},{"location":"gui/gui.html#dfastbe.gui.get_configuration--returns","title":"Returns","text":"<p>config : configparser.ConfigParser     Configuration for the D-FAST Bank Erosion analysis.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def get_configuration() -&gt; configparser.ConfigParser:\n    \"\"\"\n    Extract a configuration from the GUI.\n\n    Arguments\n    ---------\n    None\n\n    Returns\n    -------\n    config : configparser.ConfigParser\n        Configuration for the D-FAST Bank Erosion analysis.\n    \"\"\"\n    config = configparser.ConfigParser()\n    config.optionxform = str  # case sensitive configuration\n\n    config.add_section(\"General\")\n    config[\"General\"][\"Version\"] = \"1.0\"\n    config[\"General\"][\"RiverKM\"] = dialog[\"chainFileEdit\"].text()\n    config[\"General\"][\"Boundaries\"] = (\n        dialog[\"startRange\"].text() + \":\" + dialog[\"endRange\"].text()\n    )\n    config[\"General\"][\"BankDir\"] = dialog[\"bankDirEdit\"].text()\n    config[\"General\"][\"BankFile\"] = dialog[\"bankFileName\"].text()\n    config[\"General\"][\"Plotting\"] = str(dialog[\"makePlotsEdit\"].isChecked())\n    config[\"General\"][\"SavePlots\"] = str(dialog[\"savePlotsEdit\"].isChecked())\n    config[\"General\"][\"SaveZoomPlots\"] = str(dialog[\"saveZoomPlotsEdit\"].isChecked())\n    config[\"General\"][\"ZoomStepKM\"] = dialog[\"zoomPlotsRangeEdit\"].text()\n    config[\"General\"][\"FigureDir\"] = dialog[\"figureDirEdit\"].text()\n    config[\"General\"][\"ClosePlots\"] = str(dialog[\"closePlotsEdit\"].isChecked())\n    config[\"General\"][\"DebugOutput\"] = str(dialog[\"debugOutputEdit\"].isChecked())\n\n    config.add_section(\"Detect\")\n    config[\"Detect\"][\"SimFile\"] = dialog[\"simFileEdit\"].text()\n    config[\"Detect\"][\"WaterDepth\"] = dialog[\"waterDepth\"].text()\n    nbank = dialog[\"searchLines\"].topLevelItemCount()\n    config[\"Detect\"][\"NBank\"] = str(nbank)\n    dlines = \"[ \"\n    for i in range(nbank):\n        istr = str(i + 1)\n        config[\"Detect\"][\"Line\" + istr] = dialog[\"searchLines\"].topLevelItem(i).text(1)\n        dlines += dialog[\"searchLines\"].topLevelItem(i).text(2) + \", \"\n    dlines = dlines[:-2] + \" ]\"\n    config[\"Detect\"][\"DLines\"] = dlines\n\n    config.add_section(\"Erosion\")\n    config[\"Erosion\"][\"TErosion\"] = dialog[\"tErosion\"].text()\n    config[\"Erosion\"][\"RiverAxis\"] = dialog[\"riverAxisEdit\"].text()\n    config[\"Erosion\"][\"Fairway\"] = dialog[\"fairwayEdit\"].text()\n    config[\"Erosion\"][\"OutputInterval\"] = dialog[\"chainageOutStep\"].text()\n    config[\"Erosion\"][\"OutputDir\"] = dialog[\"outDirEdit\"].text()\n    config[\"Erosion\"][\"BankNew\"] = dialog[\"newBankFile\"].text()\n    config[\"Erosion\"][\"BankEq\"] = dialog[\"newEqBankFile\"].text()\n    config[\"Erosion\"][\"EroVol\"] = dialog[\"eroVol\"].text()\n    config[\"Erosion\"][\"EroVolEqui\"] = dialog[\"eroVolEqui\"].text()\n\n    if dialog[\"shipTypeType\"].currentText() == \"Constant\":\n        config[\"Erosion\"][\"ShipType\"] = str(\n            dialog[\"shipTypeSelect\"].currentIndex() + 1\n        )  # index 0 -&gt; shipType 1\n    else:\n        config[\"Erosion\"][\"ShipType\"] = dialog[\"shipTypeEdit\"].text()\n    config[\"Erosion\"][\"VShip\"] = dialog[\"shipVelocEdit\"].text()\n    config[\"Erosion\"][\"NShip\"] = dialog[\"nShipsEdit\"].text()\n    config[\"Erosion\"][\"NWaves\"] = dialog[\"shipNWavesEdit\"].text()\n    config[\"Erosion\"][\"Draught\"] = dialog[\"shipDraughtEdit\"].text()\n    config[\"Erosion\"][\"Wave0\"] = dialog[\"wavePar0Edit\"].text()\n    config[\"Erosion\"][\"Wave1\"] = dialog[\"wavePar1Edit\"].text()\n\n    if dialog[\"strengthPar\"].currentText() == \"Bank Type\":\n        config[\"Erosion\"][\"Classes\"] = \"true\"\n        if dialog[\"bankTypeType\"].currentText() == \"Constant\":\n            config[\"Erosion\"][\"BankType\"] = dialog[\"bankTypeSelect\"].currentIndex()\n        else:\n            config[\"Erosion\"][\"BankType\"] = dialog[\"bankTypeEdit\"].text()\n    else:\n        config[\"Erosion\"][\"Classes\"] = \"false\"\n        config[\"Erosion\"][\"BankType\"] = dialog[\"bankShearEdit\"].text()\n    config[\"Erosion\"][\"ProtectionLevel\"] = dialog[\"bankProtectEdit\"].text()\n    config[\"Erosion\"][\"Slope\"] = dialog[\"bankSlopeEdit\"].text()\n    config[\"Erosion\"][\"Reed\"] = dialog[\"bankReedEdit\"].text()\n\n    if dialog[\"velFilterActive\"].isChecked():\n        config[\"Erosion\"][\"VelFilterDist\"] = dialog[\"velFilterWidth\"].text()\n    if dialog[\"bedFilterActive\"].isChecked():\n        config[\"Erosion\"][\"BedFilterDist\"] = dialog[\"bedFilterWidth\"].text()\n\n    nlevel = dialog[\"discharges\"].topLevelItemCount()\n    config[\"Erosion\"][\"NLevel\"] = str(nlevel)\n    config[\"Erosion\"][\"RefLevel\"] = dialog[\"refLevel\"].text()\n    for i in range(nlevel):\n        istr = str(i + 1)\n        config[\"Erosion\"][\"SimFile\" + istr] = (\n            dialog[\"discharges\"].topLevelItem(i).text(1)\n        )\n        config[\"Erosion\"][\"PDischarge\" + istr] = (\n            dialog[\"discharges\"].topLevelItem(i).text(2)\n        )\n        if dialog[istr + \"_shipTypeType\"].currentText() != \"Use Default\":\n            if dialog[istr + \"_shipTypeType\"].currentText() == \"Constant\":\n                config[\"Erosion\"][\"ShipType\" + istr] = (\n                    dialog[istr + \"_shipTypeSelect\"].currentIndex() + 1\n                )  # index 0 -&gt; shipType 1\n            else:\n                config[\"Erosion\"][\"ShipType\" + istr] = dialog[\n                    istr + \"_shipTypeEdit\"\n                ].text()\n        if dialog[istr + \"_shipVelocType\"].currentText() != \"Use Default\":\n            config[\"Erosion\"][\"VShip\" + istr] = dialog[istr + \"_shipVelocEdit\"].text()\n        if dialog[istr + \"_nShipsType\"].currentText() != \"Use Default\":\n            config[\"Erosion\"][\"NShip\" + istr] = dialog[istr + \"_nShipsEdit\"].text()\n        if dialog[istr + \"_shipNWavesType\"].currentText() != \"Use Default\":\n            config[\"Erosion\"][\"NWaves\" + istr] = dialog[istr + \"_shipNWavesEdit\"].text()\n        if dialog[istr + \"_shipDraughtType\"].currentText() != \"Use Default\":\n            config[\"Erosion\"][\"Draught\" + istr] = dialog[\n                istr + \"_shipDraughtEdit\"\n            ].text()\n        if dialog[istr + \"_bankSlopeType\"].currentText() != \"Use Default\":\n            config[\"Erosion\"][\"Slope\" + istr] = dialog[istr + \"_bankSlopeEdit\"].text()\n        if dialog[istr + \"_bankReedType\"].currentText() != \"Use Default\":\n            config[\"Erosion\"][\"Reed\" + istr] = dialog[istr + \"_bankReedEdit\"].text()\n        if dialog[istr + \"_eroVolEdit\"].text() != \"\":\n            config[\"Erosion\"][\"EroVol\" + istr] = dialog[istr + \"_eroVolEdit\"].text()\n    return config\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui_text","title":"<code>gui_text(key: str, prefix: str = 'gui_', dict: Dict[str, Any] = {})</code>","text":"<p>Query the global dictionary of texts for a single string in the GUI.</p> <p>This routine concatenates the prefix and the key to query the global dictionary of texts. It selects the first line of the text obtained and expands and placeholders in the string using the optional dictionary provided.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui_text--arguments","title":"Arguments","text":"<p>key : str     The key string used to query the dictionary (extended with prefix). prefix : str     The prefix used in combination with the key (default \"gui_\"). dict : Dict[str, Any]     A dictionary used for placeholder expansions (default empty).</p>"},{"location":"gui/gui.html#dfastbe.gui.gui_text--returns","title":"Returns","text":"<pre><code>The first line of the text in the dictionary expanded with the keys.\n</code></pre> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def gui_text(key: str, prefix: str = \"gui_\", dict: Dict[str, Any] = {}):\n    \"\"\"\n    Query the global dictionary of texts for a single string in the GUI.\n\n    This routine concatenates the prefix and the key to query the global\n    dictionary of texts. It selects the first line of the text obtained and\n    expands and placeholders in the string using the optional dictionary\n    provided.\n\n    Arguments\n    ---------\n    key : str\n        The key string used to query the dictionary (extended with prefix).\n    prefix : str\n        The prefix used in combination with the key (default \"gui_\").\n    dict : Dict[str, Any]\n        A dictionary used for placeholder expansions (default empty).\n\n    Returns\n    -------\n        The first line of the text in the dictionary expanded with the keys.\n    \"\"\"\n    cstr = get_text(prefix + key)\n    str = cstr[0].format(**dict)\n    return str\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.load_configuration","title":"<code>load_configuration(filename: str) -&gt; None</code>","text":"<p>Open a configuration file and update the GUI accordingly.</p> <p>This routines opens the specified configuration file and updates the GUI to reflect it contents.</p>"},{"location":"gui/gui.html#dfastbe.gui.load_configuration--arguments","title":"Arguments","text":"<p>filename : str     Name of the configuration file to be opened.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def load_configuration(filename: str) -&gt; None:\n    \"\"\"\n    Open a configuration file and update the GUI accordingly.\n\n    This routines opens the specified configuration file and updates the GUI\n    to reflect it contents.\n\n    Arguments\n    ---------\n    filename : str\n        Name of the configuration file to be opened.\n    \"\"\"\n    if not os.path.exists(filename):\n        if filename != \"dfastbe.cfg\":\n            showError(\"The file '{}' does not exist!\".format(filename))\n        return\n    absfilename = absolute_path(os.getcwd(), filename)\n    rootdir = os.path.dirname(absfilename)\n    config_file = ConfigFile.read(absfilename)\n\n    config_file.path = absfilename\n\n    try:\n        version = config_file.version\n    except KeyError:\n        showError(\"No version information in the file!\")\n        return\n\n    config = config_file.config\n    if version == \"1.0\":\n        section = config[\"General\"]\n        dialog[\"chainFileEdit\"].setText(section[\"RiverKM\"])\n        studyRange = config_file.get_range(\"General\", \"Boundaries\")\n        dialog[\"startRange\"].setText(str(studyRange[0]))\n        dialog[\"endRange\"].setText(str(studyRange[1]))\n        dialog[\"bankDirEdit\"].setText(section[\"BankDir\"])\n        bankFile = config_file.get_str(\"General\", \"BankFile\", default=\"bankfile\")\n        dialog[\"bankFileName\"].setText(bankFile)\n        flag = config_file.get_bool(\"General\", \"Plotting\", default=True)\n        dialog[\"makePlotsEdit\"].setChecked(flag)\n        flag = config_file.get_bool(\"General\", \"SavePlots\", default=True)\n        dialog[\"savePlotsEdit\"].setChecked(flag)\n        flag = config_file.get_bool(\"General\", \"SaveZoomPlots\", default=False)\n        dialog[\"saveZoomPlotsEdit\"].setChecked(flag)\n        zoomStepKM = config_file.get_float(\"General\", \"ZoomStepKM\", default=1.0)\n        dialog[\"zoomPlotsRangeEdit\"].setText(str(zoomStepKM))\n        figDir = config_file.get_str(\n            \"General\",\n            \"FigureDir\",\n            default=absolute_path(rootdir, \"figures\"),\n        )\n        dialog[\"figureDirEdit\"].setText(figDir)\n        flag = config_file.get_bool(\"General\", \"ClosePlots\", default=False)\n        dialog[\"closePlotsEdit\"].setChecked(flag)\n        flag = config_file.get_bool(\"General\", \"DebugOutput\", default=False)\n        dialog[\"debugOutputEdit\"].setChecked(flag)\n\n        section = config[\"Detect\"]\n        dialog[\"simFileEdit\"].setText(section[\"SimFile\"])\n        waterDepth = config_file.get_float(\"Detect\", \"WaterDepth\", default=0.0)\n        dialog[\"waterDepth\"].setText(str(waterDepth))\n        NBank = config_file.get_int(\"Detect\", \"NBank\", default=0, positive=True)\n        DLines = config_file.get_bank_search_distances(NBank)\n        dialog[\"searchLines\"].invisibleRootItem().takeChildren()\n        for i in range(NBank):\n            istr = str(i + 1)\n            fileName = config_file.get_str(\"Detect\", \"Line\" + istr)\n            c1 = QtWidgets.QTreeWidgetItem(\n                dialog[\"searchLines\"], [istr, fileName, str(DLines[i])]\n            )\n        if NBank &gt; 0:\n            dialog[\"searchLinesEdit\"].setEnabled(True)\n            dialog[\"searchLinesRemove\"].setEnabled(True)\n\n        section = config[\"Erosion\"]\n        dialog[\"tErosion\"].setText(section[\"TErosion\"])\n        dialog[\"riverAxisEdit\"].setText(section[\"RiverAxis\"])\n        dialog[\"fairwayEdit\"].setText(section[\"Fairway\"])\n        dialog[\"chainageOutStep\"].setText(section[\"OutputInterval\"])\n        dialog[\"outDirEdit\"].setText(section[\"OutputDir\"])\n        bankNew = config_file.get_str(\"Erosion\", \"BankNew\", default=\"banknew\")\n        dialog[\"newBankFile\"].setText(bankNew)\n        bankEq = config_file.get_str(\"Erosion\", \"BankEq\", default=\"bankeq\")\n        dialog[\"newEqBankFile\"].setText(bankEq)\n        txt = config_file.get_str(\"Erosion\", \"EroVol\", default=\"erovol_standard.evo\")\n        dialog[\"eroVol\"].setText(txt)\n        txt = config_file.get_str(\"Erosion\", \"EroVolEqui\", default=\"erovol_eq.evo\")\n        dialog[\"eroVolEqui\"].setText(txt)\n\n        NLevel = config_file.get_int(\"Erosion\", \"NLevel\", default=0, positive=True)\n        dialog[\"discharges\"].invisibleRootItem().takeChildren()\n        for i in range(NLevel):\n            istr = str(i + 1)\n            fileName = config_file.get_str(\"Erosion\", \"SimFile\" + istr)\n            prob = config_file.get_str(\"Erosion\", \"PDischarge\" + istr)\n            c1 = QtWidgets.QTreeWidgetItem(dialog[\"discharges\"], [istr, fileName, prob])\n        if NLevel &gt; 0:\n            dialog[\"dischargesEdit\"].setEnabled(True)\n            dialog[\"dischargesRemove\"].setEnabled(True)\n        dialog[\"refLevel\"].validator().setTop(NLevel)\n        dialog[\"refLevel\"].setText(section[\"RefLevel\"])\n\n        setParam(\"shipType\", config, \"Erosion\", \"ShipType\")\n        setParam(\"shipVeloc\", config, \"Erosion\", \"VShip\")\n        setParam(\"nShips\", config, \"Erosion\", \"NShip\")\n        setParam(\"shipNWaves\", config, \"Erosion\", \"NWave\", \"5\")\n        setParam(\"shipDraught\", config, \"Erosion\", \"Draught\")\n        setParam(\"wavePar0\", config, \"Erosion\", \"Wave0\", \"200.0\")\n        wave0 = config_file.get_str(\"Erosion\", \"Wave0\", \"200.0\")\n        setParam(\"wavePar1\", config_file.config, \"Erosion\", \"Wave1\", wave0)\n\n        useBankType = config_file.get_bool(\"Erosion\", \"Classes\", default=True)\n        dialog[\"bankType\"].setEnabled(useBankType)\n        dialog[\"bankTypeType\"].setEnabled(useBankType)\n        dialog[\"bankTypeEdit\"].setEnabled(useBankType)\n        dialog[\"bankTypeEditFile\"].setEnabled(useBankType)\n        dialog[\"bankShear\"].setEnabled(not useBankType)\n        dialog[\"bankShearType\"].setEnabled(not useBankType)\n        dialog[\"bankShearEdit\"].setEnabled(not useBankType)\n        dialog[\"bankShearEditFile\"].setEnabled(not useBankType)\n        if useBankType:\n            dialog[\"strengthPar\"].setCurrentText(\"Bank Type\")\n            bankStrengthSwitch()\n            setParam(\"bankType\", config_file.config, \"Erosion\", \"BankType\")\n        else:\n            dialog[\"strengthPar\"].setCurrentText(\"Critical Shear Stress\")\n            bankStrengthSwitch()\n            setParam(\"bankShear\", config, \"Erosion\", \"BankType\")\n        setParam(\"bankProtect\", config, \"Erosion\", \"ProtectionLevel\", \"-1000\")\n        setParam(\"bankSlope\", config, \"Erosion\", \"Slope\", \"20.0\")\n        setParam(\"bankReed\", config, \"Erosion\", \"Reed\", \"0.0\")\n\n        setFilter(\"velFilter\", config, \"Erosion\", \"VelFilterDist\")\n        setFilter(\"bedFilter\", config, \"Erosion\", \"BedFilterDist\")\n\n        tabs = dialog[\"tabs\"]\n        for i in range(tabs.count() - 1, 4, -1):\n            tabs.removeTab(i)\n\n        for i in range(NLevel):\n            istr = str(i + 1)\n            addTabForLevel(istr)\n            setOptParam(istr + \"_shipType\", config, \"Erosion\", \"ShipType\" + istr)\n            setOptParam(istr + \"_shipVeloc\", config, \"Erosion\", \"VShip\" + istr)\n            setOptParam(istr + \"_nShips\", config, \"Erosion\", \"NShip\" + istr)\n            setOptParam(istr + \"_shipNWaves\", config, \"Erosion\", \"NWave\" + istr)\n            setOptParam(istr + \"_shipDraught\", config, \"Erosion\", \"Draught\" + istr)\n            setOptParam(istr + \"_bankSlope\", config, \"Erosion\", \"Slope\" + istr)\n            setOptParam(istr + \"_bankReed\", config, \"Erosion\", \"Reed\" + istr)\n            txt = config_file.get_str(\"Erosion\", \"EroVol\" + istr, default=\"\")\n            dialog[istr + \"_eroVolEdit\"].setText(txt)\n\n    else:\n        showError(\"Unsupported version number {} in the file!\".format(version))\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.main","title":"<code>main(config: Optional[str] = None) -&gt; None</code>","text":"<p>Start the user interface using default settings or optional configuration.</p>"},{"location":"gui/gui.html#dfastbe.gui.main--arguments","title":"Arguments","text":"<p>config : Optional[str]     Optional name of configuration file.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def main(config: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Start the user interface using default settings or optional configuration.\n\n    Arguments\n    ---------\n    config : Optional[str]\n        Optional name of configuration file.\n    \"\"\"\n    create_dialog()\n    if not config is None:\n        load_configuration(config)\n\n    activate_dialog()\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.menu_about_qt","title":"<code>menu_about_qt()</code>","text":"<p>Show the about dialog for Qt.</p>"},{"location":"gui/gui.html#dfastbe.gui.menu_about_qt--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def menu_about_qt():\n    \"\"\"\n    Show the about dialog for Qt.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    QtWidgets.QApplication.aboutQt()\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.menu_about_self","title":"<code>menu_about_self()</code>","text":"<p>Show the about dialog for D-FAST Bank Erosion.</p>"},{"location":"gui/gui.html#dfastbe.gui.menu_about_self--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def menu_about_self():\n    \"\"\"\n    Show the about dialog for D-FAST Bank Erosion.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    msg = QtWidgets.QMessageBox()\n    msg.setIcon(QtWidgets.QMessageBox.Information)\n    msg.setText(f\"D-FAST Bank Erosion {__version__}\")\n    msg.setInformativeText(\"Copyright (c) 2020 Deltares.\")\n    msg.setDetailedText(gui_text(\"license\"))\n    msg.setWindowTitle(gui_text(\"about\"))\n    msg.setStandardButtons(QtWidgets.QMessageBox.Ok)\n    msg.setStyleSheet(\"QDialogButtonBox{min-width: 400px;}\")\n    msg.exec_()\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.menu_load_configuration","title":"<code>menu_load_configuration() -&gt; None</code>","text":"<p>Select and load a configuration file.</p>"},{"location":"gui/gui.html#dfastbe.gui.menu_load_configuration--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def menu_load_configuration() -&gt; None:\n    \"\"\"\n    Select and load a configuration file.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    fil = QtWidgets.QFileDialog.getOpenFileName(\n        caption=\"Select Configuration File\", filter=\"Config Files (*.cfg)\"\n    )\n    filename = fil[0]\n    if filename != \"\":\n        load_configuration(filename)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.menu_open_manual","title":"<code>menu_open_manual()</code>","text":"<p>Open the user manual.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def menu_open_manual():\n    \"\"\"Open the user manual.\"\"\"\n    filename = str(r_dir / USER_MANUAL_FILE_NAME)\n    subprocess.Popen(filename, shell=True)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.menu_save_configuration","title":"<code>menu_save_configuration() -&gt; None</code>","text":"<p>Ask for a configuration file name and save GUI selection to that file.</p>"},{"location":"gui/gui.html#dfastbe.gui.menu_save_configuration--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def menu_save_configuration() -&gt; None:\n    \"\"\"\n    Ask for a configuration file name and save GUI selection to that file.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    fil = QtWidgets.QFileDialog.getSaveFileName(\n        caption=\"Save Configuration As\", filter=\"Config Files (*.cfg)\"\n    )\n    filename = fil[0]\n    if filename != \"\":\n        config = get_configuration()\n        rootdir = os.path.dirname(filename)\n        config_file = ConfigFile(config)\n        config_file.relative_to(rootdir)\n        config.write(filename)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.openFileLayout","title":"<code>openFileLayout(key, enabled=True) -&gt; PyQt5.QtWidgets.QWidget</code>","text":"<p>Create a standard layout with a file or folder edit field and selection button.</p>"},{"location":"gui/gui.html#dfastbe.gui.openFileLayout--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter. enabled : bool     Flag indicating whether the file selection button should be enabed by default.</p>"},{"location":"gui/gui.html#dfastbe.gui.openFileLayout--returns","title":"Returns","text":"<p>parent : PyQt5.QtWidgets.QWidget     Parent QtWidget that contains the edit field and selection button.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def openFileLayout(key, enabled=True) -&gt; PyQt5.QtWidgets.QWidget:\n    \"\"\"\n    Create a standard layout with a file or folder edit field and selection button.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    enabled : bool\n        Flag indicating whether the file selection button should be enabed by default.\n\n    Returns\n    ------\n    parent : PyQt5.QtWidgets.QWidget\n        Parent QtWidget that contains the edit field and selection button.\n    \"\"\"\n    parent = QtWidgets.QWidget()\n    gridly = QtWidgets.QGridLayout(parent)\n    gridly.setContentsMargins(0, 0, 0, 0)\n\n    myWidget = QtWidgets.QLineEdit()\n    dialog[key] = myWidget\n    gridly.addWidget(myWidget, 0, 0)\n\n    openFile = QtWidgets.QPushButton(getIcon(\"open.png\"), \"\")\n    openFile.clicked.connect(partial(selectFile, key))\n    openFile.setEnabled(enabled)\n    dialog[key + \"File\"] = openFile\n    gridly.addWidget(openFile, 0, 2)\n\n    return parent\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.optionalParLayout","title":"<code>optionalParLayout(gridLayout: PyQt5.QtWidgets.QGridLayout, row: int, key, labelString, selectList=None) -&gt; None</code>","text":"<p>Add a line of controls for editing an optional parameter.</p>"},{"location":"gui/gui.html#dfastbe.gui.optionalParLayout--arguments","title":"Arguments","text":"<p>gridLayout : PyQt5.QtWidgets.QGridLayout     Grid layout object in which to position the edit controls. row : int     Grid row number to be used for this parameter. key : str     Short name of the parameter. labelString : str     String describing the parameter to be displayed as label. selectList : Optional[List[str]]     In case the parameter can only have a limited number of values: a list     of strings describing the options.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def optionalParLayout(\n    gridLayout: PyQt5.QtWidgets.QGridLayout, row: int, key, labelString, selectList=None\n) -&gt; None:\n    \"\"\"\n    Add a line of controls for editing an optional parameter.\n\n    Arguments\n    ---------\n    gridLayout : PyQt5.QtWidgets.QGridLayout\n        Grid layout object in which to position the edit controls.\n    row : int\n        Grid row number to be used for this parameter.\n    key : str\n        Short name of the parameter.\n    labelString : str\n        String describing the parameter to be displayed as label.\n    selectList : Optional[List[str]]\n        In case the parameter can only have a limited number of values: a list\n        of strings describing the options.\n    \"\"\"\n    Label = QtWidgets.QLabel(labelString)\n    dialog[key + \"Label\"] = Label\n    gridLayout.addWidget(Label, row, 0)\n\n    paramTypes = (\"Use Default\", \"Constant\", \"Variable\")\n    Type = QtWidgets.QComboBox()\n    Type.addItems(paramTypes)\n    Type.currentIndexChanged.connect(partial(typeUpdatePar, key))\n    dialog[key + \"Type\"] = Type\n    gridLayout.addWidget(Type, row, 1)\n\n    if selectList is None:\n        fLayout = openFileLayout(key + \"Edit\", enabled=False)\n        dialog[key + \"Edit\"].setEnabled(False)\n        gridLayout.addWidget(fLayout, row, 2)\n    else:\n        Select = QtWidgets.QComboBox()\n        Select.addItems(selectList)\n        Select.setEnabled(False)\n        dialog[key + \"Select\"] = Select\n        gridLayout.addWidget(Select, row, 2)\n\n        fLayout = openFileLayout(key + \"Edit\", enabled=False)\n        dialog[key + \"Edit\"].setEnabled(False)\n        gridLayout.addWidget(fLayout, row + 1, 2)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.removeAnItem","title":"<code>removeAnItem(key: str) -&gt; None</code>","text":"<p>Implements the actions for the remove item button.</p>"},{"location":"gui/gui.html#dfastbe.gui.removeAnItem--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def removeAnItem(key: str) -&gt; None:\n    \"\"\"\n    Implements the actions for the remove item button.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    \"\"\"\n    selected = dialog[key].selectedItems()\n    root = dialog[key].invisibleRootItem()\n    if len(selected) &gt; 0:\n        istr = selected[0].text(0)\n        root.removeChild(selected[0])\n        i = int(istr) - 1\n        for j in range(i, root.childCount()):\n            root.child(j).setText(0, str(j + 1))\n    else:\n        istr = \"\"\n    if root.childCount() == 0:\n        dialog[key + \"Edit\"].setEnabled(False)\n        dialog[key + \"Remove\"].setEnabled(False)\n    if istr == \"\":\n        pass\n    elif key == \"searchLines\":\n        pass\n    elif key == \"discharges\":\n        tabs = dialog[\"tabs\"]\n        dialog[\"refLevel\"].validator().setTop(root.childCount())\n        dj = 0\n        for j in range(tabs.count()):\n            if dj &gt; 0:\n                tabs.setTabText(j - 1, \"Level \" + str(j + dj))\n                updateTabKeys(j + dj + 1)\n            elif tabs.tabText(j) == \"Level \" + istr:\n                tabs.removeTab(j)\n                dj = i - j\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.run_detection","title":"<code>run_detection() -&gt; None</code>","text":"<p>Run the bank line detection based on settings in the GUI.</p> <p>Use a dummy configuration name in the current work directory to create relative paths.</p>"},{"location":"gui/gui.html#dfastbe.gui.run_detection--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def run_detection() -&gt; None:\n    \"\"\"\n    Run the bank line detection based on settings in the GUI.\n\n    Use a dummy configuration name in the current work directory to create\n    relative paths.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    config = get_configuration()\n    rootdir = os.getcwd()\n    config_file = ConfigFile(config)\n    config_file.root_dir = rootdir\n    config_file.relative_to(rootdir)\n    dialog[\"application\"].setOverrideCursor(QtCore.Qt.WaitCursor)\n    matplotlib.pyplot.close(\"all\")\n    # should maybe use a separate thread for this ...\n    msg = \"\"\n    try:\n        bank_line = BankLines(config_file, gui=True)\n        bank_line.detect()\n    except Exception as Ex:\n        msg = str(Ex)\n    dialog[\"application\"].restoreOverrideCursor()\n    if msg != \"\":\n        print(msg)\n        showError(msg)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.run_erosion","title":"<code>run_erosion() -&gt; None</code>","text":"<p>Run the D-FAST Bank Erosion analysis based on settings in the GUI.</p> <p>Use a dummy configuration name in the current work directory to create relative paths.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def run_erosion() -&gt; None:\n    \"\"\"\n    Run the D-FAST Bank Erosion analysis based on settings in the GUI.\n\n    Use a dummy configuration name in the current work directory to create\n    relative paths.\n    \"\"\"\n    config = get_configuration()\n    rootdir = os.getcwd()\n    config_file = ConfigFile(config)\n    config_file.root_dir = rootdir\n    config_file.relative_to(rootdir)\n    dialog[\"application\"].setOverrideCursor(QtCore.Qt.WaitCursor)\n    matplotlib.pyplot.close(\"all\")\n    erosion = Erosion(config_file, gui=True)\n    erosion.bankerosion_core()\n    dialog[\"application\"].restoreOverrideCursor()\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.selectFile","title":"<code>selectFile(key: str) -&gt; None</code>","text":"<p>Select a file or directory via a selection dialog.</p>"},{"location":"gui/gui.html#dfastbe.gui.selectFile--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def selectFile(key: str) -&gt; None:\n    \"\"\"\n    Select a file or directory via a selection dialog.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    \"\"\"\n    dnm: str\n    if not dialog[key + \"File\"].hasFocus():\n        # in the add/edit dialogs, the selectFile is triggered when the user presses enter in one of the lineEdit boxes ...\n        # don't trigger the actual selectFile\n        fil = \"\"\n    elif key == \"simFileEdit\":\n        fil, fltr = QtWidgets.QFileDialog.getOpenFileName(\n            caption=\"Select D-Flow FM Map File\", filter=\"D-Flow FM Map Files (*map.nc)\"\n        )\n        # getOpenFileName returns a tuple van file name and active file filter.\n    elif key == \"chainFileEdit\":\n        fil, fltr = QtWidgets.QFileDialog.getOpenFileName(\n            caption=\"Select Chainage File\", filter=\"Chainage Files (*.xyc)\"\n        )\n    elif key == \"riverAxisEdit\":\n        fil, fltr = QtWidgets.QFileDialog.getOpenFileName(\n            caption=\"Select River Axis File\", filter=\"River Axis Files (*.xyc)\"\n        )\n    elif key == \"fairwayEdit\":\n        fil, fltr = QtWidgets.QFileDialog.getOpenFileName(\n            caption=\"Select Fairway File\", filter=\"Fairway Files (*.xyc)\"\n        )\n    elif key == \"editSearchLineEdit\":\n        fil, fltr = QtWidgets.QFileDialog.getOpenFileName(\n            caption=\"Select Search Line File\", filter=\"Search Line Files (*.xyc)\"\n        )\n    elif key == \"editDischargeEdit\":\n        fil, fltr = QtWidgets.QFileDialog.getOpenFileName(\n            caption=\"Select Simulation File\", filter=\"Simulation File (*map.nc)\"\n        )\n    elif key == \"bankDirEdit\":\n        fil = QtWidgets.QFileDialog.getExistingDirectory(\n            caption=\"Select Bank Directory\"\n        )\n    elif key == \"figureDirEdit\":\n        fil = QtWidgets.QFileDialog.getExistingDirectory(\n            caption=\"Select Figure Output Directory\"\n        )\n    elif key == \"outDirEdit\":\n        fil = QtWidgets.QFileDialog.getExistingDirectory(\n            caption=\"Select Output Directory\"\n        )\n    else:\n        if key[-4:] == \"Edit\":\n            rkey = key[:-4]\n            nr = \"\"\n            while rkey[0] in \"1234567890\":\n                nr = nr + rkey[0]\n                rkey = rkey[1:]\n            if rkey[0] == \"_\":\n                rkey = rkey[1:]\n            if not nr == \"\":\n                nr = \" for Level \" + nr\n            if rkey == \"bankType\":\n                ftype = \"Bank Type\"\n                ext = \".btp\"\n                oneFile = False\n            elif rkey == \"bankShear\":\n                ftype = \"Critical Shear\"\n                ext = \".btp\"\n                oneFile = False\n            elif rkey == \"bankProtect\":\n                ftype = \"Protection Level\"\n                ext = \".bpl\"\n                oneFile = False\n            elif rkey == \"bankSlope\":\n                ftype = \"Bank Slope\"\n                ext = \".slp\"\n                oneFile = False\n            elif rkey == \"bankReed\":\n                ftype = \"Reed Fraction\"\n                ext = \".rdd\"\n                oneFile = False\n            elif rkey == \"shipType\":\n                ftype = \"Ship Type\"\n                ext = \"\"\n                oneFile = True\n            elif rkey == \"shipVeloc\":\n                ftype = \"Ship Velocity\"\n                ext = \"\"\n                oneFile = True\n            elif rkey == \"nShips\":\n                ftype = \"Number of Ships\"\n                ext = \"\"\n                oneFile = True\n            elif rkey == \"shipNWaves\":\n                ftype = \"Number of Ship Waves\"\n                ext = \"\"\n                oneFile = True\n            elif rkey == \"shipDraught\":\n                ftype = \"Ship Draught\"\n                ext = \"\"\n                oneFile = True\n            elif rkey == \"wavePar0\":\n                ftype = \"Wave0\"\n                ext = \"\"\n                oneFile = True\n            elif rkey == \"wavePar1\":\n                ftype = \"Wave1\"\n                ext = \"\"\n                oneFile = True\n            else:\n                ftype = \"Parameter\"\n                ext = \"*\"\n            ftype = ftype + \" File\"\n            fil, fltr = QtWidgets.QFileDialog.getOpenFileName(\n                caption=\"Select \" + ftype + nr, filter=ftype + \" (*\" + ext + \")\"\n            )\n            if fil != \"\":\n                fil, fext = os.path.splitext(fil)\n                if fext == ext:\n                    if not oneFile:\n                        # file should end on _&lt;nr&gt;\n                        nr = \"\"\n                        while fil[-1] in \"1234567890\":\n                             nr = rkey[-1] + nr\n                             fil = fil[:-1]\n                        if nr == \"\" or fil[-1] != \"_\":\n                            print(\"Missing bank number(s) at end of file name. Reference not updated.\")\n                            fil = \"\"\n                        else:\n                            fil = fil[:-1]\n                else:\n                    if ext == \"\":\n                        print(\"Unsupported file extension {} while expecting no extension. Reference not updated.\".format(fext))\n                    else:\n                        print(\"Unsupported file extension {} while expecting {}. Reference not updated.\".format(fext,ext))\n                    fil = \"\"\n        else:\n            print(key)\n            fil = \"\"\n    if fil != \"\":\n        dialog[key].setText(fil)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.setDialogSize","title":"<code>setDialogSize(editDialog: PyQt5.QtWidgets.QDialog, width: int, height: int) -&gt; None</code>","text":"<p>Set the width and height of a dialog and position it centered relative to the main window.</p>"},{"location":"gui/gui.html#dfastbe.gui.setDialogSize--arguments","title":"Arguments","text":"<p>editDialog : QtWidgets.QDialog     Dialog object to be positioned correctly. width : int     Desired width of the dialog. height : int     Desired height of the dialog.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def setDialogSize(editDialog: PyQt5.QtWidgets.QDialog, width: int, height: int) -&gt; None:\n    \"\"\"\n    Set the width and height of a dialog and position it centered relative to the main window.\n\n    Arguments\n    ---------\n    editDialog : QtWidgets.QDialog\n        Dialog object to be positioned correctly.\n    width : int\n        Desired width of the dialog.\n    height : int\n        Desired height of the dialog.\n    \"\"\"\n    parent = dialog[\"window\"]\n    x = parent.x()\n    y = parent.y()\n    pw = parent.width()\n    ph = parent.height()\n    editDialog.setGeometry(\n        x + pw / 2 - width / 2, y + ph / 2 - height / 2, width, height\n    )\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.setFilter","title":"<code>setFilter(field: str, config, group: str, key: str) -&gt; None</code>","text":"<p>Update the dialog for a filter based on configuration file.</p>"},{"location":"gui/gui.html#dfastbe.gui.setFilter--arguments","title":"Arguments","text":"<p>field : str     Short name of the parameter. config : configparser.ConfigParser     Configuration for the D-FAST Bank Erosion analysis with absolute or relative paths. group : str     Name of the group in the configuration. key : str     Name of the key in the configuration group.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def setFilter(field: str, config, group: str, key: str) -&gt; None:\n    \"\"\"\n    Update the dialog for a filter based on configuration file.\n\n    Arguments\n    ---------\n    field : str\n        Short name of the parameter.\n    config : configparser.ConfigParser\n        Configuration for the D-FAST Bank Erosion analysis with absolute or relative paths.\n    group : str\n        Name of the group in the configuration.\n    key : str\n        Name of the key in the configuration group.\n\n    \"\"\"\n    config_file = ConfigFile(config)\n    val = config_file.get_float(group, key, 0.0)\n    if val &gt; 0.0:\n        dialog[field + \"Active\"].setChecked(True)\n        dialog[field + \"Width\"].setText(str(val))\n    else:\n        dialog[field + \"Active\"].setChecked(False)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.setOptParam","title":"<code>setOptParam(field: str, config, group: str, key: str) -&gt; None</code>","text":"<p>Update the dialog for an optional parameter based on configuration file.</p>"},{"location":"gui/gui.html#dfastbe.gui.setOptParam--arguments","title":"Arguments","text":"<p>field : str     Short name of the parameter. config : configparser.ConfigParser     Configuration for the D-FAST Bank Erosion analysis with absolute or relative paths. group : str     Name of the group in the configuration. key : str     Name of the key in the configuration group.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def setOptParam(field: str, config, group: str, key: str) -&gt; None:\n    \"\"\"\n    Update the dialog for an optional parameter based on configuration file.\n\n    Arguments\n    ---------\n    field : str\n        Short name of the parameter.\n    config : configparser.ConfigParser\n        Configuration for the D-FAST Bank Erosion analysis with absolute or relative paths.\n    group : str\n        Name of the group in the configuration.\n    key : str\n        Name of the key in the configuration group.\n    \"\"\"\n    config_file = ConfigFile(config)\n    str = config_file.get_str(group, key, \"\")\n    if str == \"\":\n        dialog[field + \"Type\"].setCurrentText(\"Use Default\")\n        dialog[field + \"Edit\"].setText(\"\")\n    else:\n        try:\n            val = float(str)\n            dialog[field + \"Type\"].setCurrentText(\"Constant\")\n            if field + \"Select\" in dialog.keys():\n                ival = int(val) - 1  # shipType 1 -&gt; index 0\n                dialog[field + \"Select\"].setCurrentIndex(ival)\n            else:\n                dialog[field + \"Edit\"].setText(str)\n        except:\n            dialog[field + \"Type\"].setCurrentText(\"Variable\")\n            dialog[field + \"Edit\"].setText(str)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.setParam","title":"<code>setParam(field: str, config, group: str, key: str, default: str = '??') -&gt; None</code>","text":"<p>Update the dialog for a general parameter based on configuration file.</p>"},{"location":"gui/gui.html#dfastbe.gui.setParam--arguments","title":"Arguments","text":"<p>field : str     Short name of the parameter. config : configparser.ConfigParser     Configuration for the D-FAST Bank Erosion analysis with absolute or relative paths. group : str     Name of the group in the configuration. key : str     Name of the key in the configuration group. default : str     Default string if the group/key pair doesn't exist in the configuration.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def setParam(field: str, config, group: str, key: str, default: str = \"??\") -&gt; None:\n    \"\"\"\n    Update the dialog for a general parameter based on configuration file.\n\n    Arguments\n    ---------\n    field : str\n        Short name of the parameter.\n    config : configparser.ConfigParser\n        Configuration for the D-FAST Bank Erosion analysis with absolute or relative paths.\n    group : str\n        Name of the group in the configuration.\n    key : str\n        Name of the key in the configuration group.\n    default : str\n        Default string if the group/key pair doesn't exist in the configuration.\n\n    \"\"\"\n    config_file = ConfigFile(config)\n    str = config_file.get_str(group, key, default)\n\n    try:\n        val = float(str)\n        dialog[field + \"Type\"].setCurrentText(\"Constant\")\n        if field + \"Select\" in dialog.keys():\n            ival = int(val)\n            if field == \"shipType\":\n                ival = ival - 1\n            dialog[field + \"Select\"].setCurrentIndex(ival)\n        else:\n            dialog[field + \"Edit\"].setText(str)\n    except:\n        dialog[field + \"Type\"].setCurrentText(\"Variable\")\n        dialog[field + \"Edit\"].setText(str)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.shipTypes","title":"<code>shipTypes() -&gt; List[str]</code>","text":"<p>Return the tuple of ship types.</p>"},{"location":"gui/gui.html#dfastbe.gui.shipTypes--arguments","title":"Arguments","text":"<p>None</p>"},{"location":"gui/gui.html#dfastbe.gui.shipTypes--returns","title":"Returns","text":"<p>types : List[str]     List of three ship types.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def shipTypes() -&gt; List[str]:\n    \"\"\"\n    Return the tuple of ship types.\n\n    Arguments\n    ---------\n    None\n\n    Returns\n    -------\n    types : List[str]\n        List of three ship types.\n    \"\"\"\n    return [\"1 (multiple barge convoy set)\", \"2 (RHK ship / motorship)\", \"3 (towboat)\"]\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.showError","title":"<code>showError(message)</code>","text":"<p>Display an error message box with specified string.</p>"},{"location":"gui/gui.html#dfastbe.gui.showError--arguments","title":"Arguments","text":"<p>message : str     Text to be displayed in the message box.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def showError(message):\n    \"\"\"\n    Display an error message box with specified string.\n\n    Arguments\n    ---------\n    message : str\n        Text to be displayed in the message box.\n    \"\"\"\n    msg = QtWidgets.QMessageBox()\n    msg.setIcon(QtWidgets.QMessageBox.Critical)\n    msg.setText(message)\n    msg.setWindowTitle(\"Error\")\n    msg.setStandardButtons(QtWidgets.QMessageBox.Ok)\n    msg.exec_()\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.typeUpdatePar","title":"<code>typeUpdatePar(key: str) -&gt; None</code>","text":"<p>Implements the dialog setting switching for both general and optional parameters.</p>"},{"location":"gui/gui.html#dfastbe.gui.typeUpdatePar--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def typeUpdatePar(key: str) -&gt; None:\n    \"\"\"\n    Implements the dialog setting switching for both general and optional parameters.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    \"\"\"\n    type = dialog[key + \"Type\"].currentText()\n    dialog[key + \"Edit\"].setText(\"\")\n    if type == \"Use Default\":\n        dialog[key + \"Edit\"].setValidator(None)\n        dialog[key + \"Edit\"].setEnabled(False)\n        dialog[key + \"EditFile\"].setEnabled(False)\n        if key + \"Select\" in dialog.keys():\n            dialog[key + \"Select\"].setEnabled(False)\n    elif type == \"Constant\":\n        if key + \"Select\" in dialog.keys():\n            dialog[key + \"Select\"].setEnabled(True)\n            dialog[key + \"Edit\"].setEnabled(False)\n        else:\n            if key != \"bankProtect\":\n                dialog[key + \"Edit\"].setValidator(validator(\"positive_real\"))\n            dialog[key + \"Edit\"].setEnabled(True)\n        dialog[key + \"EditFile\"].setEnabled(False)\n    elif type == \"Variable\":\n        if key + \"Select\" in dialog.keys():\n            dialog[key + \"Select\"].setEnabled(False)\n        dialog[key + \"Edit\"].setEnabled(True)\n        dialog[key + \"Edit\"].setValidator(None)\n        dialog[key + \"EditFile\"].setEnabled(True)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.updateFilter","title":"<code>updateFilter(key: str) -&gt; None</code>","text":"<p>Implements the dialog setting switching for both general and optional parameters.</p>"},{"location":"gui/gui.html#dfastbe.gui.updateFilter--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def updateFilter(key: str) -&gt; None:\n    \"\"\"\n    Implements the dialog setting switching for both general and optional parameters.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    \"\"\"\n    if dialog[key + \"Active\"].isChecked():\n        dialog[key + \"Width\"].setEnabled(True)\n    else:\n        dialog[key + \"Width\"].setEnabled(False)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.updatePlotting","title":"<code>updatePlotting() -&gt; None</code>","text":"<p>Update the plotting flags.</p>"},{"location":"gui/gui.html#dfastbe.gui.updatePlotting--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def updatePlotting() -&gt; None:\n    \"\"\"\n    Update the plotting flags.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    plotFlag = dialog[\"makePlotsEdit\"].isChecked()\n    dialog[\"savePlots\"].setEnabled(plotFlag)\n    dialog[\"savePlotsEdit\"].setEnabled(plotFlag)\n\n    saveFlag = dialog[\"savePlotsEdit\"].isChecked() and plotFlag\n    dialog[\"saveZoomPlots\"].setEnabled(saveFlag)\n    dialog[\"saveZoomPlotsEdit\"].setEnabled(saveFlag)\n\n    saveZoomFlag = dialog[\"saveZoomPlotsEdit\"].isChecked() and saveFlag\n    dialog[\"zoomPlotsRangeTxt\"].setEnabled(saveZoomFlag)\n    dialog[\"zoomPlotsRangeEdit\"].setEnabled(saveZoomFlag)\n\n    dialog[\"figureDir\"].setEnabled(saveFlag)\n    dialog[\"figureDirEdit\"].setEnabled(saveFlag)\n    dialog[\"figureDirEditFile\"].setEnabled(saveFlag)\n\n    dialog[\"closePlots\"].setEnabled(plotFlag)\n    dialog[\"closePlotsEdit\"].setEnabled(plotFlag)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.updateTabKeys","title":"<code>updateTabKeys(i: int) -&gt; None</code>","text":"<p>Renumber tab i to tab i-1.</p>"},{"location":"gui/gui.html#dfastbe.gui.updateTabKeys--arguments","title":"Arguments","text":"<p>i : str     Number of the tab to be updated.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def updateTabKeys(i: int) -&gt; None:\n    \"\"\"\n    Renumber tab i to tab i-1.\n\n    Arguments\n    ---------\n    i : str\n        Number of the tab to be updated.\n    \"\"\"\n    iStart = str(i) + \"_\"\n    newStart = str(i - 1) + \"_\"\n    N = len(iStart)\n    keys = [key for key in dialog.keys() if key[:N] == iStart]\n    for key in keys:\n        obj = dialog.pop(key)\n        if key[-4:] == \"Type\":\n            obj.currentIndexChanged.disconnect()\n            obj.currentIndexChanged.connect(\n                partial(typeUpdatePar, newStart + key[N:-4])\n            )\n        elif key[-4:] == \"File\":\n            obj.clicked.disconnect()\n            obj.clicked.connect(partial(selectFile, newStart + key[N:-4]))\n        dialog[newStart + key[N:]] = obj\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.validator","title":"<code>validator(validstr: str) -&gt; PyQt5.QtGui.QValidator</code>","text":"<p>Wrapper to easily create a validator.</p>"},{"location":"gui/gui.html#dfastbe.gui.validator--arguments","title":"Arguments","text":"<p>validstr : str     Identifier for the requested validation method.</p>"},{"location":"gui/gui.html#dfastbe.gui.validator--returns","title":"Returns","text":"<p>validator : PyQt5.QtGui.QValidator     Validator for the requested validation method.</p> Source code in <code>src/dfastbe/gui.py</code> <pre><code>def validator(validstr: str) -&gt; PyQt5.QtGui.QValidator:\n    \"\"\"\n    Wrapper to easily create a validator.\n\n    Arguments\n    ---------\n    validstr : str\n        Identifier for the requested validation method.\n\n    Returns\n    -------\n    validator : PyQt5.QtGui.QValidator\n        Validator for the requested validation method.\n    \"\"\"\n    if validstr == \"positive_real\":\n        validator = PyQt5.QtGui.QDoubleValidator()\n        validator.setBottom(0)\n    else:\n        raise Exception(\"Unknown validator type: {}\".format(validstr))\n    return validator\n</code></pre>"},{"location":"guides/contributing.html","title":"Contributing","text":""},{"location":"guides/contributing.html#tooling","title":"Tooling","text":""},{"location":"guides/contributing.html#poetry","title":"Poetry","text":"<p>We use <code>poetry</code> to manage our package and its dependencies. More information on the separate Poetry page.</p>"},{"location":"guides/contributing.html#pytest","title":"Pytest","text":"<p>We use <code>pytest</code> to test our package. Run it with <code>poetry run pytest</code> to test your code changes locally.</p>"},{"location":"guides/contributing.html#black","title":"Black","text":"<p>We use <code>black</code> as an autoformatter. It is also run during CI and will fail if it's not formatted beforehand.</p>"},{"location":"guides/contributing.html#isort","title":"Isort","text":"<p>We use <code>isort</code> as an autoformatter.</p>"},{"location":"guides/contributing.html#commitizen","title":"Commitizen","text":"<ul> <li>We use <code>commitizen</code> to automatically bump the version number.</li> <li>If you use conventional commit messages, the <code>change-log.md</code> is generated automatically. More details below under \"Merging\".</li> </ul>"},{"location":"guides/contributing.html#development","title":"Development","text":""},{"location":"guides/contributing.html#branches","title":"Branches","text":"<p>For each issue or feature, a separate branch should be created from the main. To keep the branches organized each branch should be created with a prefix in the name: * <code>feat/</code> for new features and feature improvements; * <code>fix/</code> for bugfixes; * <code>docs/</code> for documentation; * <code>chore/</code> for tasks, tool changes, configuration work, everything not relevant for external users.</p> <p>After this prefix, preferrably add the issue number, followed by a brief title using underscores. For example: <code>feat/160_obsfile</code> or, <code>fix/197_validation_pump_stages</code>.</p>"},{"location":"guides/contributing.html#pull-requests","title":"Pull requests","text":"<p>When starting development on a branch, a pull request should be created for reviews and continous integration. In the description text area on GitHub, use a closing keyword such that this PR will be automatically linked to the issue. For example: <code>Fixes #160</code>.</p> <p>During continuous integration, the checks will be run with several Python versions on Windows, Ubuntu and MacOS. The checks consist of running the tests, checking the code formatting and running SonarCloud. We advise to use a draft pull request, to prevent the branch to be merged back before developement is finished. When the branch is ready for review, you can update the status of the pull request to \"ready for review\".</p>"},{"location":"guides/contributing.html#reviews","title":"Reviews","text":"<p>When an issue is ready for review, it should be moved to the \"Ready for review\" column on the GitHub board for visibility.</p>"},{"location":"guides/contributing.html#merging","title":"Merging","text":"<p>Merging a branch can only happen when a pull request is accepted through review. When a pull request is accepted the changes should be merged back with the \"squash and merge\" option. The merge commit message should adhere to the conventional commit guidelines. * In the first textfield of the GitHub commit form, use for example: <code>feat: Support 3D timeseries in .bc file</code>, without any PR/issue references. * In the text area of the GitHub commit form, optionally add some more description details on the commit. * In the same text area, add footer line <code>Refs: #&lt;issuenr&gt;</code>, and if needed an extra line <code>BREAKING CHANGE: explanation</code>. Don't forget a blank line between footer lines and the preceding description lines (if present).</p>"},{"location":"guides/contributing.html#coding-guidelines","title":"Coding guidelines","text":"<ul> <li>If there is code that needs to be tested, there should be tests written for it.</li> <li>If there are any additions or changes to the public API, the documentation should be updated.</li> <li>Files should be added to the appropriate folder to keep modules and objects within the correct scope.</li> </ul>"},{"location":"guides/contributing.html#releasing","title":"Releasing","text":""},{"location":"guides/contributing.html#making-a-release-on-github-and-pypi","title":"Making a release on GitHub and PyPi","text":"<p>When we are releasing D-FAST_Bank_Erosion, we want to create a release on GitHub and PyPi. This should only be done by one of the D-FAST_Bank_Erosion maintainers. To prepare for releasing, please make sure you have a clean checkout of the latest <code>main</code> branch and follow these steps:</p> <ul> <li>Go to the root level of your D-FAST_Bank_Erosion checkout location</li> <li>Open your command line in this location</li> <li>Perform the following commands:<ul> <li>If commitizen is not installed yet:  <pre><code>pip install commitizen\n</code></pre></li> <li>Prepare the Changelog before bumping the release version:  <pre><code>cz changelog --unreleased-version=\"0.3.1\" --incremental\n</code></pre>  In the above command, use the version tag instead of the raw version number (so without \"v\" in our case).  If you don't know the version tag yet, you can do a dry-run of the next step, for example via:  <pre><code>cz bump --dry-run --increment PATCH\n</code></pre></li> <li>In the updated <code>docs/mkdocs/change-log.md</code>, manually add links to GitHub PR numbers (or issue numbers) at the     end of each line, if appropriate.      It is recommended to use the macros <code>{{gh_pr(123)}}</code>, resp. <code>{{gh_issue(345)}}</code> to get automatic hyperlinks (where 123 and 345 are GitHub's PR and issue numbers, respectively).</li> <li>Use MAJOR, MINOR or PATCH to increment the version  <pre><code>cz bump --increment {MAJOR,MINOR,PATCH}\n</code></pre></li> <li>Or let commitizen detect the increment automatically  <pre><code>cz bump\n</code></pre></li> <li>Push the tags and changes to git  <pre><code>git push --tags\ngit push\n</code></pre></li> <li>Build the wheels and publish the package to PyPi  <pre><code>poetry build\npoetry publish\n</code></pre>  You will need a PyPI account and permissions for this publish step. Ask a maintainer for help if you need this.</li> </ul> </li> <li>Go to the D-FAST_Bank_Erosion GitHub page.</li> <li>Go to <code>Releases</code> and click on <code>Draft a new release</code>.</li> <li>Fill in the <code>Release title</code> field with <code>Release v&lt;VERSION&gt;</code>, with <code>&lt;VERSION&gt;</code> in the full format <code>&lt;MAJOR&gt;.&lt;MINOR&gt;.&lt;PATCH&gt;</code>, for example <code>Release v0.3.0</code>.</li> <li>Choose the appropriate version tag in the <code>Choose a tag</code> dropdown box (typically <code>&lt;VERSION&gt;</code> without \"v\" prefix).</li> <li>Click on <code>Generate release notes</code>.</li> <li>Click on <code>Publish release</code>.</li> <li>Celebrate </li> </ul>"},{"location":"guides/developer-instructions.html","title":"Developer Instructions","text":"<p>Instructions coding guidelines for contributing to this repository. How to contribute Pre-Commit Hooks: Instructions on setting up and using pre-commit hooks for this repository.</p>"},{"location":"guides/doctest.html","title":"Docstrings and Doctest","text":"<p>Proper documentation is essential for code readability and maintainability. This guide explains how to write docstrings using the Google style and test them using <code>doctest</code>.</p>"},{"location":"guides/doctest.html#1-writing-docstrings-in-google-style","title":"1. Writing Docstrings in Google Style","text":"<p>Google style docstrings are a clean and readable way to document your code. Here is a breakdown of the format:</p>"},{"location":"guides/doctest.html#example-docstring","title":"Example Docstring","text":"<pre><code>def add_numbers(a: int, b: int) -&gt; int:\n    \"\"\"\n    Add two numbers.\n\n    Args:\n        a (int): The first number.\n        b (int): The second number.\n\n    Returns:\n        int: The sum of the two numbers.\n\n    Examples:\n        &gt;&gt;&gt; add_numbers(1, 2)\n        3\n        &gt;&gt;&gt; add_numbers(-1, 5)\n        4\n    \"\"\"\n    return a + b\n</code></pre>"},{"location":"guides/doctest.html#key-sections-of-a-google-style-docstring","title":"Key Sections of a Google Style Docstring","text":"<ol> <li>Summary: A short description of the function.</li> <li>Args: A list of all parameters with their types and descriptions.</li> <li>Returns: A description of the return value(s).</li> <li>Raises (optional): A list of exceptions the function may raise.</li> <li>Examples: Code examples demonstrating how to use the function.</li> </ol>"},{"location":"guides/doctest.html#additional-notes","title":"Additional Notes","text":"<ul> <li>Use <code>\"\"\"</code> for multi-line docstrings.</li> <li>Align descriptions for readability.</li> <li>Keep the summary concise and to the point.</li> </ul>"},{"location":"guides/doctest.html#2-testing-docstrings-with-doctest","title":"2. Testing Docstrings with Doctest","text":"<p><code>doctest</code> allows you to test the examples provided in your docstrings.</p>"},{"location":"guides/doctest.html#running-doctests","title":"Running Doctests","text":"<ol> <li>Save your code with properly formatted docstrings.</li> <li>Use the following command to run <code>doctest</code>:</li> </ol> <pre><code>python -m doctest -v your_script.py\n</code></pre> <p>The <code>-v</code> flag provides verbose output, showing which tests passed or failed.</p>"},{"location":"guides/doctest.html#example-script-with-doctest","title":"Example Script with Doctest","text":"<pre><code>def multiply_numbers(a: int, b: int) -&gt; int:\n    \"\"\"\n    Multiply two numbers.\n\n    Args:\n        a (int): The first number.\n        b (int): The second number.\n\n    Returns:\n        int: The product of the two numbers.\n\n    Examples:\n        &gt;&gt;&gt; multiply_numbers(2, 3)\n        6\n        &gt;&gt;&gt; multiply_numbers(-1, 5)\n        -5\n        &gt;&gt;&gt; multiply_numbers(0, 10)\n        0\n    \"\"\"\n    return a * b\n</code></pre>"},{"location":"guides/doctest.html#common-commands","title":"Common Commands","text":"<ul> <li>Run all tests: Run the script with doctest as shown above.</li> <li>Check specific failures: Look at the detailed output to understand why a test failed.</li> </ul>"},{"location":"guides/doctest.html#3-debugging-and-troubleshooting","title":"3. Debugging and Troubleshooting","text":"<ol> <li>Ensure your examples in the docstring match the actual output exactly (including whitespace).</li> <li>Use the <code># doctest: +SKIP</code> directive to skip examples that should not be tested:</li> </ol> <pre><code>&gt;&gt;&gt; some_function()  # doctest: +SKIP\n</code></pre> <ol> <li>If you encounter issues with floating-point numbers, use the <code># doctest: +ELLIPSIS</code> directive to allow partial matching:</li> </ol> <pre><code>&gt;&gt;&gt; divide_numbers(1, 3)\n0.333...  # doctest: +ELLIPSIS\n</code></pre>"},{"location":"guides/doctest.html#4-best-practices","title":"4. Best Practices","text":"<ul> <li>Write examples for edge cases (e.g., zero, negative numbers, large inputs).</li> <li>Ensure all public functions, methods, and classes have docstrings.</li> <li>Regularly run <code>doctest</code> to ensure your examples remain up to date.</li> </ul>"},{"location":"guides/doctest.html#5-additional-resources","title":"5. Additional Resources","text":"<ul> <li>Google Python Style Guide: Docstrings</li> <li>Python Doctest Documentation</li> </ul> <p>By following these guidelines, you can ensure your code is both well-documented and well-tested. Thank you for contributing!</p>"},{"location":"guides/documentation.html","title":"Documentation","text":"<p>We use MKdocs for documentation. For full documentation visit mkdocs.org.</p> <p>The documentation itself is written with https://documentation.divio.com/ structure in mind, creating different categories: - Guides - Tutorials - Reference - Topics</p>"},{"location":"guides/documentation.html#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"guides/documentation.html#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"guides/poetry.html","title":"Installation using Poetry","text":"<p>You can use a Poetry-based installation if you are using D-FAST_Bank_Erosion from a local clone of the Github repository, for example if you intend to contribute to the code.</p>"},{"location":"guides/poetry.html#clone-the-github-repo","title":"Clone the GitHub repo","text":"<p>Use your own preferred way of cloning the GitHub repository of D-FAST_Bank_Erosion. In the examples below it is placed in <code>C:\\checkouts\\D-FAST_Bank_Erosion_git</code>.</p>"},{"location":"guides/poetry.html#use-poetry-to-install-d-fast_bank_erosion","title":"Use Poetry to install D-FAST_Bank_Erosion","text":"<p>We use <code>poetry</code> to manage our package and its dependencies.</p> <p>Note</p> <p>If you use <code>conda</code>, do not combine conda virtual environments with the poetry virtual environment. In other words, run the <code>poetry install</code> command from the <code>base</code> conda environment.</p> <ol> <li>Download + installation instructions for Poetry are here.</li> <li> <p>After installation of Poetry itself, now use it to install your local clone of the D-FAST_Bank_Erosion package, as follows.    Make sure Poetry is available on your <code>PATH</code> and run <code>poetry install</code> in the D-FAST_Bank_Erosion directory in your shell of choice.    This will create a virtual environment in which D-FAST_Bank_Erosion is installed and made available for use in your own scripts.    For example in an Anaconda PowerShell: <pre><code>(base) PS C:\\checkouts\\D-FAST_Bank_Erosion_git&gt; poetry install\nCreating virtualenv D-FAST_Bank_Erosion-kHkQBdtS-py3.8 in C:\\Users\\dam_ar\\AppData\\Local\\pypoetry\\Cache\\virtualenvs\nInstalling dependencies from lock file\n\nPackage operations: 67 installs, 0 updates, 0 removals\n\n  * Installing six (1.16.0)\n[..]\nInstalling the current project: D-FAST_Bank_Erosion (0.1.5)\n(base) PS C:\\checkouts\\D-FAST_Bank_Erosion_git&gt;\n</code></pre>    If you need to use an already existing Python installation, you can activate it and run <code>poetry env use system</code> before <code>poetry install</code>.</p> </li> <li> <p>Test your installation, by running the D-FAST_Bank_Erosion pytest suite via poetry: <pre><code>(base) PS C:\\checkouts\\D-FAST_Bank_Erosion_git&gt; poetry run pytest\n===================================== test session starts ======================================\nplatform win32 -- Python 3.8.8, pytest-6.2.5, py-1.10.0, pluggy-1.0.0\nrootdir: C:\\checkouts\\D-FAST_Bank_Erosion_git, configfile: pyproject.toml\nplugins: cov-2.12.1\ncollected 473 items / 2 deselected / 471 selected\n\ntests\\io\\dflowfm\\ini\\test_ini.py ........................................................ [  3%]\ntests\\io\\dflowfm\\test_bc.py ....                                                          [  4%]\ntests\\io\\dflowfm\\test_ext.py ........................................................     [  5%]\ntests\\io\\dflowfm\\test_fnm.py ..................                                           [ 11%]\ntests\\io\\dflowfm\\test_net.py ............                                                 [ 11%]\ntests\\io\\dflowfm\\test_parser.py .                                                         [ 12%]\ntests\\io\\dflowfm\\test_polyfile.py ........................................................[ 23%]\n....................................                                                      [ 27%]\ntests\\io\\dflowfm\\test_structure.py .......................................................[ 42%]\n.........................................................                                 [ 54%]\ntests\\io\\dimr\\test_dimr.py ...                                                            [ 56%]\ntests\\io\\rr\\meteo\\test_bui.py ...........................                                 [ 57%]\ntests\\io\\test_docker.py .                                                                 [ 70%]\ntests\\test_model.py ...............                                                       [ 78%]\ntests\\test_utils.py .......                                                               [ 91%]\n.........................................                                                 [100%]\n\n============================== 471 passed, 2 deselected in 3.50s ===============================\n(base) PS C:\\checkouts\\D-FAST_Bank_Erosion_git&gt;\n</code></pre></p> </li> <li>Start using D-FAST_Bank_Erosion. You can launch your favourite editor (for example VS Code) by first starting a poetry shell with the virtual D-FAST_Bank_Erosion environment: <pre><code>(base) PS C:\\checkouts\\D-FAST_Bank_Erosion_git&gt; poetry shell\n(base) PS C:\\checkouts\\D-FAST_Bank_Erosion_git&gt; code\n</code></pre></li> </ol>"},{"location":"guides/poetry.html#switching-between-python-versions","title":"Switching Between Python Versions","text":"<p>If you need to switch between Python versions (e.g., from Python 3.9 to Python 3.10), you can configure Poetry to use a specific Python version. Follow these steps:</p> <ol> <li> <p>Verify python version in <code>pyproject.toml</code>: The <code>pyproject.toml</code> specifies which python version is supported. Please verify that the python version you wish to use is supported. For example, the following configuration: <pre><code>[tool.poetry.dependencies]\npython = \"~3.10\"\n</code></pre> It Indicates that the project supports Python 3.10 with any minor version (e.g., 3.10.1, 3.10.2, etc.).</p> </li> <li> <p>Check Installed Python Versions: Ensure that the desired Python version (e.g., Python 3.10) is installed on your system.  You can check the available versions by running: on windows: <pre><code>python --version\n</code></pre> or on Linux: <pre><code>python3 --version \n</code></pre></p> </li> <li> <p>Set the Python Version for Poetry: Use the <code>poetry env use</code> command to specify the Python version for your project. For example: <code>poetry env use python3.10</code>. This will create a new virtual environment using Python 3.10.</p> </li> <li> <p>Verify the Python Version: After setting the Python version, verify that Poetry is using the correct version: <code>poetry run python --version</code>. The output should show Python 3.10.</p> </li> <li> <p>Reinstall Dependencies: If you switch Python versions, you may need to reinstall your dependencies. Run: <code>poetry install</code>.</p> </li> <li> <p>Test the Installation: Run the test suite to ensure everything works correctly with the new Python version:  <code>poetry run pytest</code>.</p> </li> </ol>"},{"location":"guides/pre-commit-hooks.html","title":"Pre-Commit Hooks","text":"<p>The pre-commit hooks tool is integrated into this repository to automate code quality checks, formatting, and validation before committing changes. These hooks enforce consistency and ensure that only well-validated code is committed, improving overall codebase quality.</p>"},{"location":"guides/pre-commit-hooks.html#features-of-pre-commit-hooks","title":"Features of Pre-Commit Hooks","text":"<ul> <li>Automated Validation: Validates file formats, YAML/JSON structure, and checks for large files or trailing whitespace.</li> <li>Code Formatting: Automatically formats Python code using <code>black</code> and organizes imports with <code>isort</code>.</li> <li>Static Analysis: Enforces linting rules using <code>flake8</code> and additional plugins for advanced checks.</li> <li>Security Checks: Detects private keys and merge conflicts in committed code.</li> <li>Test Integration: Runs <code>pytest</code> for code and documentation tests, ensuring no regression in functionality.</li> </ul>"},{"location":"guides/pre-commit-hooks.html#configured-hooks","title":"Configured Hooks","text":"<p>Some of the key hooks configured for this repository include: - File Formatting and Cleanup:     - Trim trailing whitespace.     - Fix file encodings.     - Validate YAML and JSON files. - Code Linting and Formatting:     - <code>black</code> for consistent Python code style.     - <code>isort</code> for sorting imports.     - <code>flake8</code> for linting. - Testing:     - Runs unit tests and checks coverage using <code>pytest</code>.     - Validates Jupyter notebooks (<code>nbval</code>).     - Ensures all Python docstrings follow conventions (<code>doctest</code>). - Git and Metadata Checks:     - Ensures commits are not directly made to protected branches (e.g., <code>main</code>).     - Verifies commit messages are well-formed.</p>"},{"location":"guides/pre-commit-hooks.html#how-to-use-pre-commit-hooks","title":"How to Use Pre-Commit Hooks","text":"<p>Pre-commit hooks are an excellent way to ensure code quality and consistency before committing changes to the repository. This guide explains how to set up and use pre-commit hooks for this repository.</p>"},{"location":"guides/pre-commit-hooks.html#1-install-pre-commit","title":"1. Install Pre-Commit","text":"<p>Before you begin, ensure you have Python installed on your system. all the necessary packages for pre-commit hooks to work are listed as a separate dependency group in the pyproject.toml <code>pre-commit</code>. Follow these steps to install pre-commit:</p> <pre><code>poetry install --with pre-commit\n</code></pre>"},{"location":"guides/pre-commit-hooks.html#2-install-git-and-clone-the-repository","title":"2. Install Git and Clone the Repository","text":"<p>Ensure that Git is installed on your system. Then, clone the repository:</p> <pre><code>git clone &lt;repository_url&gt;\ncd &lt;repository_name&gt;\n</code></pre>"},{"location":"guides/pre-commit-hooks.html#3-install-pre-commit-hooks","title":"3. Install Pre-Commit Hooks","text":"<p>To set up the pre-commit hooks defined in the repository's configuration file:</p> <pre><code>pre-commit install\n</code></pre> <p>This command installs the hooks so they run automatically every time you create a commit.</p>"},{"location":"guides/pre-commit-hooks.html#4-run-pre-commit-hooks-manually-optional","title":"4. Run Pre-Commit Hooks Manually (Optional)","text":"<p>You can also run the pre-commit hooks manually to test your changes before committing:</p> <pre><code>pre-commit run --all-files\n</code></pre> <p>This will run all the hooks against the files in the repository.</p>"},{"location":"guides/pre-commit-hooks.html#5-configure-the-pre-commit-hooks","title":"5. Configure the Pre-Commit Hooks","text":"<p>The repository includes a <code>.pre-commit-config.yaml</code> file, which defines the hooks to be executed. If you need to modify the hooks, edit this file and reinstall the hooks:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"guides/pre-commit-hooks.html#example-pre-commit-configyaml-file","title":"Example <code>.pre-commit-config.yaml</code> File","text":"<p>Here is an example configuration file for common hooks:</p> <pre><code>repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.4.0  # Use the latest stable version\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n      - id: check-yaml\n      - id: check-added-large-files\n  - repo: https://github.com/psf/black\n    rev: 23.1.0\n    hooks:\n      - id: black\n  - repo: https://github.com/pycqa/flake8\n    rev: 6.1.0\n    hooks:\n      - id: flake8\n</code></pre>"},{"location":"guides/pre-commit-hooks.html#6-debugging-and-troubleshooting","title":"6. Debugging and Troubleshooting","text":"<p>If you encounter issues with pre-commit hooks:</p> <ol> <li>Ensure all dependencies required by the hooks are installed.</li> <li>Use the <code>--verbose</code> flag to get detailed output:</li> </ol> <p><pre><code>pre-commit run --all-files --verbose\n</code></pre> 3. Check the official documentation for each specific hook if errors persist.</p>"},{"location":"guides/pre-commit-hooks.html#7-best-practices","title":"7. Best Practices","text":"<ul> <li>Always run the hooks manually if you suspect your changes may not comply with repository standards.</li> <li>Avoid skipping hooks unless absolutely necessary. If skipping is required, use the following command to bypass hooks:</li> </ul> <pre><code>git commit --no-verify\n</code></pre> <ul> <li>Periodically update the hooks by running:</li> </ul> <pre><code>pre-commit autoupdate\n</code></pre>"},{"location":"guides/pre-commit-hooks.html#8-uninstall-hooks","title":"8. Uninstall Hooks:","text":"<ul> <li>To remove pre-commit hooks from your repository, run:</li> </ul> <p><pre><code>pre-commit uninstall\n</code></pre>    This will remove the hooks from the repository.</p>"},{"location":"guides/pre-commit-hooks.html#9-additional-resources","title":"9. Additional Resources","text":"<ul> <li>Pre-Commit Documentation</li> <li>Available Hooks</li> </ul> <p>By following these guidelines, you'll help maintain a clean, consistent, and high-quality codebase. Thank you for contributing!</p>"},{"location":"guides/testing.html","title":"Naming conventions","text":""},{"location":"guides/testing.html#test-files","title":"Test Files","text":"<ul> <li>all test files should start with <code>test_</code>, and use snake case naming convention (i.e. <code>test_my_functionality.py</code>).</li> </ul>"},{"location":"guides/testing.html#test-functions","title":"Test Functions","text":"<ul> <li>all test functions should start with <code>test_</code>, and use snake case naming convention. <pre><code>def test_my_functionality():\n    # Test code here\n    pass\n</code></pre></li> </ul>"},{"location":"guides/testing.html#test-classes","title":"Test Classes","text":"<ul> <li>all test classes should start with <code>Test</code>, and use CamelCase naming convention. <pre><code>class TestMyFunctionality:\n    def test_my_functionality(self):\n        # Test code here\n        pass\n</code></pre></li> </ul>"},{"location":"guides/testing.html#binaries","title":"Binaries","text":""},{"location":"guides/testing.html#creating-tests-for-the-binaries","title":"Creating tests for the binaries","text":"<ul> <li>all tests that are using the binaries are located in <code>tests/test_binaries</code>.</li> <li>The binaries are being built in teamcity in the following directory <pre><code>from pathlib import Path\nrepo_root = Path(__file__).resolve().parent.parent.parent\nexe_path = repo_root / \"dfastbe.dist/dfastbe.exe\"\n</code></pre></li> <li>Use the above path to trigger the binaries in any test.</li> <li>any test in the <code>tests/test_binaries</code> directory have to be marked with the following pytest marker. <pre><code>import pytest\n@pytest.mark.binaries\ndef test_my_functionality():\n    # Test code here\n    pass\n</code></pre></li> </ul>"},{"location":"guides/testing.html#teamcity-pipelines","title":"Teamcity Pipelines","text":"<p>The team city pipelines have hard coded steps that locate the dfast built binaries, and also hard coded steps to trigger the tests. This is a work in progress. - The build step that triggers testing the binaries uses the following command <pre><code>pytest -v tests/test_binaries/ --no-cov\n</code></pre> - While the unit tests pipeline uses the <code>binaries</code> pytest marker to not run the tests that uses the binaries. - So not marking any binary test with the <code>binaries</code> marker will break the unit tests pipeline. <pre><code>pytest --junitxml=\"report.xml\" --cov=%COVERAGE_LOC% --cov-report=xml tests/ -m \"not binaries\"\n</code></pre></p>"}]}