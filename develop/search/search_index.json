{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"D-FAST Bank Erosion","text":"<p>This is one of the Deltares Fluvial Assessment Tools to be used in conjunction with D-Flow FM. The purpose of this particular tool is * to compute local bank erosion sensitivity, and * to give an estimate of the amount of bank material that will be eroded     * during the first year, and     * until equilibrium.</p> <p>The user should carry out a number of steady state hydrodynamic simulations for different discharges using D-Flow FM. The results of these simulations will be combined with some basic morphological characteristics to estimate the bank erosion. For more details see the documentation section.</p>"},{"location":"index.html#license","title":"License","text":"<p>This software is distributed under the terms of the GNU Lesser General Public License Version 2.1. See the license file for details.</p>"},{"location":"change-log.html","title":"Release Notes","text":""},{"location":"change-log.html#231-2025-01-","title":"2.3.1 (2025-01-**)","text":""},{"location":"change-log.html#initial-design","title":"Initial Design","text":"<ul> <li>Initial design of the core library</li> </ul>"},{"location":"license.html","title":"License","text":""},{"location":"license.html#gnu-lesser-general-public-license","title":"GNU LESSER GENERAL PUBLIC LICENSE","text":"<p>Version 2.1, February 1999</p> <pre><code>Copyright (C) 1991, 1999 Free Software Foundation, Inc.\n51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nEveryone is permitted to copy and distribute verbatim copies\nof this license document, but changing it is not allowed.\n\n[This is the first released version of the Lesser GPL.  It also counts\n as the successor of the GNU Library Public License, version 2, hence\n the version number 2.1.]\n</code></pre>"},{"location":"license.html#preamble","title":"Preamble","text":"<p>The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public Licenses are intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users.</p> <p>This license, the Lesser General Public License, applies to some specially designated software packages--typically libraries--of the Free Software Foundation and other authors who decide to use it. You can use it too, but we suggest you first think carefully about whether this license or the ordinary General Public License is the better strategy to use in any particular case, based on the explanations below.</p> <p>When we speak of free software, we are referring to freedom of use, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish); that you receive source code or can get it if you want it; that you can change the software and use pieces of it in new free programs; and that you are informed that you can do these things.</p> <p>To protect your rights, we need to make restrictions that forbid distributors to deny you these rights or to ask you to surrender these rights. These restrictions translate to certain responsibilities for you if you distribute copies of the library or if you modify it.</p> <p>For example, if you distribute copies of the library, whether gratis or for a fee, you must give the recipients all the rights that we gave you. You must make sure that they, too, receive or can get the source code. If you link other code with the library, you must provide complete object files to the recipients, so that they can relink them with the library after making changes to the library and recompiling it. And you must show them these terms so they know their rights.</p> <p>We protect your rights with a two-step method: (1) we copyright the library, and (2) we offer you this license, which gives you legal permission to copy, distribute and/or modify the library.</p> <p>To protect each distributor, we want to make it very clear that there is no warranty for the free library. Also, if the library is modified by someone else and passed on, the recipients should know that what they have is not the original version, so that the original author's reputation will not be affected by problems that might be introduced by others.</p> <p>Finally, software patents pose a constant threat to the existence of any free program. We wish to make sure that a company cannot effectively restrict the users of a free program by obtaining a restrictive license from a patent holder. Therefore, we insist that any patent license obtained for a version of the library must be consistent with the full freedom of use specified in this license.</p> <p>Most GNU software, including some libraries, is covered by the ordinary GNU General Public License. This license, the GNU Lesser General Public License, applies to certain designated libraries, and is quite different from the ordinary General Public License. We use this license for certain libraries in order to permit linking those libraries into non-free programs.</p> <p>When a program is linked with a library, whether statically or using a shared library, the combination of the two is legally speaking a combined work, a derivative of the original library. The ordinary General Public License therefore permits such linking only if the entire combination fits its criteria of freedom. The Lesser General Public License permits more lax criteria for linking other code with the library.</p> <p>We call this license the \"Lesser\" General Public License because it does Less to protect the user's freedom than the ordinary General Public License. It also provides other free software developers Less of an advantage over competing non-free programs. These disadvantages are the reason we use the ordinary General Public License for many libraries. However, the Lesser license provides advantages in certain special circumstances.</p> <p>For example, on rare occasions, there may be a special need to encourage the widest possible use of a certain library, so that it becomes a de-facto standard. To achieve this, non-free programs must be allowed to use the library. A more frequent case is that a free library does the same job as widely used non-free libraries. In this case, there is little to gain by limiting the free library to free software only, so we use the Lesser General Public License.</p> <p>In other cases, permission to use a particular library in non-free programs enables a greater number of people to use a large body of free software. For example, permission to use the GNU C Library in non-free programs enables many more people to use the whole GNU operating system, as well as its variant, the GNU/Linux operating system.</p> <p>Although the Lesser General Public License is Less protective of the users' freedom, it does ensure that the user of a program that is linked with the Library has the freedom and the wherewithal to run that program using a modified version of the Library.</p> <p>The precise terms and conditions for copying, distribution and modification follow. Pay close attention to the difference between a \"work based on the library\" and a \"work that uses the library\". The former contains code derived from the library, whereas the latter must be combined with the library in order to run.</p>"},{"location":"license.html#terms-and-conditions-for-copying-distribution-and-modification","title":"TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION","text":"<p>0. This License Agreement applies to any software library or other program which contains a notice placed by the copyright holder or other authorized party saying it may be distributed under the terms of this Lesser General Public License (also called \"this License\"). Each licensee is addressed as \"you\".</p> <p>A \"library\" means a collection of software functions and/or data prepared so as to be conveniently linked with application programs (which use some of those functions and data) to form executables.</p> <p>The \"Library\", below, refers to any such software library or work which has been distributed under these terms. A \"work based on the Library\" means either the Library or any derivative work under copyright law: that is to say, a work containing the Library or a portion of it, either verbatim or with modifications and/or translated straightforwardly into another language. (Hereinafter, translation is included without limitation in the term \"modification\".)</p> <p>\"Source code\" for a work means the preferred form of the work for making modifications to it. For a library, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the library.</p> <p>Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running a program using the Library is not restricted, and output from such a program is covered only if its contents constitute a work based on the Library (independent of the use of the Library in a tool for writing it). Whether that is true depends on what the Library does and what the program that uses the Library does.</p> <p>1. You may copy and distribute verbatim copies of the Library's complete source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and distribute a copy of this License along with the Library.</p> <p>You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee.</p> <p>2. You may modify your copy or copies of the Library or any portion of it, thus forming a work based on the Library, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions:</p> <ul> <li>a) The modified work must itself be a software library.</li> <li>b) You must cause the files modified to carry prominent     notices stating that you changed the files and the date of     any change.</li> <li>c) You must cause the whole of the work to be licensed at no     charge to all third parties under the terms of this License.</li> <li> <p>d) If a facility in the modified Library refers to a function     or a table of data to be supplied by an application program that     uses the facility, other than as an argument passed when the     facility is invoked, then you must make a good faith effort to     ensure that, in the event an application does not supply such     function or table, the facility still operates, and performs     whatever part of its purpose remains meaningful.</p> <p>(For example, a function in a library to compute square roots has a purpose that is entirely well-defined independent of the application. Therefore, Subsection 2d requires that any application-supplied function or table used by this function must be optional: if the application does not supply it, the square root function must still compute square roots.)</p> </li> </ul> <p>These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Library, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Library, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it.</p> <p>Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Library.</p> <p>In addition, mere aggregation of another work not based on the Library with the Library (or with a work based on the Library) on a volume of a storage or distribution medium does not bring the other work under the scope of this License.</p> <p>3. You may opt to apply the terms of the ordinary GNU General Public License instead of this License to a given copy of the Library. To do this, you must alter all the notices that refer to this License, so that they refer to the ordinary GNU General Public License, version 2, instead of to this License. (If a newer version than version 2 of the ordinary GNU General Public License has appeared, then you can specify that version instead if you wish.) Do not make any other change in these notices.</p> <p>Once this change is made in a given copy, it is irreversible for that copy, so the ordinary GNU General Public License applies to all subsequent copies and derivative works made from that copy.</p> <p>This option is useful when you wish to copy part of the code of the Library into a program that is not a library.</p> <p>4. You may copy and distribute the Library (or a portion or derivative of it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange.</p> <p>If distribution of object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place satisfies the requirement to distribute the source code, even though third parties are not compelled to copy the source along with the object code.</p> <p>5. A program that contains no derivative of any portion of the Library, but is designed to work with the Library by being compiled or linked with it, is called a \"work that uses the Library\". Such a work, in isolation, is not a derivative work of the Library, and therefore falls outside the scope of this License.</p> <p>However, linking a \"work that uses the Library\" with the Library creates an executable that is a derivative of the Library (because it contains portions of the Library), rather than a \"work that uses the library\". The executable is therefore covered by this License. Section 6 states terms for distribution of such executables.</p> <p>When a \"work that uses the Library\" uses material from a header file that is part of the Library, the object code for the work may be a derivative work of the Library even though the source code is not. Whether this is true is especially significant if the work can be linked without the Library, or if the work is itself a library. The threshold for this to be true is not precisely defined by law.</p> <p>If such an object file uses only numerical parameters, data structure layouts and accessors, and small macros and small inline functions (ten lines or less in length), then the use of the object file is unrestricted, regardless of whether it is legally a derivative work. (Executables containing this object code plus portions of the Library will still fall under Section 6.)</p> <p>Otherwise, if the work is a derivative of the Library, you may distribute the object code for the work under the terms of Section 6. Any executables containing that work also fall under Section 6, whether or not they are linked directly with the Library itself.</p> <p>6. As an exception to the Sections above, you may also combine or link a \"work that uses the Library\" with the Library to produce a work containing portions of the Library, and distribute that work under terms of your choice, provided that the terms permit modification of the work for the customer's own use and reverse engineering for debugging such modifications.</p> <p>You must give prominent notice with each copy of the work that the Library is used in it and that the Library and its use are covered by this License. You must supply a copy of this License. If the work during execution displays copyright notices, you must include the copyright notice for the Library among them, as well as a reference directing the user to the copy of this License. Also, you must do one of these things:</p> <ul> <li>a) Accompany the work with the complete corresponding     machine-readable source code for the Library including whatever     changes were used in the work (which must be distributed under     Sections 1 and 2 above); and, if the work is an executable linked     with the Library, with the complete machine-readable \"work that     uses the Library\", as object code and/or source code, so that the     user can modify the Library and then relink to produce a modified     executable containing the modified Library. (It is understood that     the user who changes the contents of definitions files in the     Library will not necessarily be able to recompile the application     to use the modified definitions.)</li> <li>b) Use a suitable shared library mechanism for linking with     the Library. A suitable mechanism is one that (1) uses at run time     a copy of the library already present on the user's computer     system, rather than copying library functions into the executable,     and (2) will operate properly with a modified version of the     library, if the user installs one, as long as the modified version     is interface-compatible with the version that the work was     made with.</li> <li>c) Accompany the work with a written offer, valid for at least     three years, to give the same user the materials specified in     Subsection 6a, above, for a charge no more than the cost of     performing this distribution.</li> <li>d) If distribution of the work is made by offering access to     copy from a designated place, offer equivalent access to copy the     above specified materials from the same place.</li> <li>e) Verify that the user has already received a copy of these     materials or that you have already sent this user a copy.</li> </ul> <p>For an executable, the required form of the \"work that uses the Library\" must include any data and utility programs needed for reproducing the executable from it. However, as a special exception, the materials to be distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable.</p> <p>It may happen that this requirement contradicts the license restrictions of other proprietary libraries that do not normally accompany the operating system. Such a contradiction means you cannot use both them and the Library together in an executable that you distribute.</p> <p>7. You may place library facilities that are a work based on the Library side-by-side in a single library together with other library facilities not covered by this License, and distribute such a combined library, provided that the separate distribution of the work based on the Library and of the other library facilities is otherwise permitted, and provided that you do these two things:</p> <ul> <li>a) Accompany the combined library with a copy of the same work     based on the Library, uncombined with any other     library facilities. This must be distributed under the terms of     the Sections above.</li> <li>b) Give prominent notice with the combined library of the fact     that part of it is a work based on the Library, and explaining     where to find the accompanying uncombined form of the same work.</li> </ul> <p>8. You may not copy, modify, sublicense, link with, or distribute the Library except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, link with, or distribute the Library is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance.</p> <p>9. You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Library or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Library (or any work based on the Library), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Library or works based on it.</p> <p>10. Each time you redistribute the Library (or any work based on the Library), the recipient automatically receives a license from the original licensor to copy, distribute, link with or modify the Library subject to these terms and conditions. You may not impose any further restrictions on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties with this License.</p> <p>11. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Library at all. For example, if a patent license would not permit royalty-free redistribution of the Library by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Library.</p> <p>If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply, and the section as a whole is intended to apply in other circumstances.</p> <p>It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice.</p> <p>This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License.</p> <p>12. If the distribution and/or use of the Library is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Library under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License.</p> <p>13. The Free Software Foundation may publish revised and/or new versions of the Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.</p> <p>Each version is given a distinguishing version number. If the Library specifies a version number of this License which applies to it and \"any later version\", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Library does not specify a license version number, you may choose any version ever published by the Free Software Foundation.</p> <p>14. If you wish to incorporate parts of the Library into other free programs whose distribution conditions are incompatible with these, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally.</p> <p>NO WARRANTY</p> <p>15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE LIBRARY \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE LIBRARY IS WITH YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</p> <p>16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p>"},{"location":"license.html#end-of-terms-and-conditions","title":"END OF TERMS AND CONDITIONS","text":""},{"location":"license.html#how-to-apply-these-terms-to-your-new-libraries","title":"How to Apply These Terms to Your New Libraries","text":"<p>If you develop a new library, and you want it to be of the greatest possible use to the public, we recommend making it free software that everyone can redistribute and change. You can do so by permitting redistribution under these terms (or, alternatively, under the terms of the ordinary General Public License).</p> <p>To apply these terms, attach the following notices to the library. It is safest to attach them to the start of each source file to most effectively convey the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found.</p> <pre><code>one line to give the library's name and an idea of what it does.\nCopyright (C) year  name of author\n\nThis library is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense as published by the Free Software Foundation; either\nversion 2.1 of the License, or (at your option) any later version.\n\nThis library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public\nLicense along with this library; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n</code></pre> <p>Also add information on how to contact you by electronic and paper mail.</p> <p>You should also get your employer (if you work as a programmer) or your school, if any, to sign a \"copyright disclaimer\" for the library, if necessary. Here is a sample; alter the names:</p> <pre><code>Yoyodyne, Inc., hereby disclaims all copyright interest in\nthe library `Frob' (a library for tweaking knobs) written\nby James Random Hacker.\n\nsignature of Ty Coon, 1 April 1990\nTy Coon, President of Vice\n</code></pre> <p>That's all there is to it!</p>"},{"location":"api/io.html","title":"I/O Module","text":"<p>The I/O module is responsible for handling input/output operations in the D-FAST Bank Erosion software. It provides functionality for reading configuration files, loading and saving data, and logging.</p>"},{"location":"api/io.html#overview","title":"Overview","text":"<p>The I/O module serves as the interface between the D-FAST Bank Erosion software and external data sources and destinations. It handles reading configuration files, loading hydrodynamic simulation results, saving bank lines and erosion results, and logging information during the execution of the software.</p>"},{"location":"api/io.html#components","title":"Components","text":"<p>The I/O module consists of the following components:</p>"},{"location":"api/io.html#configuration","title":"Configuration","text":"<p>The configuration component handles reading and parsing configuration files, which specify parameters for bank line detection and erosion calculation.</p>"},{"location":"api/io.html#dfastbe.io.config","title":"<code>dfastbe.io.config</code>","text":"<p>Copyright (C) 2025 Stichting Deltares.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation version 2.1.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, see http://www.gnu.org/licenses/.</p> <p>contact: delft3d.support@deltares.nl Stichting Deltares P.O. Box 177 2600 MH Delft, The Netherlands</p> <p>All indications and logos of, and references to, \"Delft3D\" and \"Deltares\" are registered trademarks of Stichting Deltares, and remain the property of Stichting Deltares. All rights reserved.</p> <p>INFORMATION This file is part of D-FAST Bank Erosion: https://github.com/Deltares/D-FAST_Bank_Erosion</p>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile","title":"<code>ConfigFile</code>","text":"<p>Class to read configuration files for D-FAST Bank Erosion.</p> <p>This class provides methods to read, write, and manage configuration files for the D-FAST Bank Erosion analysis. It also allows access to configuration settings and supports upgrading older configuration formats.</p> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>class ConfigFile:\n    \"\"\"Class to read configuration files for D-FAST Bank Erosion.\n\n    This class provides methods to read, write, and manage configuration files\n    for the D-FAST Bank Erosion analysis. It also allows access to configuration\n    settings and supports upgrading older configuration formats.\n    \"\"\"\n\n    def __init__(self, config: ConfigParser, path: Union[Path, str] = None):\n        \"\"\"\n        Initialize the ConfigFile object.\n\n        Args:\n            config (ConfigParser):\n                Settings for the D-FAST Bank Erosion analysis.\n            path (Union[Path, str]):\n                Path to the configuration file.\n\n        Examples:\n            Reading a configuration file:\n                ```python\n                &gt;&gt;&gt; import tempfile\n                &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n                &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n                &gt;&gt;&gt; print(config_file.config[\"General\"][\"Version\"])\n                1.0\n\n                ```\n            Writing a configuration file:\n                ```python\n                &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n                &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n                &gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdirname:\n                ...     config_file.write(f\"{tmpdirname}/meuse_manual_out.cfg\")\n\n                ```\n        \"\"\"\n        self._config = config\n        self.crs = \"EPSG:28992\"\n        if path:\n            self.path = Path(path)\n            self.root_dir = self.path.parent\n            self.make_paths_absolute()\n        self.log_data = LogData()\n\n    @property\n    def config(self) -&gt; ConfigParser:\n        \"\"\"ConfigParser: Get the configuration settings.\"\"\"\n        return self._config\n\n    @config.setter\n    def config(self, value: ConfigParser):\n        self._config = value\n\n    @property\n    def version(self) -&gt; str:\n        \"\"\"str: Get the version of the configuration file.\"\"\"\n        return self.get_str(\"General\", \"Version\")\n\n    @property\n    def debug(self) -&gt; bool:\n        \"\"\"bool: Get the debug flag.\"\"\"\n        return self.get_bool(\"General\", \"DebugOutput\", False)\n\n    @property\n    def root_dir(self) -&gt; Path | str:\n        \"\"\"Path: Get the root directory of the configuration file.\"\"\"\n        return self._root_dir\n\n    @root_dir.setter\n    def root_dir(self, value: str):\n        self._root_dir = value\n\n    @classmethod\n    def read(cls, path: Union[str, Path]) -&gt; \"ConfigFile\":\n        \"\"\"Read a configParser object (configuration file).\n\n        Reads the config file using the standard `configparser`. Falls back to a\n        dedicated reader compatible with old waqbank files.\n\n        Args:\n            path (Union[str, Path]): Path to the configuration file.\n\n        Returns:\n            ConfigFile: Settings for the D-FAST Bank Erosion analysis.\n\n        Raises:\n            FileNotFoundError: If the configuration file does not exist.\n            Exception: If there is an error reading the config file.\n\n        Examples:\n            Read a config file:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n\n            ```\n        \"\"\"\n        if not Path(path).exists():\n            raise FileNotFoundError(f\"The Config-File: {path} does not exist\")\n\n        try:\n            config = ConfigParser(comment_prefixes=\"%\")\n            with open(path, \"r\") as configfile:\n                config.read_file(configfile)\n        except ConfigparserError as e:\n            print(f\"Error during reading the config file: {e}\")\n            config = cls.config_file_callback_parser(path)\n\n        # if version != \"1.0\":\n        config = cls._upgrade(config)\n        return cls(config, path=path)\n\n    @staticmethod\n    def config_file_callback_parser(path: str) -&gt; ConfigParser:\n        \"\"\"Parse a configuration file as fallback to the read method.\n\n        Args:\n            path (str): Path to the configuration file.\n\n        Returns:\n            ConfigParser: Parsed configuration file.\n        \"\"\"\n        config = ConfigParser()\n        config[\"General\"] = {}\n        all_lines = open(path, \"r\").read().splitlines()\n        for line in all_lines:\n            perc = line.find(\"%\")\n            if perc &gt;= 0:\n                line = line[:perc]\n            data = line.split()\n            if len(data) &gt;= 3:\n                config[\"General\"][data[0]] = data[2]\n        return config\n\n    @staticmethod\n    def _upgrade(config: ConfigParser) -&gt; ConfigParser:\n        \"\"\"Upgrade the configuration data structure to version 1.0 format.\n\n        Args:\n            config (ConfigParser): D-FAST Bank Erosion settings in 0.1 format.\n\n        Returns:\n            ConfigParser: D-FAST Bank Erosion settings in 1.0 format.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; result = config_file._upgrade(config_file.config)\n            &gt;&gt;&gt; isinstance(result, ConfigParser)\n            True\n\n            ```\n        \"\"\"\n        try:\n            version = config[\"General\"][\"Version\"]\n        except KeyError:\n            version = \"0.1\"\n\n        if version == \"0.1\":\n            config[\"General\"][\"Version\"] = \"1.0\"\n\n            config[\"Detect\"] = {}\n            config = _move_parameter_location(\n                config, \"General\", \"Delft3Dfile\", \"Detect\", \"SimFile\", convert=_sim2nc\n            )\n            config = _move_parameter_location(\n                config, \"General\", \"SDSfile\", \"Detect\", \"SimFile\", convert=_sim2nc\n            )\n            config = _move_parameter_location(config, \"General\", \"SimFile\", \"Detect\")\n            config = _move_parameter_location(config, \"General\", \"NBank\", \"Detect\")\n            config_file = ConfigFile(config)\n            n_bank = config_file.get_int(\"Detect\", \"NBank\", default=0, positive=True)\n            for i in range(1, n_bank + 1):\n                config = _move_parameter_location(\n                    config, \"General\", f\"Line{i}\", \"Detect\"\n                )\n\n            config = _move_parameter_location(config, \"General\", \"WaterDepth\", \"Detect\")\n            config = _move_parameter_location(config, \"General\", \"DLines\", \"Detect\")\n\n            config[\"Erosion\"] = {}\n            config = _move_parameter_location(config, \"General\", \"TErosion\", \"Erosion\")\n            config = _move_parameter_location(config, \"General\", \"RiverAxis\", \"Erosion\")\n            config = _move_parameter_location(config, \"General\", \"Fairway\", \"Erosion\")\n            config = _move_parameter_location(config, \"General\", \"RefLevel\", \"Erosion\")\n            config = _move_parameter_location(\n                config, \"General\", \"OutputInterval\", \"Erosion\"\n            )\n            config = _move_parameter_location(config, \"General\", \"OutputDir\", \"Erosion\")\n            config = _move_parameter_location(config, \"General\", \"BankNew\", \"Erosion\")\n            config = _move_parameter_location(config, \"General\", \"BankEq\", \"Erosion\")\n            config = _move_parameter_location(config, \"General\", \"EroVol\", \"Erosion\")\n            config = _move_parameter_location(\n                config, \"General\", \"EroVolEqui\", \"Erosion\"\n            )\n            config = _move_parameter_location(config, \"General\", \"NLevel\", \"Erosion\")\n            config_file = ConfigFile(config)\n            n_level = config_file.get_int(\"Erosion\", \"NLevel\", default=0, positive=True)\n\n            for i in range(1, n_level + 1):\n                config = _move_parameter_location(\n                    config,\n                    \"General\",\n                    f\"Delft3Dfile{i}\",\n                    \"Erosion\",\n                    f\"SimFile{i}\",\n                    convert=_sim2nc,\n                )\n                config = _move_parameter_location(\n                    config,\n                    \"General\",\n                    f\"SDSfile{i}\",\n                    \"Erosion\",\n                    f\"SimFile{i}\",\n                    convert=_sim2nc,\n                )\n                config = _move_parameter_location(\n                    config, \"General\", f\"SimFile{i}\", \"Erosion\"\n                )\n                config = _move_parameter_location(\n                    config, \"General\", f\"PDischarge{i}\", \"Erosion\"\n                )\n\n            config = _move_parameter_location(config, \"General\", \"ShipType\", \"Erosion\")\n            config = _move_parameter_location(config, \"General\", \"VShip\", \"Erosion\")\n            config = _move_parameter_location(config, \"General\", \"NShip\", \"Erosion\")\n            config = _move_parameter_location(config, \"General\", \"NWave\", \"Erosion\")\n            config = _move_parameter_location(config, \"General\", \"Draught\", \"Erosion\")\n            config = _move_parameter_location(config, \"General\", \"Wave0\", \"Erosion\")\n            config = _move_parameter_location(config, \"General\", \"Wave1\", \"Erosion\")\n\n            config = _move_parameter_location(config, \"General\", \"Classes\", \"Erosion\")\n            config = _move_parameter_location(config, \"General\", \"BankType\", \"Erosion\")\n            config = _move_parameter_location(\n                config, \"General\", \"ProtectLevel\", \"Erosion\", \"ProtectionLevel\"\n            )\n            config = _move_parameter_location(config, \"General\", \"Slope\", \"Erosion\")\n            config = _move_parameter_location(config, \"General\", \"Reed\", \"Erosion\")\n            config = _move_parameter_location(config, \"General\", \"VelFilter\", \"Erosion\")\n\n            for i in range(1, n_level + 1):\n                config = _move_parameter_location(\n                    config, \"General\", f\"ShipType{i}\", \"Erosion\"\n                )\n                config = _move_parameter_location(\n                    config, \"General\", f\"VShip{i}\", \"Erosion\"\n                )\n                config = _move_parameter_location(\n                    config, \"General\", f\"NShip{i}\", \"Erosion\"\n                )\n                config = _move_parameter_location(\n                    config, \"General\", f\"NWave{i}\", \"Erosion\"\n                )\n                config = _move_parameter_location(\n                    config, \"General\", f\"Draught{i}\", \"Erosion\"\n                )\n                config = _move_parameter_location(\n                    config, \"General\", f\"Slope{i}\", \"Erosion\"\n                )\n                config = _move_parameter_location(\n                    config, \"General\", f\"Reed{i}\", \"Erosion\"\n                )\n                config = _move_parameter_location(\n                    config, \"General\", f\"EroVol{i}\", \"Erosion\"\n                )\n\n        return config\n\n    def write(self, filename: str) -&gt; None:\n        \"\"\"Pretty print a configParser object (configuration file) to file.\n\n        Pretty prints a `configparser` object to a file. Aligns the equal signs for\n        all keyword/value pairs, adds a two-space indentation to all keyword lines,\n        and adds an empty line before the start of a new block.\n\n        Args:\n            filename (str): Name of the configuration file to be written.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; import tempfile\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdirname:\n            ...     config_file.write(f\"{tmpdirname}/meuse_manual_out.cfg\")\n\n            ```\n        \"\"\"\n        sections = self.config.sections()\n        max_length = 0\n        for section in sections:\n            options = self.config.options(section)\n            max_length = max(max_length, *[len(option) for option in options])\n\n        with open(filename, \"w\") as configfile:\n            for index, section in enumerate(sections):\n                if index &gt; 0:\n                    configfile.write(\"\\n\")\n                configfile.write(f\"[{section}]\\n\")\n\n                for option in self.config.options(section):\n                    configfile.write(\n                        f\"  {option:&lt;{max_length}} = {self.config[section][option]}\\n\"\n                    )\n\n    def make_paths_absolute(self) -&gt; str:\n        \"\"\"Convert all relative paths in the configuration to absolute paths.\n\n        Returns:\n            str: Absolute path of the configuration file's root directory.\n        \"\"\"\n        self.resolve(self.root_dir)\n\n        return self.root_dir\n\n    def get_str(\n        self,\n        group: str,\n        key: str,\n        default: Optional[str] = None,\n    ) -&gt; str:\n        \"\"\"Get a string from a selected group and keyword in the analysis settings.\n\n        Args:\n            group (str): Name of the group from which to read.\n            key (str): Name of the keyword from which to read.\n            default (Optional[str]): Optional default value.\n\n        Raises:\n            ConfigFileError: If the keyword isn't specified and no default value is given.\n\n        Returns:\n            str: value of the keyword as string.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; result = config_file.get_str(\"General\", \"BankDir\")\n            &gt;&gt;&gt; expected = Path(\"tests/data/erosion/output/banklines\").resolve()\n            &gt;&gt;&gt; str(expected) == result\n            True\n\n            ```\n        \"\"\"\n        try:\n            val = self.config[group][key]\n        except KeyError as e:\n            if default is not None:\n                val = default\n            else:\n                raise ConfigFileError(\n                    f\"No value specified for required keyword {key} in block {group}.\"\n                ) from e\n        return val\n\n    def get_bool(\n        self,\n        group: str,\n        key: str,\n        default: Optional[bool] = None,\n    ) -&gt; bool:\n        \"\"\"Get a boolean from a selected group and keyword in the analysis settings.\n\n        Args:\n            group (str): Name of the group from which to read.\n            key (str): Name of the keyword from which to read.\n            default (Optional[bool]): Optional default value.\n\n        Raises:\n            ConfigFileError: If the keyword isn't specified and no default value is given.\n\n        Returns:\n            bool: value of the keyword as boolean.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.get_bool(\"General\", \"Plotting\")\n            True\n\n            ```\n        \"\"\"\n        try:\n            str_val = self.config[group][key].lower()\n            val = (\n                (str_val == \"yes\")\n                or (str_val == \"y\")\n                or (str_val == \"true\")\n                or (str_val == \"t\")\n                or (str_val == \"1\")\n            )\n        except KeyError as e:\n            if default is not None:\n                val = default\n            else:\n                raise ConfigFileError(\n                    f\"No boolean value specified for required keyword {key} in block {group}.\"\n                ) from e\n\n        return val\n\n    def get_float(\n        self,\n        group: str,\n        key: str,\n        default: Optional[float] = None,\n        positive: bool = False,\n    ) -&gt; float:\n        \"\"\"Get a floating point value from a selected group and keyword in the analysis settings.\n\n        Args:\n            group (str): Name of the group from which to read.\n            key (str): Name of the keyword from which to read.\n            default (Optional[float]): Optional default value.\n            positive (bool): Flag specifying which floats are accepted.\n                All floats are accepted (if False), or only positive floats (if True).\n\n        Raises:\n            ConfigFileError: If the keyword isn't specified and no default value is given.\n            ConfigFileError: If a negative value is specified when a positive value is required.\n\n\n        Returns:\n            float: value of the keyword as float.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.get_float(\"General\", \"ZoomStepKM\")\n            1.0\n\n            ```\n        \"\"\"\n        try:\n            val = float(self.config[group][key])\n        except (KeyError, ValueError) as e:\n            if default is not None:\n                val = default\n            else:\n                raise ConfigFileError(\n                    f\"No floating point value specified for required keyword {key} in block {group}.\"\n                ) from e\n        if positive and val &lt; 0.0:\n            raise ConfigFileError(\n                f\"Value for {key} in block {group} must be positive, not {val}.\"\n            )\n        return val\n\n    def get_int(\n        self,\n        group: str,\n        key: str,\n        default: Optional[int] = None,\n        positive: bool = False,\n    ) -&gt; int:\n        \"\"\"Get an integer from a selected group and keyword in the analysis settings.\n\n        Args:\n            group (str): Name of the group from which to read.\n            key (str): Name of the keyword from which to read.\n            default (Optional[int]): Optional default value.\n            positive (bool): Flag specifying which floats are accepted.\n                All floats are accepted (if False), or only positive floats (if True).\n\n        Raises:\n            ConfigFileError: If the keyword isn't specified and no default value is given.\n            ConfigFileError: If a negative or zero value is specified when a positive value is required.\n\n\n        Returns:\n            int: value of the keyword as int.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.get_int(\"Detect\", \"NBank\")\n            2\n\n            ```\n        \"\"\"\n        try:\n            val = int(self.config[group][key])\n        except (KeyError, ValueError) as e:\n            if default is not None:\n                val = default\n            else:\n                raise ConfigFileError(\n                    f\"No integer value specified for required keyword {key} in block {group}.\"\n                ) from e\n        if positive and val &lt;= 0:\n            raise ConfigFileError(\n                f\"Value for {key} in block {group} must be positive, not {val}.\"\n            )\n        return val\n\n    def get_sim_file(self, group: str, istr: str) -&gt; str:\n        \"\"\"Get the name of the simulation file from the analysis settings.\n\n        Args:\n            group (str): Name of the group in which to search for the simulation file name.\n            istr (str): Postfix for the simulation file name keyword;\n                typically a string representation of the index.\n\n        Returns:\n            str: Name of the simulation file (empty string if keywords are not found).\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; result = config_file.get_sim_file(\"Erosion\", \"1\")\n            &gt;&gt;&gt; expected = Path(\"tests/data/erosion/inputs/sim0075/SDS-j19_map.nc\").resolve()\n            &gt;&gt;&gt; str(expected) == result\n            True\n\n            ```\n        \"\"\"\n        sim_file = self.config[group].get(f\"SimFile{istr}\", \"\")\n        return sim_file\n\n    def get_start_end_stations(self) -&gt; Tuple[float, float]:\n        \"\"\"Get the start and end station for the river.\n\n        Returns:\n            Tuple[float, float]: start and end station.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.get_start_end_stations()\n            (123.0, 128.0)\n\n            ```\n        \"\"\"\n        stations = self.get_range(\"General\", \"Boundaries\")\n\n        return stations\n\n    def get_search_lines(self) -&gt; List[LineString]:\n        \"\"\"Get the search lines for the bank lines from the analysis settings.\n\n        Returns:\n            List[np.ndarray]: List of arrays containing the x,y-coordinates of a bank search lines.\n        \"\"\"\n        # read guiding bank line\n        n_bank = self.get_int(\"Detect\", \"NBank\")\n        line = []\n        for b in range(n_bank):\n            bankfile = self.config[\"Detect\"][f\"Line{b + 1}\"]\n            self.log_data.log_text(\"read_search_line\", data={\"nr\": b + 1, \"file\": bankfile})\n            line.append(XYCModel.read(bankfile))\n        return line\n\n    def read_bank_lines(self, bank_dir: str) -&gt; List[np.ndarray] | GeoDataFrame:\n        \"\"\"Get the bank lines from the detection step.\n\n        Args:\n            bank_dir (str): Name of directory in which the bank lines files are located.\n\n        Returns:\n            List[np.ndarray]: List of arrays containing the x,y-coordinates of a bank lines.\n        \"\"\"\n        bank_name = self.get_str(\"General\", \"BankFile\", \"bankfile\")\n        bankfile = Path(bank_dir) / f\"{bank_name}.shp\"\n        if bankfile.exists():\n            self.log_data.log_text(\"read_banklines\", data={\"file\": str(bankfile)})\n            return gpd.read_file(bankfile)\n\n        bankfile = Path(bank_dir) / f\"{bank_name}_#.xyc\"\n        self.log_data.log_text(\"read_banklines\", data={\"file\": str(bankfile)})\n        bankline_list = []\n        b = 1\n        while True:\n            xyc_file = Path(bank_dir) / f\"{bank_name}_{b}.xyc\"\n            if not xyc_file.exists():\n                break\n\n            xy_bank = XYCModel.read(xyc_file)\n            bankline_list.append(LineString(xy_bank))\n            b += 1\n        bankline_series = GeoSeries(bankline_list, crs=self.crs)\n        banklines = GeoDataFrame(geometry=bankline_series)\n        return banklines\n\n    def get_parameter(\n        self,\n        group: str,\n        key: str,\n        num_stations_per_bank: List[int],\n        default: Any = None,\n        ext: str = \"\",\n        positive: bool = False,\n        valid: Optional[List[float]] = None,\n        onefile: bool = False,\n    ) -&gt; List[np.ndarray]:\n        \"\"\"Get a parameter field from a selected group and keyword in the analysis settings.\n\n        Args:\n            group (str):\n                Name of the group from which to read.\n            key (str):\n                Name of the keyword from which to read.\n            num_stations_per_bank (List[int]):\n                Number of stations (points) For each bank (bank chainage locations).\n            default (Optional[Union[float, List[np.ndarray]]]):\n                Optional default value or default parameter field; default None.\n            ext (str):\n                File name extension; default empty string.\n            positive (bool):\n                Flag specifying which boolean values are accepted.\n                All values are accepted (if False), or only strictly positive values (if True); default False.\n            valid (Optional[List[float]]):\n                Optional list of valid values; default None.\n            onefile (bool):\n                Flag indicating whether parameters are read from one file.\n                One file should be used for all bank lines (True) or one file per bank line (False; default).\n\n        Raises:\n            Exception:\n                If a parameter isn't provided in the configuration, but no default value provided either.\n                If the value is negative while a positive value is required (positive = True).\n                If the value doesn't match one of the value values (valid is not None).\n\n        Returns:\n            List[np.ndarray]: Parameter field\n                For each bank a parameter value per bank point (bank chainage location).\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; bank_km = [np.array([0, 1, 2]), np.array([3, 4, 5, 6, 7])]\n            &gt;&gt;&gt; num_stations_per_bank = [len(bank) for bank in bank_km]\n            &gt;&gt;&gt; config_file.get_parameter(\"General\", \"ZoomStepKM\", num_stations_per_bank)\n            [array([1., 1., 1.]), array([1., 1., 1., 1., 1.])]\n\n            ```\n        \"\"\"\n        try:\n            value = self.config[group][key]\n            use_default = False\n        except (KeyError, TypeError) as e:\n            value = None\n            if default is None:\n                raise ConfigFileError(\n                    f'No value specified for required keyword \"{key}\" in block \"{group}\".'\n                ) from e\n            use_default = True\n\n        return self.process_parameter(\n            value=value,\n            key=key,\n            num_stations_per_bank=num_stations_per_bank,\n            use_default=use_default,\n            default=default,\n            ext=ext,\n            positive=positive,\n            valid=valid,\n            onefile=onefile,\n        )\n\n    def validate_parameter_value(\n        self,\n        value: float,\n        key: str,\n        positive: bool = False,\n        valid: Optional[List[float]] = None,\n    ) -&gt; float:\n        \"\"\"Validate a parameter value against constraints.\n\n        Args:\n            value (float): The parameter value to validate.\n            key (str): Name of the parameter for error messages.\n            positive (bool): Flag specifying whether all values are accepted (if False),\n                or only positive values (if True); default False.\n            valid (Optional[List[float]]): Optional list of valid values; default None.\n\n        Raises:\n            ValueError: If the value doesn't meet the constraints.\n\n        Returns:\n            float: The validated parameter value.\n        \"\"\"\n        if positive and value &lt; 0:\n            raise ValueError(f'Value of \"{key}\" should be positive, not {value}.')\n        if valid is not None and valid.count(value) == 0:\n            raise ValueError(f'Value of \"{key}\" should be in {valid}, not {value}.')\n        return value\n\n    def process_parameter(\n        self,\n        value: Union[str, float],\n        key: str,\n        num_stations_per_bank: List[int],\n        use_default: bool = False,\n        default: Any = None,\n        ext: str = \"\",\n        positive: bool = False,\n        valid: Optional[List[float]] = None,\n        onefile: bool = False,\n    ) -&gt; List[np.ndarray]:\n        \"\"\"\n        Process a parameter value into arrays for each bank.\n\n        Args:\n            value (Union[str, float]):\n                The parameter value or a path to a file.\n            key (str):\n                Name of the parameter for error messages.\n            num_stations_per_bank (List[int]):\n                Number of stations for each bank.\n            use_default (bool):\n                Whether to use the default value.\n            default (Optional[float], default=None):\n                Default value used if `use_default` is True.\n            ext (str, default=''):\n                File name extension.\n            positive (bool, default=False):\n                If True, only positive values are allowed.\n            valid (Optional[List[float]], default=None):\n                List of valid values.\n            onefile (bool, default=False):\n                If True, parameters are read from a single file for all banks;\n                otherwise, one file per bank.\n\n        Returns:\n            List[np.ndarray]: Parameter values for each bank.\n        \"\"\"\n        # if val is value then use that value globally\n        parameter_values = []\n        try:\n            if use_default:\n                if isinstance(default, list):\n                    return default\n                real_val = default\n            else:\n                real_val = float(value)\n                self.validate_parameter_value(real_val, key, positive, valid)\n\n            for num_stations in num_stations_per_bank:\n                parameter_values.append(np.zeros(num_stations) + real_val)\n\n        except (ValueError, TypeError):\n            if onefile:\n                self.log_data.log_text(\"read_param\", data={\"param\": key, \"file\": value})\n                km_thr, val = _get_stations(value, key, positive)\n\n            for ib, num_stations in enumerate(num_stations_per_bank):\n                if not onefile:\n                    filename_i = f\"{value}_{ib + 1}{ext}\"\n                    self.log_data.log_text(\n                        \"read_param_one_bank\",\n                        data={\"param\": key, \"i\": ib + 1, \"file\": filename_i},\n                    )\n                    km_thr, val = _get_stations(filename_i, key, positive)\n\n                if km_thr is None:\n                    parameter_values.append(np.zeros(num_stations) + val[0])\n                else:\n                    idx = np.zeros(num_stations, dtype=int)\n\n                    for thr in km_thr:\n                        idx[num_stations &gt;= thr] += 1\n                    parameter_values.append(val[idx])\n\n        return parameter_values\n\n    def get_bank_search_distances(self, num_search_lines: int) -&gt; List[float]:\n        \"\"\"Get the search distance per bank line from the analysis settings.\n\n        Args:\n            num_search_lines (int): Number of bank search lines.\n\n        Returns:\n            List[float]: Array of length nbank containing the search distance value per bank line (default value: 50).\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.get_bank_search_distances(2)\n            [50.0, 50.0]\n\n            ```\n        \"\"\"\n        d_lines_key = self.config[\"Detect\"].get(\"DLines\", None)\n        if d_lines_key is None:\n            d_lines = [50] * num_search_lines\n        elif d_lines_key[0] == \"[\" and d_lines_key[-1] == \"]\":\n            d_lines_split = d_lines_key[1:-1].split(\",\")\n            d_lines = [float(d) for d in d_lines_split]\n            if not all([d &gt; 0 for d in d_lines]):\n                raise ValueError(\n                    \"keyword DLINES should contain positive values in the configuration file.\"\n                )\n            if len(d_lines) != num_search_lines:\n                raise ConfigFileError(\n                    \"keyword DLINES should contain NBANK values in the configuration file.\"\n                )\n        return d_lines\n\n    def get_range(self, group: str, key: str) -&gt; Tuple[float, float]:\n        \"\"\"Get a start and end value from a selected group and keyword in the analysis settings.\n\n        Args:\n            group (str): Name of the group from which to read.\n            key (str): Name of the keyword from which to read.\n\n        Returns:\n            Tuple[float,float]: Lower and upper limit of the range.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.get_range(\"General\", \"Boundaries\")\n            (123.0, 128.0)\n\n            ```\n        \"\"\"\n        str_val = self.get_str(group, key)\n        try:\n            obrack = str_val.find(\"[\")\n            cbrack = str_val.find(\"]\")\n            if obrack &gt;= 0 and cbrack &gt;= 0:\n                str_val = str_val[obrack + 1 : cbrack - 1]\n            val_list = [float(fstr) for fstr in str_val.split(\":\")]\n            if val_list[0] &gt; val_list[1]:\n                val = (val_list[1], val_list[0])\n            else:\n                val = (val_list[0], val_list[1])\n        except ValueError as e:\n            raise ValueError(\n                f'Invalid range specification \"{str_val}\" for required keyword \"{key}\" in block \"{group}\".'\n            ) from e\n        return val\n\n    def get_river_center_line(self) -&gt; LineString:\n        \"\"\"Get the river center line from the xyc file as a linestring.\n\n        Returns:\n            LineString: Chainage line.\n        \"\"\"\n        # get the chainage file\n        river_center_line_file = self.get_str(\"General\", \"RiverKM\")\n        self.log_data.log_text(\"read_chainage\", data={\"file\": river_center_line_file})\n        river_center_line = XYCModel.read(river_center_line_file, num_columns=3)\n\n        # make sure that chainage is increasing with node index\n        if river_center_line.coords[0][2] &gt; river_center_line.coords[1][2]:\n            river_center_line = LineString(river_center_line.coords[::-1])\n\n        return river_center_line\n\n    def resolve(self, rootdir: str):\n        \"\"\"Convert a configuration object to contain absolute paths (for editing).\n\n        Args:\n            rootdir (str): The path to be used as base for the absolute paths.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.resolve(\"tests/data/erosion\")\n\n            ```\n        \"\"\"\n        if \"General\" in self.config:\n            self.resolve_parameter(\"General\", \"RiverKM\", rootdir)\n            self.resolve_parameter(\"General\", \"BankDir\", rootdir)\n            self.resolve_parameter(\"General\", \"FigureDir\", rootdir)\n\n        if \"Detect\" in self.config:\n            self.resolve_parameter(\"Detect\", \"SimFile\", rootdir)\n            i = 0\n            while True:\n                i = i + 1\n                line_i = \"Line\" + str(i)\n                if line_i in self.config[\"Detect\"]:\n                    self.resolve_parameter(\"Detect\", line_i, rootdir)\n                else:\n                    break\n\n        if \"Erosion\" in self.config:\n            self.resolve_parameter(\"Erosion\", \"RiverAxis\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"Fairway\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"OutputDir\", rootdir)\n\n            self.resolve_parameter(\"Erosion\", \"ShipType\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"VShip\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"NShip\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"NWave\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"Draught\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"Wave0\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"Wave1\", rootdir)\n\n            self.resolve_parameter(\"Erosion\", \"BankType\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"ProtectionLevel\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"Slope\", rootdir)\n            self.resolve_parameter(\"Erosion\", \"Reed\", rootdir)\n\n            n_level = self.get_int(\"Erosion\", \"NLevel\", default=0)\n            for i in range(1, n_level + 1):\n                self.resolve_parameter(\"Erosion\", f\"SimFile{i}\", rootdir)\n                self.resolve_parameter(\"Erosion\", f\"ShipType{i}\", rootdir)\n                self.resolve_parameter(\"Erosion\", f\"VShip{i}\", rootdir)\n                self.resolve_parameter(\"Erosion\", f\"NShip{i}\", rootdir)\n                self.resolve_parameter(\"Erosion\", f\"NWave{i}\", rootdir)\n                self.resolve_parameter(\"Erosion\", f\"Draught{i}\", rootdir)\n                self.resolve_parameter(\"Erosion\", f\"Slope{i}\", rootdir)\n                self.resolve_parameter(\"Erosion\", f\"Reed{i}\", rootdir)\n\n    def relative_to(self, rootdir: str) -&gt; None:\n        \"\"\"Convert a configuration object to contain relative paths (for saving).\n\n        Args:\n            rootdir (str): The path to be used as base for the relative paths.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.relative_to(\"testing/data/erosion\")\n\n            ```\n        \"\"\"\n        if \"General\" in self.config:\n            self.parameter_relative_to(\"General\", \"RiverKM\", rootdir)\n            self.parameter_relative_to(\"General\", \"BankDir\", rootdir)\n            self.parameter_relative_to(\"General\", \"FigureDir\", rootdir)\n\n        if \"Detect\" in self.config:\n            self.parameter_relative_to(\"Detect\", \"SimFile\", rootdir)\n\n            i = 0\n            while True:\n                i = i + 1\n                line_i = f\"Line{i}\"\n                if line_i in self.config[\"Detect\"]:\n                    self.parameter_relative_to(\"Detect\", line_i, rootdir)\n                else:\n                    break\n\n        if \"Erosion\" in self.config:\n            self.parameter_relative_to(\"Erosion\", \"RiverAxis\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"Fairway\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"OutputDir\", rootdir)\n\n            self.parameter_relative_to(\"Erosion\", \"ShipType\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"VShip\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"NShip\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"NWave\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"Draught\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"Wave0\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"Wave1\", rootdir)\n\n            self.parameter_relative_to(\"Erosion\", \"BankType\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"ProtectionLevel\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"Slope\", rootdir)\n            self.parameter_relative_to(\"Erosion\", \"Reed\", rootdir)\n\n            n_level = self.get_int(\"Erosion\", \"NLevel\", default=0)\n            for i in range(1, n_level + 1):\n                self.parameter_relative_to(\"Erosion\", f\"SimFile{i}\", rootdir)\n                self.parameter_relative_to(\"Erosion\", f\"ShipType{i}\", rootdir)\n                self.parameter_relative_to(\"Erosion\", f\"VShip{i}\", rootdir)\n                self.parameter_relative_to(\"Erosion\", f\"NShip{i}\", rootdir)\n                self.parameter_relative_to(\"Erosion\", f\"NWave{i}\", rootdir)\n                self.parameter_relative_to(\"Erosion\", f\"Draught{i}\", rootdir)\n                self.parameter_relative_to(\"Erosion\", f\"Slope{i}\", rootdir)\n                self.parameter_relative_to(\"Erosion\", f\"Reed{i}\", rootdir)\n\n    def resolve_parameter(self, group: str, key: str, rootdir: str):\n        \"\"\"Convert a parameter value to contain an absolute path.\n\n        Determine whether the string represents a number.\n        If not, try to convert to an absolute path.\n\n        Args:\n            group (str): Name of the group in the configuration.\n            key (str): Name of the key in the configuration.\n            rootdir (str): The path to be used as base for the absolute paths.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.resolve_parameter(\"General\", \"RiverKM\", \"tests/data/erosion\")\n\n            ```\n        \"\"\"\n        if key in self.config[group]:\n            val_str = self.config[group][key]\n            try:\n                float(val_str)\n            except ValueError:\n                self.config[group][key] = absolute_path(rootdir, val_str)\n\n    def parameter_relative_to(self, group: str, key: str, rootdir: str):\n        \"\"\"Convert a parameter value to contain a relative path.\n\n        Determine whether the string represents a number.\n        If not, try to convert to a relative path.\n\n        Args:\n            group (str): Name of the group in the configuration.\n            key (str): Name of the key in the configuration.\n            rootdir (str): The path to be used as base for the relative paths.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; config_file.parameter_relative_to(\"General\", \"RiverKM\", \"tests/data/erosion\")\n\n            ```\n        \"\"\"\n        if key in self.config[group]:\n            val_str = self.config[group][key]\n\n            try:\n                float(val_str)\n            except ValueError:\n                self.config[group][key] = relative_path(rootdir, val_str)\n\n    def get_plotting_flags(self, root_dir: Path | str) -&gt; PlotProperties:\n        \"\"\"Get the plotting flags from the configuration file.\n\n        Returns:\n            PlotProperties:\n                plot_data (bool):\n                    Flag indicating whether to plot the data.\n                save_plot (bool):\n                    Flag indicating whether to save the plot.\n                save_zoomed_plot (bool):\n                    Flag indicating whether to save the zoomed plot.\n                zoom_step_km (float):\n                    Step size for zooming in on the plot.\n                close_plot (bool):\n                    Flag indicating whether to close the plot.\n                save_dir (str):\n                    Directory where the figures will be saved.\n                plot_extension (str):\n                    File extension for the saved figures.\n        \"\"\"\n        plot_data = self.get_bool(\"General\", \"Plotting\", True)\n\n        if plot_data:\n            save_plot = self.get_bool(\"General\", \"SavePlots\", True)\n            save_zoomed_plot = self.get_bool(\"General\", \"SaveZoomPlots\", True)\n            zoom_step_km = self.get_float(\"General\", \"ZoomStepKM\", 1.0)\n            if zoom_step_km &lt; 0.01:\n                save_zoomed_plot = False\n            close_plot = self.get_bool(\"General\", \"ClosePlots\", False)\n        else:\n            save_plot = False\n            save_zoomed_plot = False\n            close_plot = False\n\n        data = {\n            \"plot_data\": plot_data,\n            \"save_plot\": save_plot,\n            \"save_zoomed_plot\": save_zoomed_plot,\n            \"zoom_step_km\": zoom_step_km,\n            \"close_plot\": close_plot,\n        }\n\n        # as appropriate, check output dir for figures and file format\n        if save_plot:\n            fig_dir = self.get_str(\"General\", \"FigureDir\", Path(root_dir) / \"figure\")\n            self.log_data.log_text(\"figure_dir\", data={\"dir\": fig_dir})\n            path_fig_dir = Path(fig_dir)\n            if path_fig_dir.exists():\n                self.log_data.log_text(\"overwrite_dir\", data={\"dir\": fig_dir})\n            path_fig_dir.mkdir(parents=True, exist_ok=True)\n            plot_ext = self.get_str(\"General\", \"FigureExt\", \".png\")\n            data = data | {\n                \"save_dir\": fig_dir,\n                \"plot_extension\": plot_ext,\n            }\n\n        return PlotProperties(**data)\n\n    def get_output_dir(self, option: str) -&gt; Path:\n        \"\"\"Get the output directory for the analysis.\n\n        Args:\n            option (str):\n                Option for which to get the output directory. \"banklines\" for bank lines, else the erosion output\n                directory will be returned.\n        Returns:\n            output_dir (Path):\n                Path to the output directory.\n        \"\"\"\n        if option == \"banklines\":\n            output_dir = self.get_str(\"General\", \"BankDir\")\n        else:\n            output_dir = self.get_str(\"Erosion\", \"OutputDir\")\n\n        output_dir = Path(output_dir)\n        self.log_data.log_text(f\"{option}_out\", data={\"dir\": output_dir})\n        if output_dir.exists():\n            self.log_data.log_text(\"overwrite_dir\", data={\"dir\": output_dir})\n        else:\n            output_dir.mkdir(parents=True, exist_ok=True)\n\n        return output_dir\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.config","title":"<code>config: ConfigParser</code>  <code>property</code> <code>writable</code>","text":"<p>ConfigParser: Get the configuration settings.</p>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.debug","title":"<code>debug: bool</code>  <code>property</code>","text":"<p>bool: Get the debug flag.</p>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.root_dir","title":"<code>root_dir: Path | str</code>  <code>property</code> <code>writable</code>","text":"<p>Path: Get the root directory of the configuration file.</p>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.version","title":"<code>version: str</code>  <code>property</code>","text":"<p>str: Get the version of the configuration file.</p>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.__init__","title":"<code>__init__(config: ConfigParser, path: Union[Path, str] = None)</code>","text":"<p>Initialize the ConfigFile object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConfigParser</code> <p>Settings for the D-FAST Bank Erosion analysis.</p> required <code>path</code> <code>Union[Path, str]</code> <p>Path to the configuration file.</p> <code>None</code> <p>Examples:</p> <p>Reading a configuration file:     <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; print(config_file.config[\"General\"][\"Version\"])\n1.0\n</code></pre> Writing a configuration file:     <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdirname:\n...     config_file.write(f\"{tmpdirname}/meuse_manual_out.cfg\")\n</code></pre></p> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def __init__(self, config: ConfigParser, path: Union[Path, str] = None):\n    \"\"\"\n    Initialize the ConfigFile object.\n\n    Args:\n        config (ConfigParser):\n            Settings for the D-FAST Bank Erosion analysis.\n        path (Union[Path, str]):\n            Path to the configuration file.\n\n    Examples:\n        Reading a configuration file:\n            ```python\n            &gt;&gt;&gt; import tempfile\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; print(config_file.config[\"General\"][\"Version\"])\n            1.0\n\n            ```\n        Writing a configuration file:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdirname:\n            ...     config_file.write(f\"{tmpdirname}/meuse_manual_out.cfg\")\n\n            ```\n    \"\"\"\n    self._config = config\n    self.crs = \"EPSG:28992\"\n    if path:\n        self.path = Path(path)\n        self.root_dir = self.path.parent\n        self.make_paths_absolute()\n    self.log_data = LogData()\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.config_file_callback_parser","title":"<code>config_file_callback_parser(path: str) -&gt; ConfigParser</code>  <code>staticmethod</code>","text":"<p>Parse a configuration file as fallback to the read method.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the configuration file.</p> required <p>Returns:</p> Name Type Description <code>ConfigParser</code> <code>ConfigParser</code> <p>Parsed configuration file.</p> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>@staticmethod\ndef config_file_callback_parser(path: str) -&gt; ConfigParser:\n    \"\"\"Parse a configuration file as fallback to the read method.\n\n    Args:\n        path (str): Path to the configuration file.\n\n    Returns:\n        ConfigParser: Parsed configuration file.\n    \"\"\"\n    config = ConfigParser()\n    config[\"General\"] = {}\n    all_lines = open(path, \"r\").read().splitlines()\n    for line in all_lines:\n        perc = line.find(\"%\")\n        if perc &gt;= 0:\n            line = line[:perc]\n        data = line.split()\n        if len(data) &gt;= 3:\n            config[\"General\"][data[0]] = data[2]\n    return config\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.get_bank_search_distances","title":"<code>get_bank_search_distances(num_search_lines: int) -&gt; List[float]</code>","text":"<p>Get the search distance per bank line from the analysis settings.</p> <p>Parameters:</p> Name Type Description Default <code>num_search_lines</code> <code>int</code> <p>Number of bank search lines.</p> required <p>Returns:</p> Type Description <code>List[float]</code> <p>List[float]: Array of length nbank containing the search distance value per bank line (default value: 50).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.get_bank_search_distances(2)\n[50.0, 50.0]\n</code></pre> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def get_bank_search_distances(self, num_search_lines: int) -&gt; List[float]:\n    \"\"\"Get the search distance per bank line from the analysis settings.\n\n    Args:\n        num_search_lines (int): Number of bank search lines.\n\n    Returns:\n        List[float]: Array of length nbank containing the search distance value per bank line (default value: 50).\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.get_bank_search_distances(2)\n        [50.0, 50.0]\n\n        ```\n    \"\"\"\n    d_lines_key = self.config[\"Detect\"].get(\"DLines\", None)\n    if d_lines_key is None:\n        d_lines = [50] * num_search_lines\n    elif d_lines_key[0] == \"[\" and d_lines_key[-1] == \"]\":\n        d_lines_split = d_lines_key[1:-1].split(\",\")\n        d_lines = [float(d) for d in d_lines_split]\n        if not all([d &gt; 0 for d in d_lines]):\n            raise ValueError(\n                \"keyword DLINES should contain positive values in the configuration file.\"\n            )\n        if len(d_lines) != num_search_lines:\n            raise ConfigFileError(\n                \"keyword DLINES should contain NBANK values in the configuration file.\"\n            )\n    return d_lines\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.get_bool","title":"<code>get_bool(group: str, key: str, default: Optional[bool] = None) -&gt; bool</code>","text":"<p>Get a boolean from a selected group and keyword in the analysis settings.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group from which to read.</p> required <code>key</code> <code>str</code> <p>Name of the keyword from which to read.</p> required <code>default</code> <code>Optional[bool]</code> <p>Optional default value.</p> <code>None</code> <p>Raises:</p> Type Description <code>ConfigFileError</code> <p>If the keyword isn't specified and no default value is given.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>value of the keyword as boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.get_bool(\"General\", \"Plotting\")\nTrue\n</code></pre> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def get_bool(\n    self,\n    group: str,\n    key: str,\n    default: Optional[bool] = None,\n) -&gt; bool:\n    \"\"\"Get a boolean from a selected group and keyword in the analysis settings.\n\n    Args:\n        group (str): Name of the group from which to read.\n        key (str): Name of the keyword from which to read.\n        default (Optional[bool]): Optional default value.\n\n    Raises:\n        ConfigFileError: If the keyword isn't specified and no default value is given.\n\n    Returns:\n        bool: value of the keyword as boolean.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.get_bool(\"General\", \"Plotting\")\n        True\n\n        ```\n    \"\"\"\n    try:\n        str_val = self.config[group][key].lower()\n        val = (\n            (str_val == \"yes\")\n            or (str_val == \"y\")\n            or (str_val == \"true\")\n            or (str_val == \"t\")\n            or (str_val == \"1\")\n        )\n    except KeyError as e:\n        if default is not None:\n            val = default\n        else:\n            raise ConfigFileError(\n                f\"No boolean value specified for required keyword {key} in block {group}.\"\n            ) from e\n\n    return val\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.get_float","title":"<code>get_float(group: str, key: str, default: Optional[float] = None, positive: bool = False) -&gt; float</code>","text":"<p>Get a floating point value from a selected group and keyword in the analysis settings.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group from which to read.</p> required <code>key</code> <code>str</code> <p>Name of the keyword from which to read.</p> required <code>default</code> <code>Optional[float]</code> <p>Optional default value.</p> <code>None</code> <code>positive</code> <code>bool</code> <p>Flag specifying which floats are accepted. All floats are accepted (if False), or only positive floats (if True).</p> <code>False</code> <p>Raises:</p> Type Description <code>ConfigFileError</code> <p>If the keyword isn't specified and no default value is given.</p> <code>ConfigFileError</code> <p>If a negative value is specified when a positive value is required.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>value of the keyword as float.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.get_float(\"General\", \"ZoomStepKM\")\n1.0\n</code></pre> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def get_float(\n    self,\n    group: str,\n    key: str,\n    default: Optional[float] = None,\n    positive: bool = False,\n) -&gt; float:\n    \"\"\"Get a floating point value from a selected group and keyword in the analysis settings.\n\n    Args:\n        group (str): Name of the group from which to read.\n        key (str): Name of the keyword from which to read.\n        default (Optional[float]): Optional default value.\n        positive (bool): Flag specifying which floats are accepted.\n            All floats are accepted (if False), or only positive floats (if True).\n\n    Raises:\n        ConfigFileError: If the keyword isn't specified and no default value is given.\n        ConfigFileError: If a negative value is specified when a positive value is required.\n\n\n    Returns:\n        float: value of the keyword as float.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.get_float(\"General\", \"ZoomStepKM\")\n        1.0\n\n        ```\n    \"\"\"\n    try:\n        val = float(self.config[group][key])\n    except (KeyError, ValueError) as e:\n        if default is not None:\n            val = default\n        else:\n            raise ConfigFileError(\n                f\"No floating point value specified for required keyword {key} in block {group}.\"\n            ) from e\n    if positive and val &lt; 0.0:\n        raise ConfigFileError(\n            f\"Value for {key} in block {group} must be positive, not {val}.\"\n        )\n    return val\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.get_int","title":"<code>get_int(group: str, key: str, default: Optional[int] = None, positive: bool = False) -&gt; int</code>","text":"<p>Get an integer from a selected group and keyword in the analysis settings.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group from which to read.</p> required <code>key</code> <code>str</code> <p>Name of the keyword from which to read.</p> required <code>default</code> <code>Optional[int]</code> <p>Optional default value.</p> <code>None</code> <code>positive</code> <code>bool</code> <p>Flag specifying which floats are accepted. All floats are accepted (if False), or only positive floats (if True).</p> <code>False</code> <p>Raises:</p> Type Description <code>ConfigFileError</code> <p>If the keyword isn't specified and no default value is given.</p> <code>ConfigFileError</code> <p>If a negative or zero value is specified when a positive value is required.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>value of the keyword as int.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.get_int(\"Detect\", \"NBank\")\n2\n</code></pre> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def get_int(\n    self,\n    group: str,\n    key: str,\n    default: Optional[int] = None,\n    positive: bool = False,\n) -&gt; int:\n    \"\"\"Get an integer from a selected group and keyword in the analysis settings.\n\n    Args:\n        group (str): Name of the group from which to read.\n        key (str): Name of the keyword from which to read.\n        default (Optional[int]): Optional default value.\n        positive (bool): Flag specifying which floats are accepted.\n            All floats are accepted (if False), or only positive floats (if True).\n\n    Raises:\n        ConfigFileError: If the keyword isn't specified and no default value is given.\n        ConfigFileError: If a negative or zero value is specified when a positive value is required.\n\n\n    Returns:\n        int: value of the keyword as int.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.get_int(\"Detect\", \"NBank\")\n        2\n\n        ```\n    \"\"\"\n    try:\n        val = int(self.config[group][key])\n    except (KeyError, ValueError) as e:\n        if default is not None:\n            val = default\n        else:\n            raise ConfigFileError(\n                f\"No integer value specified for required keyword {key} in block {group}.\"\n            ) from e\n    if positive and val &lt;= 0:\n        raise ConfigFileError(\n            f\"Value for {key} in block {group} must be positive, not {val}.\"\n        )\n    return val\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.get_output_dir","title":"<code>get_output_dir(option: str) -&gt; Path</code>","text":"<p>Get the output directory for the analysis.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>str</code> <p>Option for which to get the output directory. \"banklines\" for bank lines, else the erosion output directory will be returned.</p> required <p>Returns:     output_dir (Path):         Path to the output directory.</p> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def get_output_dir(self, option: str) -&gt; Path:\n    \"\"\"Get the output directory for the analysis.\n\n    Args:\n        option (str):\n            Option for which to get the output directory. \"banklines\" for bank lines, else the erosion output\n            directory will be returned.\n    Returns:\n        output_dir (Path):\n            Path to the output directory.\n    \"\"\"\n    if option == \"banklines\":\n        output_dir = self.get_str(\"General\", \"BankDir\")\n    else:\n        output_dir = self.get_str(\"Erosion\", \"OutputDir\")\n\n    output_dir = Path(output_dir)\n    self.log_data.log_text(f\"{option}_out\", data={\"dir\": output_dir})\n    if output_dir.exists():\n        self.log_data.log_text(\"overwrite_dir\", data={\"dir\": output_dir})\n    else:\n        output_dir.mkdir(parents=True, exist_ok=True)\n\n    return output_dir\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.get_parameter","title":"<code>get_parameter(group: str, key: str, num_stations_per_bank: List[int], default: Any = None, ext: str = '', positive: bool = False, valid: Optional[List[float]] = None, onefile: bool = False) -&gt; List[np.ndarray]</code>","text":"<p>Get a parameter field from a selected group and keyword in the analysis settings.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group from which to read.</p> required <code>key</code> <code>str</code> <p>Name of the keyword from which to read.</p> required <code>num_stations_per_bank</code> <code>List[int]</code> <p>Number of stations (points) For each bank (bank chainage locations).</p> required <code>default</code> <code>Optional[Union[float, List[ndarray]]]</code> <p>Optional default value or default parameter field; default None.</p> <code>None</code> <code>ext</code> <code>str</code> <p>File name extension; default empty string.</p> <code>''</code> <code>positive</code> <code>bool</code> <p>Flag specifying which boolean values are accepted. All values are accepted (if False), or only strictly positive values (if True); default False.</p> <code>False</code> <code>valid</code> <code>Optional[List[float]]</code> <p>Optional list of valid values; default None.</p> <code>None</code> <code>onefile</code> <code>bool</code> <p>Flag indicating whether parameters are read from one file. One file should be used for all bank lines (True) or one file per bank line (False; default).</p> <code>False</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If a parameter isn't provided in the configuration, but no default value provided either. If the value is negative while a positive value is required (positive = True). If the value doesn't match one of the value values (valid is not None).</p> <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>List[np.ndarray]: Parameter field For each bank a parameter value per bank point (bank chainage location).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; bank_km = [np.array([0, 1, 2]), np.array([3, 4, 5, 6, 7])]\n&gt;&gt;&gt; num_stations_per_bank = [len(bank) for bank in bank_km]\n&gt;&gt;&gt; config_file.get_parameter(\"General\", \"ZoomStepKM\", num_stations_per_bank)\n[array([1., 1., 1.]), array([1., 1., 1., 1., 1.])]\n</code></pre> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def get_parameter(\n    self,\n    group: str,\n    key: str,\n    num_stations_per_bank: List[int],\n    default: Any = None,\n    ext: str = \"\",\n    positive: bool = False,\n    valid: Optional[List[float]] = None,\n    onefile: bool = False,\n) -&gt; List[np.ndarray]:\n    \"\"\"Get a parameter field from a selected group and keyword in the analysis settings.\n\n    Args:\n        group (str):\n            Name of the group from which to read.\n        key (str):\n            Name of the keyword from which to read.\n        num_stations_per_bank (List[int]):\n            Number of stations (points) For each bank (bank chainage locations).\n        default (Optional[Union[float, List[np.ndarray]]]):\n            Optional default value or default parameter field; default None.\n        ext (str):\n            File name extension; default empty string.\n        positive (bool):\n            Flag specifying which boolean values are accepted.\n            All values are accepted (if False), or only strictly positive values (if True); default False.\n        valid (Optional[List[float]]):\n            Optional list of valid values; default None.\n        onefile (bool):\n            Flag indicating whether parameters are read from one file.\n            One file should be used for all bank lines (True) or one file per bank line (False; default).\n\n    Raises:\n        Exception:\n            If a parameter isn't provided in the configuration, but no default value provided either.\n            If the value is negative while a positive value is required (positive = True).\n            If the value doesn't match one of the value values (valid is not None).\n\n    Returns:\n        List[np.ndarray]: Parameter field\n            For each bank a parameter value per bank point (bank chainage location).\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; bank_km = [np.array([0, 1, 2]), np.array([3, 4, 5, 6, 7])]\n        &gt;&gt;&gt; num_stations_per_bank = [len(bank) for bank in bank_km]\n        &gt;&gt;&gt; config_file.get_parameter(\"General\", \"ZoomStepKM\", num_stations_per_bank)\n        [array([1., 1., 1.]), array([1., 1., 1., 1., 1.])]\n\n        ```\n    \"\"\"\n    try:\n        value = self.config[group][key]\n        use_default = False\n    except (KeyError, TypeError) as e:\n        value = None\n        if default is None:\n            raise ConfigFileError(\n                f'No value specified for required keyword \"{key}\" in block \"{group}\".'\n            ) from e\n        use_default = True\n\n    return self.process_parameter(\n        value=value,\n        key=key,\n        num_stations_per_bank=num_stations_per_bank,\n        use_default=use_default,\n        default=default,\n        ext=ext,\n        positive=positive,\n        valid=valid,\n        onefile=onefile,\n    )\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.get_plotting_flags","title":"<code>get_plotting_flags(root_dir: Path | str) -&gt; PlotProperties</code>","text":"<p>Get the plotting flags from the configuration file.</p> <p>Returns:</p> Name Type Description <code>PlotProperties</code> <code>PlotProperties</code> <p>plot_data (bool):     Flag indicating whether to plot the data. save_plot (bool):     Flag indicating whether to save the plot. save_zoomed_plot (bool):     Flag indicating whether to save the zoomed plot. zoom_step_km (float):     Step size for zooming in on the plot. close_plot (bool):     Flag indicating whether to close the plot. save_dir (str):     Directory where the figures will be saved. plot_extension (str):     File extension for the saved figures.</p> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def get_plotting_flags(self, root_dir: Path | str) -&gt; PlotProperties:\n    \"\"\"Get the plotting flags from the configuration file.\n\n    Returns:\n        PlotProperties:\n            plot_data (bool):\n                Flag indicating whether to plot the data.\n            save_plot (bool):\n                Flag indicating whether to save the plot.\n            save_zoomed_plot (bool):\n                Flag indicating whether to save the zoomed plot.\n            zoom_step_km (float):\n                Step size for zooming in on the plot.\n            close_plot (bool):\n                Flag indicating whether to close the plot.\n            save_dir (str):\n                Directory where the figures will be saved.\n            plot_extension (str):\n                File extension for the saved figures.\n    \"\"\"\n    plot_data = self.get_bool(\"General\", \"Plotting\", True)\n\n    if plot_data:\n        save_plot = self.get_bool(\"General\", \"SavePlots\", True)\n        save_zoomed_plot = self.get_bool(\"General\", \"SaveZoomPlots\", True)\n        zoom_step_km = self.get_float(\"General\", \"ZoomStepKM\", 1.0)\n        if zoom_step_km &lt; 0.01:\n            save_zoomed_plot = False\n        close_plot = self.get_bool(\"General\", \"ClosePlots\", False)\n    else:\n        save_plot = False\n        save_zoomed_plot = False\n        close_plot = False\n\n    data = {\n        \"plot_data\": plot_data,\n        \"save_plot\": save_plot,\n        \"save_zoomed_plot\": save_zoomed_plot,\n        \"zoom_step_km\": zoom_step_km,\n        \"close_plot\": close_plot,\n    }\n\n    # as appropriate, check output dir for figures and file format\n    if save_plot:\n        fig_dir = self.get_str(\"General\", \"FigureDir\", Path(root_dir) / \"figure\")\n        self.log_data.log_text(\"figure_dir\", data={\"dir\": fig_dir})\n        path_fig_dir = Path(fig_dir)\n        if path_fig_dir.exists():\n            self.log_data.log_text(\"overwrite_dir\", data={\"dir\": fig_dir})\n        path_fig_dir.mkdir(parents=True, exist_ok=True)\n        plot_ext = self.get_str(\"General\", \"FigureExt\", \".png\")\n        data = data | {\n            \"save_dir\": fig_dir,\n            \"plot_extension\": plot_ext,\n        }\n\n    return PlotProperties(**data)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.get_range","title":"<code>get_range(group: str, key: str) -&gt; Tuple[float, float]</code>","text":"<p>Get a start and end value from a selected group and keyword in the analysis settings.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group from which to read.</p> required <code>key</code> <code>str</code> <p>Name of the keyword from which to read.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float,float]: Lower and upper limit of the range.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.get_range(\"General\", \"Boundaries\")\n(123.0, 128.0)\n</code></pre> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def get_range(self, group: str, key: str) -&gt; Tuple[float, float]:\n    \"\"\"Get a start and end value from a selected group and keyword in the analysis settings.\n\n    Args:\n        group (str): Name of the group from which to read.\n        key (str): Name of the keyword from which to read.\n\n    Returns:\n        Tuple[float,float]: Lower and upper limit of the range.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.get_range(\"General\", \"Boundaries\")\n        (123.0, 128.0)\n\n        ```\n    \"\"\"\n    str_val = self.get_str(group, key)\n    try:\n        obrack = str_val.find(\"[\")\n        cbrack = str_val.find(\"]\")\n        if obrack &gt;= 0 and cbrack &gt;= 0:\n            str_val = str_val[obrack + 1 : cbrack - 1]\n        val_list = [float(fstr) for fstr in str_val.split(\":\")]\n        if val_list[0] &gt; val_list[1]:\n            val = (val_list[1], val_list[0])\n        else:\n            val = (val_list[0], val_list[1])\n    except ValueError as e:\n        raise ValueError(\n            f'Invalid range specification \"{str_val}\" for required keyword \"{key}\" in block \"{group}\".'\n        ) from e\n    return val\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.get_river_center_line","title":"<code>get_river_center_line() -&gt; LineString</code>","text":"<p>Get the river center line from the xyc file as a linestring.</p> <p>Returns:</p> Name Type Description <code>LineString</code> <code>LineString</code> <p>Chainage line.</p> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def get_river_center_line(self) -&gt; LineString:\n    \"\"\"Get the river center line from the xyc file as a linestring.\n\n    Returns:\n        LineString: Chainage line.\n    \"\"\"\n    # get the chainage file\n    river_center_line_file = self.get_str(\"General\", \"RiverKM\")\n    self.log_data.log_text(\"read_chainage\", data={\"file\": river_center_line_file})\n    river_center_line = XYCModel.read(river_center_line_file, num_columns=3)\n\n    # make sure that chainage is increasing with node index\n    if river_center_line.coords[0][2] &gt; river_center_line.coords[1][2]:\n        river_center_line = LineString(river_center_line.coords[::-1])\n\n    return river_center_line\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.get_search_lines","title":"<code>get_search_lines() -&gt; List[LineString]</code>","text":"<p>Get the search lines for the bank lines from the analysis settings.</p> <p>Returns:</p> Type Description <code>List[LineString]</code> <p>List[np.ndarray]: List of arrays containing the x,y-coordinates of a bank search lines.</p> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def get_search_lines(self) -&gt; List[LineString]:\n    \"\"\"Get the search lines for the bank lines from the analysis settings.\n\n    Returns:\n        List[np.ndarray]: List of arrays containing the x,y-coordinates of a bank search lines.\n    \"\"\"\n    # read guiding bank line\n    n_bank = self.get_int(\"Detect\", \"NBank\")\n    line = []\n    for b in range(n_bank):\n        bankfile = self.config[\"Detect\"][f\"Line{b + 1}\"]\n        self.log_data.log_text(\"read_search_line\", data={\"nr\": b + 1, \"file\": bankfile})\n        line.append(XYCModel.read(bankfile))\n    return line\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.get_sim_file","title":"<code>get_sim_file(group: str, istr: str) -&gt; str</code>","text":"<p>Get the name of the simulation file from the analysis settings.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group in which to search for the simulation file name.</p> required <code>istr</code> <code>str</code> <p>Postfix for the simulation file name keyword; typically a string representation of the index.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name of the simulation file (empty string if keywords are not found).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; result = config_file.get_sim_file(\"Erosion\", \"1\")\n&gt;&gt;&gt; expected = Path(\"tests/data/erosion/inputs/sim0075/SDS-j19_map.nc\").resolve()\n&gt;&gt;&gt; str(expected) == result\nTrue\n</code></pre> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def get_sim_file(self, group: str, istr: str) -&gt; str:\n    \"\"\"Get the name of the simulation file from the analysis settings.\n\n    Args:\n        group (str): Name of the group in which to search for the simulation file name.\n        istr (str): Postfix for the simulation file name keyword;\n            typically a string representation of the index.\n\n    Returns:\n        str: Name of the simulation file (empty string if keywords are not found).\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; result = config_file.get_sim_file(\"Erosion\", \"1\")\n        &gt;&gt;&gt; expected = Path(\"tests/data/erosion/inputs/sim0075/SDS-j19_map.nc\").resolve()\n        &gt;&gt;&gt; str(expected) == result\n        True\n\n        ```\n    \"\"\"\n    sim_file = self.config[group].get(f\"SimFile{istr}\", \"\")\n    return sim_file\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.get_start_end_stations","title":"<code>get_start_end_stations() -&gt; Tuple[float, float]</code>","text":"<p>Get the start and end station for the river.</p> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float, float]: start and end station.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.get_start_end_stations()\n(123.0, 128.0)\n</code></pre> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def get_start_end_stations(self) -&gt; Tuple[float, float]:\n    \"\"\"Get the start and end station for the river.\n\n    Returns:\n        Tuple[float, float]: start and end station.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.get_start_end_stations()\n        (123.0, 128.0)\n\n        ```\n    \"\"\"\n    stations = self.get_range(\"General\", \"Boundaries\")\n\n    return stations\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.get_str","title":"<code>get_str(group: str, key: str, default: Optional[str] = None) -&gt; str</code>","text":"<p>Get a string from a selected group and keyword in the analysis settings.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group from which to read.</p> required <code>key</code> <code>str</code> <p>Name of the keyword from which to read.</p> required <code>default</code> <code>Optional[str]</code> <p>Optional default value.</p> <code>None</code> <p>Raises:</p> Type Description <code>ConfigFileError</code> <p>If the keyword isn't specified and no default value is given.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>value of the keyword as string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; result = config_file.get_str(\"General\", \"BankDir\")\n&gt;&gt;&gt; expected = Path(\"tests/data/erosion/output/banklines\").resolve()\n&gt;&gt;&gt; str(expected) == result\nTrue\n</code></pre> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def get_str(\n    self,\n    group: str,\n    key: str,\n    default: Optional[str] = None,\n) -&gt; str:\n    \"\"\"Get a string from a selected group and keyword in the analysis settings.\n\n    Args:\n        group (str): Name of the group from which to read.\n        key (str): Name of the keyword from which to read.\n        default (Optional[str]): Optional default value.\n\n    Raises:\n        ConfigFileError: If the keyword isn't specified and no default value is given.\n\n    Returns:\n        str: value of the keyword as string.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; result = config_file.get_str(\"General\", \"BankDir\")\n        &gt;&gt;&gt; expected = Path(\"tests/data/erosion/output/banklines\").resolve()\n        &gt;&gt;&gt; str(expected) == result\n        True\n\n        ```\n    \"\"\"\n    try:\n        val = self.config[group][key]\n    except KeyError as e:\n        if default is not None:\n            val = default\n        else:\n            raise ConfigFileError(\n                f\"No value specified for required keyword {key} in block {group}.\"\n            ) from e\n    return val\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.make_paths_absolute","title":"<code>make_paths_absolute() -&gt; str</code>","text":"<p>Convert all relative paths in the configuration to absolute paths.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Absolute path of the configuration file's root directory.</p> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def make_paths_absolute(self) -&gt; str:\n    \"\"\"Convert all relative paths in the configuration to absolute paths.\n\n    Returns:\n        str: Absolute path of the configuration file's root directory.\n    \"\"\"\n    self.resolve(self.root_dir)\n\n    return self.root_dir\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.parameter_relative_to","title":"<code>parameter_relative_to(group: str, key: str, rootdir: str)</code>","text":"<p>Convert a parameter value to contain a relative path.</p> <p>Determine whether the string represents a number. If not, try to convert to a relative path.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group in the configuration.</p> required <code>key</code> <code>str</code> <p>Name of the key in the configuration.</p> required <code>rootdir</code> <code>str</code> <p>The path to be used as base for the relative paths.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.parameter_relative_to(\"General\", \"RiverKM\", \"tests/data/erosion\")\n</code></pre> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def parameter_relative_to(self, group: str, key: str, rootdir: str):\n    \"\"\"Convert a parameter value to contain a relative path.\n\n    Determine whether the string represents a number.\n    If not, try to convert to a relative path.\n\n    Args:\n        group (str): Name of the group in the configuration.\n        key (str): Name of the key in the configuration.\n        rootdir (str): The path to be used as base for the relative paths.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.parameter_relative_to(\"General\", \"RiverKM\", \"tests/data/erosion\")\n\n        ```\n    \"\"\"\n    if key in self.config[group]:\n        val_str = self.config[group][key]\n\n        try:\n            float(val_str)\n        except ValueError:\n            self.config[group][key] = relative_path(rootdir, val_str)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.process_parameter","title":"<code>process_parameter(value: Union[str, float], key: str, num_stations_per_bank: List[int], use_default: bool = False, default: Any = None, ext: str = '', positive: bool = False, valid: Optional[List[float]] = None, onefile: bool = False) -&gt; List[np.ndarray]</code>","text":"<p>Process a parameter value into arrays for each bank.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[str, float]</code> <p>The parameter value or a path to a file.</p> required <code>key</code> <code>str</code> <p>Name of the parameter for error messages.</p> required <code>num_stations_per_bank</code> <code>List[int]</code> <p>Number of stations for each bank.</p> required <code>use_default</code> <code>bool</code> <p>Whether to use the default value.</p> <code>False</code> <code>default</code> <code>Optional[float], default=None</code> <p>Default value used if <code>use_default</code> is True.</p> <code>None</code> <code>ext</code> <code>str, default=''</code> <p>File name extension.</p> <code>''</code> <code>positive</code> <code>bool, default=False</code> <p>If True, only positive values are allowed.</p> <code>False</code> <code>valid</code> <code>Optional[List[float]], default=None</code> <p>List of valid values.</p> <code>None</code> <code>onefile</code> <code>bool, default=False</code> <p>If True, parameters are read from a single file for all banks; otherwise, one file per bank.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>List[np.ndarray]: Parameter values for each bank.</p> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def process_parameter(\n    self,\n    value: Union[str, float],\n    key: str,\n    num_stations_per_bank: List[int],\n    use_default: bool = False,\n    default: Any = None,\n    ext: str = \"\",\n    positive: bool = False,\n    valid: Optional[List[float]] = None,\n    onefile: bool = False,\n) -&gt; List[np.ndarray]:\n    \"\"\"\n    Process a parameter value into arrays for each bank.\n\n    Args:\n        value (Union[str, float]):\n            The parameter value or a path to a file.\n        key (str):\n            Name of the parameter for error messages.\n        num_stations_per_bank (List[int]):\n            Number of stations for each bank.\n        use_default (bool):\n            Whether to use the default value.\n        default (Optional[float], default=None):\n            Default value used if `use_default` is True.\n        ext (str, default=''):\n            File name extension.\n        positive (bool, default=False):\n            If True, only positive values are allowed.\n        valid (Optional[List[float]], default=None):\n            List of valid values.\n        onefile (bool, default=False):\n            If True, parameters are read from a single file for all banks;\n            otherwise, one file per bank.\n\n    Returns:\n        List[np.ndarray]: Parameter values for each bank.\n    \"\"\"\n    # if val is value then use that value globally\n    parameter_values = []\n    try:\n        if use_default:\n            if isinstance(default, list):\n                return default\n            real_val = default\n        else:\n            real_val = float(value)\n            self.validate_parameter_value(real_val, key, positive, valid)\n\n        for num_stations in num_stations_per_bank:\n            parameter_values.append(np.zeros(num_stations) + real_val)\n\n    except (ValueError, TypeError):\n        if onefile:\n            self.log_data.log_text(\"read_param\", data={\"param\": key, \"file\": value})\n            km_thr, val = _get_stations(value, key, positive)\n\n        for ib, num_stations in enumerate(num_stations_per_bank):\n            if not onefile:\n                filename_i = f\"{value}_{ib + 1}{ext}\"\n                self.log_data.log_text(\n                    \"read_param_one_bank\",\n                    data={\"param\": key, \"i\": ib + 1, \"file\": filename_i},\n                )\n                km_thr, val = _get_stations(filename_i, key, positive)\n\n            if km_thr is None:\n                parameter_values.append(np.zeros(num_stations) + val[0])\n            else:\n                idx = np.zeros(num_stations, dtype=int)\n\n                for thr in km_thr:\n                    idx[num_stations &gt;= thr] += 1\n                parameter_values.append(val[idx])\n\n    return parameter_values\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.read","title":"<code>read(path: Union[str, Path]) -&gt; 'ConfigFile'</code>  <code>classmethod</code>","text":"<p>Read a configParser object (configuration file).</p> <p>Reads the config file using the standard <code>configparser</code>. Falls back to a dedicated reader compatible with old waqbank files.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the configuration file.</p> required <p>Returns:</p> Name Type Description <code>ConfigFile</code> <code>'ConfigFile'</code> <p>Settings for the D-FAST Bank Erosion analysis.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the configuration file does not exist.</p> <code>Exception</code> <p>If there is an error reading the config file.</p> <p>Examples:</p> <p>Read a config file: <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n</code></pre></p> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>@classmethod\ndef read(cls, path: Union[str, Path]) -&gt; \"ConfigFile\":\n    \"\"\"Read a configParser object (configuration file).\n\n    Reads the config file using the standard `configparser`. Falls back to a\n    dedicated reader compatible with old waqbank files.\n\n    Args:\n        path (Union[str, Path]): Path to the configuration file.\n\n    Returns:\n        ConfigFile: Settings for the D-FAST Bank Erosion analysis.\n\n    Raises:\n        FileNotFoundError: If the configuration file does not exist.\n        Exception: If there is an error reading the config file.\n\n    Examples:\n        Read a config file:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n\n        ```\n    \"\"\"\n    if not Path(path).exists():\n        raise FileNotFoundError(f\"The Config-File: {path} does not exist\")\n\n    try:\n        config = ConfigParser(comment_prefixes=\"%\")\n        with open(path, \"r\") as configfile:\n            config.read_file(configfile)\n    except ConfigparserError as e:\n        print(f\"Error during reading the config file: {e}\")\n        config = cls.config_file_callback_parser(path)\n\n    # if version != \"1.0\":\n    config = cls._upgrade(config)\n    return cls(config, path=path)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.read_bank_lines","title":"<code>read_bank_lines(bank_dir: str) -&gt; List[np.ndarray] | GeoDataFrame</code>","text":"<p>Get the bank lines from the detection step.</p> <p>Parameters:</p> Name Type Description Default <code>bank_dir</code> <code>str</code> <p>Name of directory in which the bank lines files are located.</p> required <p>Returns:</p> Type Description <code>List[ndarray] | GeoDataFrame</code> <p>List[np.ndarray]: List of arrays containing the x,y-coordinates of a bank lines.</p> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def read_bank_lines(self, bank_dir: str) -&gt; List[np.ndarray] | GeoDataFrame:\n    \"\"\"Get the bank lines from the detection step.\n\n    Args:\n        bank_dir (str): Name of directory in which the bank lines files are located.\n\n    Returns:\n        List[np.ndarray]: List of arrays containing the x,y-coordinates of a bank lines.\n    \"\"\"\n    bank_name = self.get_str(\"General\", \"BankFile\", \"bankfile\")\n    bankfile = Path(bank_dir) / f\"{bank_name}.shp\"\n    if bankfile.exists():\n        self.log_data.log_text(\"read_banklines\", data={\"file\": str(bankfile)})\n        return gpd.read_file(bankfile)\n\n    bankfile = Path(bank_dir) / f\"{bank_name}_#.xyc\"\n    self.log_data.log_text(\"read_banklines\", data={\"file\": str(bankfile)})\n    bankline_list = []\n    b = 1\n    while True:\n        xyc_file = Path(bank_dir) / f\"{bank_name}_{b}.xyc\"\n        if not xyc_file.exists():\n            break\n\n        xy_bank = XYCModel.read(xyc_file)\n        bankline_list.append(LineString(xy_bank))\n        b += 1\n    bankline_series = GeoSeries(bankline_list, crs=self.crs)\n    banklines = GeoDataFrame(geometry=bankline_series)\n    return banklines\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.relative_to","title":"<code>relative_to(rootdir: str) -&gt; None</code>","text":"<p>Convert a configuration object to contain relative paths (for saving).</p> <p>Parameters:</p> Name Type Description Default <code>rootdir</code> <code>str</code> <p>The path to be used as base for the relative paths.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.relative_to(\"testing/data/erosion\")\n</code></pre> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def relative_to(self, rootdir: str) -&gt; None:\n    \"\"\"Convert a configuration object to contain relative paths (for saving).\n\n    Args:\n        rootdir (str): The path to be used as base for the relative paths.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.relative_to(\"testing/data/erosion\")\n\n        ```\n    \"\"\"\n    if \"General\" in self.config:\n        self.parameter_relative_to(\"General\", \"RiverKM\", rootdir)\n        self.parameter_relative_to(\"General\", \"BankDir\", rootdir)\n        self.parameter_relative_to(\"General\", \"FigureDir\", rootdir)\n\n    if \"Detect\" in self.config:\n        self.parameter_relative_to(\"Detect\", \"SimFile\", rootdir)\n\n        i = 0\n        while True:\n            i = i + 1\n            line_i = f\"Line{i}\"\n            if line_i in self.config[\"Detect\"]:\n                self.parameter_relative_to(\"Detect\", line_i, rootdir)\n            else:\n                break\n\n    if \"Erosion\" in self.config:\n        self.parameter_relative_to(\"Erosion\", \"RiverAxis\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"Fairway\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"OutputDir\", rootdir)\n\n        self.parameter_relative_to(\"Erosion\", \"ShipType\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"VShip\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"NShip\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"NWave\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"Draught\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"Wave0\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"Wave1\", rootdir)\n\n        self.parameter_relative_to(\"Erosion\", \"BankType\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"ProtectionLevel\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"Slope\", rootdir)\n        self.parameter_relative_to(\"Erosion\", \"Reed\", rootdir)\n\n        n_level = self.get_int(\"Erosion\", \"NLevel\", default=0)\n        for i in range(1, n_level + 1):\n            self.parameter_relative_to(\"Erosion\", f\"SimFile{i}\", rootdir)\n            self.parameter_relative_to(\"Erosion\", f\"ShipType{i}\", rootdir)\n            self.parameter_relative_to(\"Erosion\", f\"VShip{i}\", rootdir)\n            self.parameter_relative_to(\"Erosion\", f\"NShip{i}\", rootdir)\n            self.parameter_relative_to(\"Erosion\", f\"NWave{i}\", rootdir)\n            self.parameter_relative_to(\"Erosion\", f\"Draught{i}\", rootdir)\n            self.parameter_relative_to(\"Erosion\", f\"Slope{i}\", rootdir)\n            self.parameter_relative_to(\"Erosion\", f\"Reed{i}\", rootdir)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.resolve","title":"<code>resolve(rootdir: str)</code>","text":"<p>Convert a configuration object to contain absolute paths (for editing).</p> <p>Parameters:</p> Name Type Description Default <code>rootdir</code> <code>str</code> <p>The path to be used as base for the absolute paths.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.resolve(\"tests/data/erosion\")\n</code></pre> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def resolve(self, rootdir: str):\n    \"\"\"Convert a configuration object to contain absolute paths (for editing).\n\n    Args:\n        rootdir (str): The path to be used as base for the absolute paths.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.resolve(\"tests/data/erosion\")\n\n        ```\n    \"\"\"\n    if \"General\" in self.config:\n        self.resolve_parameter(\"General\", \"RiverKM\", rootdir)\n        self.resolve_parameter(\"General\", \"BankDir\", rootdir)\n        self.resolve_parameter(\"General\", \"FigureDir\", rootdir)\n\n    if \"Detect\" in self.config:\n        self.resolve_parameter(\"Detect\", \"SimFile\", rootdir)\n        i = 0\n        while True:\n            i = i + 1\n            line_i = \"Line\" + str(i)\n            if line_i in self.config[\"Detect\"]:\n                self.resolve_parameter(\"Detect\", line_i, rootdir)\n            else:\n                break\n\n    if \"Erosion\" in self.config:\n        self.resolve_parameter(\"Erosion\", \"RiverAxis\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"Fairway\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"OutputDir\", rootdir)\n\n        self.resolve_parameter(\"Erosion\", \"ShipType\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"VShip\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"NShip\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"NWave\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"Draught\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"Wave0\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"Wave1\", rootdir)\n\n        self.resolve_parameter(\"Erosion\", \"BankType\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"ProtectionLevel\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"Slope\", rootdir)\n        self.resolve_parameter(\"Erosion\", \"Reed\", rootdir)\n\n        n_level = self.get_int(\"Erosion\", \"NLevel\", default=0)\n        for i in range(1, n_level + 1):\n            self.resolve_parameter(\"Erosion\", f\"SimFile{i}\", rootdir)\n            self.resolve_parameter(\"Erosion\", f\"ShipType{i}\", rootdir)\n            self.resolve_parameter(\"Erosion\", f\"VShip{i}\", rootdir)\n            self.resolve_parameter(\"Erosion\", f\"NShip{i}\", rootdir)\n            self.resolve_parameter(\"Erosion\", f\"NWave{i}\", rootdir)\n            self.resolve_parameter(\"Erosion\", f\"Draught{i}\", rootdir)\n            self.resolve_parameter(\"Erosion\", f\"Slope{i}\", rootdir)\n            self.resolve_parameter(\"Erosion\", f\"Reed{i}\", rootdir)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.resolve_parameter","title":"<code>resolve_parameter(group: str, key: str, rootdir: str)</code>","text":"<p>Convert a parameter value to contain an absolute path.</p> <p>Determine whether the string represents a number. If not, try to convert to an absolute path.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Name of the group in the configuration.</p> required <code>key</code> <code>str</code> <p>Name of the key in the configuration.</p> required <code>rootdir</code> <code>str</code> <p>The path to be used as base for the absolute paths.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; config_file.resolve_parameter(\"General\", \"RiverKM\", \"tests/data/erosion\")\n</code></pre> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def resolve_parameter(self, group: str, key: str, rootdir: str):\n    \"\"\"Convert a parameter value to contain an absolute path.\n\n    Determine whether the string represents a number.\n    If not, try to convert to an absolute path.\n\n    Args:\n        group (str): Name of the group in the configuration.\n        key (str): Name of the key in the configuration.\n        rootdir (str): The path to be used as base for the absolute paths.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; config_file.resolve_parameter(\"General\", \"RiverKM\", \"tests/data/erosion\")\n\n        ```\n    \"\"\"\n    if key in self.config[group]:\n        val_str = self.config[group][key]\n        try:\n            float(val_str)\n        except ValueError:\n            self.config[group][key] = absolute_path(rootdir, val_str)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.validate_parameter_value","title":"<code>validate_parameter_value(value: float, key: str, positive: bool = False, valid: Optional[List[float]] = None) -&gt; float</code>","text":"<p>Validate a parameter value against constraints.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The parameter value to validate.</p> required <code>key</code> <code>str</code> <p>Name of the parameter for error messages.</p> required <code>positive</code> <code>bool</code> <p>Flag specifying whether all values are accepted (if False), or only positive values (if True); default False.</p> <code>False</code> <code>valid</code> <code>Optional[List[float]]</code> <p>Optional list of valid values; default None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value doesn't meet the constraints.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The validated parameter value.</p> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def validate_parameter_value(\n    self,\n    value: float,\n    key: str,\n    positive: bool = False,\n    valid: Optional[List[float]] = None,\n) -&gt; float:\n    \"\"\"Validate a parameter value against constraints.\n\n    Args:\n        value (float): The parameter value to validate.\n        key (str): Name of the parameter for error messages.\n        positive (bool): Flag specifying whether all values are accepted (if False),\n            or only positive values (if True); default False.\n        valid (Optional[List[float]]): Optional list of valid values; default None.\n\n    Raises:\n        ValueError: If the value doesn't meet the constraints.\n\n    Returns:\n        float: The validated parameter value.\n    \"\"\"\n    if positive and value &lt; 0:\n        raise ValueError(f'Value of \"{key}\" should be positive, not {value}.')\n    if valid is not None and valid.count(value) == 0:\n        raise ValueError(f'Value of \"{key}\" should be in {valid}, not {value}.')\n    return value\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFile.write","title":"<code>write(filename: str) -&gt; None</code>","text":"<p>Pretty print a configParser object (configuration file) to file.</p> <p>Pretty prints a <code>configparser</code> object to a file. Aligns the equal signs for all keyword/value pairs, adds a two-space indentation to all keyword lines, and adds an empty line before the start of a new block.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of the configuration file to be written.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdirname:\n...     config_file.write(f\"{tmpdirname}/meuse_manual_out.cfg\")\n</code></pre> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def write(self, filename: str) -&gt; None:\n    \"\"\"Pretty print a configParser object (configuration file) to file.\n\n    Pretty prints a `configparser` object to a file. Aligns the equal signs for\n    all keyword/value pairs, adds a two-space indentation to all keyword lines,\n    and adds an empty line before the start of a new block.\n\n    Args:\n        filename (str): Name of the configuration file to be written.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; import tempfile\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdirname:\n        ...     config_file.write(f\"{tmpdirname}/meuse_manual_out.cfg\")\n\n        ```\n    \"\"\"\n    sections = self.config.sections()\n    max_length = 0\n    for section in sections:\n        options = self.config.options(section)\n        max_length = max(max_length, *[len(option) for option in options])\n\n    with open(filename, \"w\") as configfile:\n        for index, section in enumerate(sections):\n            if index &gt; 0:\n                configfile.write(\"\\n\")\n            configfile.write(f\"[{section}]\\n\")\n\n            for option in self.config.options(section):\n                configfile.write(\n                    f\"  {option:&lt;{max_length}} = {self.config[section][option]}\\n\"\n                )\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.ConfigFileError","title":"<code>ConfigFileError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for configuration file errors.</p> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>class ConfigFileError(Exception):\n    \"\"\"Custom exception for configuration file errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.PlotProperties","title":"<code>PlotProperties</code>  <code>dataclass</code>","text":"<p>Class to hold plotting flags for the erosion simulation.</p> <p>Parameters:</p> Name Type Description Default <code>plot_data</code> <code>bool</code> <p>Flag to indicate if data should be plotted.</p> required <code>save_plot</code> <code>bool</code> <p>Flag to indicate if the plot should be saved.</p> required <code>save_zoomed_plot</code> <code>bool</code> <p>Flag to indicate if the zoomed plot should be saved.</p> required <code>close_plot</code> <code>bool</code> <p>Flag to indicate if the plot should be closed after saving.</p> required <code>zoom_step_km</code> <code>float</code> <p>Step size for zooming in kilometers.</p> <code>1.0</code> <code>save_dir</code> <code>Optional[str]</code> <p>Directory where figures are saved.</p> <code>None</code> <code>plot_extension</code> <code>str</code> <p>File extension for saved plots.</p> <code>'.png'</code> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>@dataclass\nclass PlotProperties:\n    \"\"\"Class to hold plotting flags for the erosion simulation.\n\n    Args:\n        plot_data (bool):\n            Flag to indicate if data should be plotted.\n        save_plot (bool):\n            Flag to indicate if the plot should be saved.\n        save_zoomed_plot (bool):\n            Flag to indicate if the zoomed plot should be saved.\n        close_plot (bool):\n            Flag to indicate if the plot should be closed after saving.\n        zoom_step_km (float):\n            Step size for zooming in kilometers.\n        save_dir (Optional[str]):\n            Directory where figures are saved.\n        plot_extension (str):\n            File extension for saved plots.\n    \"\"\"\n\n    plot_data: bool\n    save_plot: bool\n    save_zoomed_plot: bool\n    close_plot: bool\n    zoom_step_km: float = 1.0\n    save_dir: Optional[str] = None\n    plot_extension: str = \".png\"\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.SimulationFilesError","title":"<code>SimulationFilesError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for configuration file errors.</p> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>class SimulationFilesError(Exception):\n    \"\"\"Custom exception for configuration file errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/io.html#dfastbe.io.config.get_bbox","title":"<code>get_bbox(coords: np.ndarray, buffer: float = 0.1) -&gt; Tuple[float, float, float, float]</code>","text":"<p>Derive the bounding box from a line.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>ndarray</code> <p>An N x M array containing x- and y-coordinates as first two M entries</p> required <code>buffer </code> <p>float Buffer fraction surrounding the tight bounding box</p> required <p>Returns:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>Tuple bounding box consisting of [min x, min y, max x, max y)</p> Source code in <code>src/dfastbe/io/config.py</code> <pre><code>def get_bbox(\n    coords: np.ndarray, buffer: float = 0.1\n) -&gt; Tuple[float, float, float, float]:\n    \"\"\"\n    Derive the bounding box from a line.\n\n    Args:\n        coords (np.ndarray):\n            An N x M array containing x- and y-coordinates as first two M entries\n        buffer : float\n            Buffer fraction surrounding the tight bounding box\n\n    Returns:\n        bbox (Tuple[float, float, float, float]):\n            Tuple bounding box consisting of [min x, min y, max x, max y)\n    \"\"\"\n    x = coords[:, 0]\n    y = coords[:, 1]\n    x_min = x.min()\n    y_min = y.min()\n    x_max = x.max()\n    y_max = y.max()\n    d = buffer * max(x_max - x_min, y_max - y_min)\n    bbox = (x_min - d, y_min - d, x_max + d, y_max + d)\n\n    return bbox\n</code></pre>"},{"location":"api/io.html#data-models","title":"Data Models","text":"<p>The data models component provides classes for representing various types of data used in the I/O operations.</p>"},{"location":"api/io.html#dfastbe.io.data_models","title":"<code>dfastbe.io.data_models</code>","text":"<p>Copyright (C) 2025 Stichting Deltares.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation version 2.1.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, see http://www.gnu.org/licenses/.</p> <p>contact: delft3d.support@deltares.nl Stichting Deltares P.O. Box 177 2600 MH Delft, The Netherlands</p> <p>All indications and logos of, and references to, \"Delft3D\" and \"Deltares\" are registered trademarks of Stichting Deltares, and remain the property of Stichting Deltares. All rights reserved.</p> <p>INFORMATION This file is part of D-FAST Bank Erosion: https://github.com/Deltares/D-FAST_Bank_Erosion</p>"},{"location":"api/io.html#dfastbe.io.data_models.BaseRiverData","title":"<code>BaseRiverData</code>","text":"<p>River data class.</p> Source code in <code>src/dfastbe/io/data_models.py</code> <pre><code>class BaseRiverData:\n    \"\"\"River data class.\"\"\"\n\n    def __init__(self, config_file: ConfigFile):\n        \"\"\"River Data initialization.\n\n        Args:\n            config_file (ConfigFile):\n                Configuration file with settings for the analysis.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.data_models import ConfigFile, BaseRiverData\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n            &gt;&gt;&gt; river_data = BaseRiverData(config_file)\n            No message found for read_chainage\n            No message found for clip_chainage\n\n            ```\n        \"\"\"\n        self.config_file = config_file\n        center_line = config_file.get_river_center_line()\n        bounds = config_file.get_start_end_stations()\n        self._river_center_line = LineGeometry(center_line, bounds, crs=config_file.crs)\n        self._station_bounds: Tuple = config_file.get_start_end_stations()\n\n    @property\n    def river_center_line(self) -&gt; LineGeometry:\n        \"\"\"LineGeometry: the clipped river center line.\"\"\"\n        return self._river_center_line\n\n    @property\n    def station_bounds(self) -&gt; Tuple[float, float]:\n        \"\"\"Tuple: the lower and upper bounds of the river center line.\"\"\"\n        return self._station_bounds\n\n    @staticmethod\n    def get_bbox(\n        coords: np.ndarray, buffer: float = 0.1\n    ) -&gt; Tuple[float, float, float, float]:\n        \"\"\"\n        Derive the bounding box from an array of coordinates.\n\n        Args:\n            coords (np.ndarray):\n                An N x M array containing x- and y-coordinates as first two M entries\n            buffer : float\n                Buffer fraction surrounding the tight bounding box\n\n        Returns:\n            bbox (Tuple[float, float, float, float]):\n                Tuple bounding box consisting of [min x, min y, max x, max y)\n        \"\"\"\n        return get_bbox(coords, buffer)\n\n    def get_erosion_sim_data(self, num_discharge_levels: int) -&gt; Tuple[List[str], List[float]]:\n        # get p discharges\n        sim_files = []\n        p_discharge = []\n        for iq in range(num_discharge_levels):\n            iq_str = str(iq + 1)\n            sim_files.append(self.config_file.get_sim_file(\"Erosion\", iq_str))\n            p_discharge.append(\n                self.config_file.get_float(\"Erosion\", f\"PDischarge{iq_str}\")\n            )\n        return sim_files, p_discharge\n</code></pre>"},{"location":"api/io.html#dfastbe.io.data_models.BaseRiverData.river_center_line","title":"<code>river_center_line: LineGeometry</code>  <code>property</code>","text":"<p>LineGeometry: the clipped river center line.</p>"},{"location":"api/io.html#dfastbe.io.data_models.BaseRiverData.station_bounds","title":"<code>station_bounds: Tuple[float, float]</code>  <code>property</code>","text":"<p>Tuple: the lower and upper bounds of the river center line.</p>"},{"location":"api/io.html#dfastbe.io.data_models.BaseRiverData.__init__","title":"<code>__init__(config_file: ConfigFile)</code>","text":"<p>River Data initialization.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>ConfigFile</code> <p>Configuration file with settings for the analysis.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.data_models import ConfigFile, BaseRiverData\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n&gt;&gt;&gt; river_data = BaseRiverData(config_file)\nNo message found for read_chainage\nNo message found for clip_chainage\n</code></pre> Source code in <code>src/dfastbe/io/data_models.py</code> <pre><code>def __init__(self, config_file: ConfigFile):\n    \"\"\"River Data initialization.\n\n    Args:\n        config_file (ConfigFile):\n            Configuration file with settings for the analysis.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.data_models import ConfigFile, BaseRiverData\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/erosion/meuse_manual.cfg\")\n        &gt;&gt;&gt; river_data = BaseRiverData(config_file)\n        No message found for read_chainage\n        No message found for clip_chainage\n\n        ```\n    \"\"\"\n    self.config_file = config_file\n    center_line = config_file.get_river_center_line()\n    bounds = config_file.get_start_end_stations()\n    self._river_center_line = LineGeometry(center_line, bounds, crs=config_file.crs)\n    self._station_bounds: Tuple = config_file.get_start_end_stations()\n</code></pre>"},{"location":"api/io.html#dfastbe.io.data_models.BaseRiverData.get_bbox","title":"<code>get_bbox(coords: np.ndarray, buffer: float = 0.1) -&gt; Tuple[float, float, float, float]</code>  <code>staticmethod</code>","text":"<p>Derive the bounding box from an array of coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>ndarray</code> <p>An N x M array containing x- and y-coordinates as first two M entries</p> required <code>buffer </code> <p>float Buffer fraction surrounding the tight bounding box</p> required <p>Returns:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>Tuple bounding box consisting of [min x, min y, max x, max y)</p> Source code in <code>src/dfastbe/io/data_models.py</code> <pre><code>@staticmethod\ndef get_bbox(\n    coords: np.ndarray, buffer: float = 0.1\n) -&gt; Tuple[float, float, float, float]:\n    \"\"\"\n    Derive the bounding box from an array of coordinates.\n\n    Args:\n        coords (np.ndarray):\n            An N x M array containing x- and y-coordinates as first two M entries\n        buffer : float\n            Buffer fraction surrounding the tight bounding box\n\n    Returns:\n        bbox (Tuple[float, float, float, float]):\n            Tuple bounding box consisting of [min x, min y, max x, max y)\n    \"\"\"\n    return get_bbox(coords, buffer)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.data_models.BaseSimulationData","title":"<code>BaseSimulationData</code>","text":"<p>Class to hold simulation data.</p> <p>This class contains the simulation data read from a UGRID netCDF file. It includes methods to read the data from the file and clip the simulation mesh to a specified area of interest.</p> Source code in <code>src/dfastbe/io/data_models.py</code> <pre><code>class BaseSimulationData:\n    \"\"\"Class to hold simulation data.\n\n    This class contains the simulation data read from a UGRID netCDF file.\n    It includes methods to read the data from the file and clip the simulation\n    mesh to a specified area of interest.\n    \"\"\"\n\n    def __init__(\n        self,\n        x_node: np.ndarray,\n        y_node: np.ndarray,\n        n_nodes: np.ndarray,\n        face_node: np.ma.masked_array,\n        bed_elevation_location: np.ndarray,\n        bed_elevation_values: np.ndarray,\n        water_level_face: np.ndarray,\n        water_depth_face: np.ndarray,\n        velocity_x_face: np.ndarray,\n        velocity_y_face: np.ndarray,\n        chezy_face: np.ndarray,\n        dry_wet_threshold: float,\n    ):\n        \"\"\"\n        Initialize the SimulationData object.\n\n        Args:\n        x_node (np.ndarray):\n            X-coordinates of the nodes.\n        y_node (np.ndarray):\n            Y-coordinates of the nodes.\n        n_nodes (np.ndarray):\n            Number of nodes in each face.\n        face_node (np.ma.masked_array):\n            Face-node connectivity array.\n        bed_elevation_location (np.ndarray):\n            Determines whether the bed elevation is associated with nodes\n            or faces in the computational mesh.\n        bed_elevation_values (np.ndarray):\n            Bed elevation values for each node in the simulation data.\n        water_level_face (np.ndarray):\n            Water levels at the faces.\n        water_depth_face (np.ndarray):\n            Water depths at the faces.\n        velocity_x_face (np.ndarray):\n            X-component of the velocity at the faces.\n        velocity_y_face (np.ndarray):\n            Y-component of the velocity at the faces.\n        chezy_face (np.ndarray):\n            Chezy roughness values at the faces.\n        dry_wet_threshold (float):\n            Threshold depth for detecting drying and flooding.\n        \"\"\"\n        self.x_node = x_node\n        self.y_node = y_node\n        self.n_nodes = n_nodes\n        self.face_node = face_node\n        self.bed_elevation_location = bed_elevation_location\n        self.bed_elevation_values = bed_elevation_values\n        self.water_level_face = water_level_face\n        self.water_depth_face = water_depth_face\n        self.velocity_x_face = velocity_x_face\n        self.velocity_y_face = velocity_y_face\n        self.chezy_face = chezy_face\n        self.dry_wet_threshold = dry_wet_threshold\n\n    @classmethod\n    def read(cls, file_name: str, indent: str = \"\") -&gt; \"BaseSimulationData\":\n        \"\"\"Read a default set of quantities from a UGRID netCDF file.\n\n        Supported files are coming from D-Flow FM (or similar).\n\n        Args:\n            file_name (str):\n                Name of the simulation output file to be read.\n            indent (str):\n                String to use for each line as indentation (default empty).\n\n        Raises:\n            SimulationFilesError:\n                If the file is not recognized as a D-Flow FM map-file.\n\n        Returns:\n            BaseSimulationData (Tuple[BaseSimulationData, float]):\n                Dictionary containing the data read from the simulation output file.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.data_models import BaseSimulationData\n            &gt;&gt;&gt; sim_data = BaseSimulationData.read(\"tests/data/erosion/inputs/sim0075/SDS-j19_map.nc\") # doctest: +ELLIPSIS\n            No message ... read_drywet\n            &gt;&gt;&gt; print(sim_data.x_node[0:3])\n            [194949.796875 194966.515625 194982.8125  ]\n\n            ```\n        \"\"\"\n        name = Path(file_name).name\n        if name.endswith(\"map.nc\"):\n            LogData().log_text(\"read_grid\", indent=indent)\n\n            # read the node coordinates\n            x_node = _read_fm_map(file_name, \"x\", location=\"node\")\n            y_node = _read_fm_map(file_name, \"y\", location=\"node\")\n\n            # read the face node connectivity and make sure it's a masked array\n            f_nc_read = _read_fm_map(file_name, \"face_node_connectivity\")\n            if isinstance(f_nc_read, np.ma.MaskedArray):\n                f_nc = f_nc_read\n                # make sure the mask is a full array\n                if f_nc.mask.size == 1:\n                    f_nc.mask = np.full(f_nc.shape, False)\n            else:\n                f_nc = np.ma.MaskedArray(f_nc_read, np.full(f_nc_read.shape, False))\n\n            # sometimes the _FillValue is not correctly set or applied in all preprocessing steps\n            # clean-up the indices to make the code more robust:\n\n            # 1) remove negative node indices\n            f_nc.mask[f_nc.data &lt; 0] = True\n            # 2) remove node indices larger than the number of nodes\n            f_nc.mask[f_nc.data &gt; x_node.size-1] = True\n\n            # set all masked node indices to 0, such that indexing operations don't fail\n            f_nc.data[f_nc.mask] = 0\n            n_nodes_per_face = f_nc.mask.shape[1] - f_nc.mask.sum(axis=1)\n\n            face_node = f_nc\n            LogData().log_text(\"read_bathymetry\", indent=indent)\n            bed_elevation_location = \"node\"\n            bed_elevation_values = _read_fm_map(file_name, \"altitude\", location=\"node\")\n            LogData().log_text(\"read_water_level\", indent=indent)\n            water_level_face = _read_fm_map(file_name, \"Water level\")\n            LogData().log_text(\"read_water_depth\", indent=indent)\n            water_depth_face = np.maximum(\n                _read_fm_map(file_name, \"sea_floor_depth_below_sea_surface\"), 0.0\n            )\n            LogData().log_text(\"read_velocity\", indent=indent)\n            velocity_x_face = _read_fm_map(file_name, \"sea_water_x_velocity\")\n            velocity_y_face = _read_fm_map(file_name, \"sea_water_y_velocity\")\n            LogData().log_text(\"read_chezy\", indent=indent)\n            chezy_face = _read_fm_map(file_name, \"Chezy roughness\")\n\n            LogData().log_text(\"read_drywet\", indent=indent)\n            root_group = netCDF4.Dataset(file_name)\n            try:\n                file_source = root_group.converted_from\n                if file_source == \"SIMONA\":\n                    dry_wet_threshold = 0.1\n                else:\n                    dry_wet_threshold = 0.01\n            except AttributeError:\n                dry_wet_threshold = 0.01\n\n        elif name.startswith(\"SDS\"):\n            raise SimulationFilesError(\n                f\"WAQUA output files not yet supported. Unable to process {name}\"\n            )\n        elif name.startswith(\"trim\"):\n            raise SimulationFilesError(\n                f\"Delft3D map files not yet supported. Unable to process {name}\"\n            )\n        else:\n            raise SimulationFilesError(f\"Unable to determine file type for {name}\")\n\n        return cls(\n            x_node=x_node,\n            y_node=y_node,\n            n_nodes=n_nodes_per_face,\n            face_node=face_node,\n            bed_elevation_location=bed_elevation_location,\n            bed_elevation_values=bed_elevation_values,\n            water_level_face=water_level_face,\n            water_depth_face=water_depth_face,\n            velocity_x_face=velocity_x_face,\n            velocity_y_face=velocity_y_face,\n            chezy_face=chezy_face,\n            dry_wet_threshold=dry_wet_threshold,\n        )\n\n    def clip(self, river_center_line: LineString, max_distance: float):\n        \"\"\"Clip the simulation mesh.\n\n        Clipping data to the area of interest,\n        that is sufficiently close to the reference line.\n\n        Args:\n            river_center_line (np.ndarray):\n                Reference line.\n            max_distance (float):\n                Maximum distance between the reference line and a point in the area of\n                interest defined based on the search lines for the banks and the search\n                distance.\n\n        Notes:\n            The function uses the Shapely library to create a buffer around the river\n            profile and checks if the nodes are within that buffer. If they are not,\n            they are removed from the simulation data.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.data_models import BaseSimulationData\n            &gt;&gt;&gt; sim_data = BaseSimulationData.read(\"tests/data/erosion/inputs/sim0075/SDS-j19_map.nc\")\n            No message found for read_grid\n            No message found for read_bathymetry\n            No message found for read_water_level\n            No message found for read_water_depth\n            No message found for read_velocity\n            No message found for read_chezy\n            No message found for read_drywet\n            &gt;&gt;&gt; river_center_line = LineString([\n            ...     [194949.796875, 361366.90625],\n            ...     [194966.515625, 361399.46875],\n            ...     [194982.8125, 361431.03125]\n            ... ])\n            &gt;&gt;&gt; max_distance = 10.0\n            &gt;&gt;&gt; sim_data.clip(river_center_line, max_distance)\n            &gt;&gt;&gt; print(sim_data.x_node)\n            [194949.796875 194966.515625 194982.8125  ]\n\n            ```\n        \"\"\"\n        xy_buffer = river_center_line.buffer(max_distance + max_distance)\n        bbox = xy_buffer.envelope.exterior\n        x_min = bbox.coords[0][0]\n        x_max = bbox.coords[1][0]\n        y_min = bbox.coords[0][1]\n        y_max = bbox.coords[2][1]\n\n        # mark which nodes to keep\n        prepare(xy_buffer)\n        x = self.x_node\n        y = self.y_node\n        nnodes = x.shape\n        keep = (x &gt; x_min) &amp; (x &lt; x_max) &amp; (y &gt; y_min) &amp; (y &lt; y_max)\n        for i in range(x.size):\n            if keep[i] and not xy_buffer.contains(Point((x[i], y[i]))):\n                keep[i] = False\n\n        # mark which faces to keep\n        fnc = self.face_node\n        keep_face_nodes = np.ma.masked_array(keep[fnc], fnc.mask)\n        keep_face = keep_face_nodes.all(axis=1)\n        renum = np.zeros(nnodes, dtype=int)\n        renum[keep] = range(sum(keep))\n        self.face_node = np.ma.masked_array(renum[fnc[keep_face]], fnc.mask[keep_face])\n\n        self.x_node = x[keep]\n        self.y_node = y[keep]\n        if self.bed_elevation_location == \"node\":\n            self.bed_elevation_values = self.bed_elevation_values[keep]\n        else:\n            self.bed_elevation_values = self.bed_elevation_values[keep_face]\n\n        self.n_nodes = self.n_nodes[keep_face]\n        self.water_level_face = self.water_level_face[keep_face]\n        self.water_depth_face = self.water_depth_face[keep_face]\n        self.velocity_x_face = self.velocity_x_face[keep_face]\n        self.velocity_y_face = self.velocity_y_face[keep_face]\n        self.chezy_face = self.chezy_face[keep_face]\n</code></pre>"},{"location":"api/io.html#dfastbe.io.data_models.BaseSimulationData.__init__","title":"<code>__init__(x_node: np.ndarray, y_node: np.ndarray, n_nodes: np.ndarray, face_node: np.ma.masked_array, bed_elevation_location: np.ndarray, bed_elevation_values: np.ndarray, water_level_face: np.ndarray, water_depth_face: np.ndarray, velocity_x_face: np.ndarray, velocity_y_face: np.ndarray, chezy_face: np.ndarray, dry_wet_threshold: float)</code>","text":"<p>Initialize the SimulationData object.</p> <p>x_node (np.ndarray):     X-coordinates of the nodes. y_node (np.ndarray):     Y-coordinates of the nodes. n_nodes (np.ndarray):     Number of nodes in each face. face_node (np.ma.masked_array):     Face-node connectivity array. bed_elevation_location (np.ndarray):     Determines whether the bed elevation is associated with nodes     or faces in the computational mesh. bed_elevation_values (np.ndarray):     Bed elevation values for each node in the simulation data. water_level_face (np.ndarray):     Water levels at the faces. water_depth_face (np.ndarray):     Water depths at the faces. velocity_x_face (np.ndarray):     X-component of the velocity at the faces. velocity_y_face (np.ndarray):     Y-component of the velocity at the faces. chezy_face (np.ndarray):     Chezy roughness values at the faces. dry_wet_threshold (float):     Threshold depth for detecting drying and flooding.</p> Source code in <code>src/dfastbe/io/data_models.py</code> <pre><code>def __init__(\n    self,\n    x_node: np.ndarray,\n    y_node: np.ndarray,\n    n_nodes: np.ndarray,\n    face_node: np.ma.masked_array,\n    bed_elevation_location: np.ndarray,\n    bed_elevation_values: np.ndarray,\n    water_level_face: np.ndarray,\n    water_depth_face: np.ndarray,\n    velocity_x_face: np.ndarray,\n    velocity_y_face: np.ndarray,\n    chezy_face: np.ndarray,\n    dry_wet_threshold: float,\n):\n    \"\"\"\n    Initialize the SimulationData object.\n\n    Args:\n    x_node (np.ndarray):\n        X-coordinates of the nodes.\n    y_node (np.ndarray):\n        Y-coordinates of the nodes.\n    n_nodes (np.ndarray):\n        Number of nodes in each face.\n    face_node (np.ma.masked_array):\n        Face-node connectivity array.\n    bed_elevation_location (np.ndarray):\n        Determines whether the bed elevation is associated with nodes\n        or faces in the computational mesh.\n    bed_elevation_values (np.ndarray):\n        Bed elevation values for each node in the simulation data.\n    water_level_face (np.ndarray):\n        Water levels at the faces.\n    water_depth_face (np.ndarray):\n        Water depths at the faces.\n    velocity_x_face (np.ndarray):\n        X-component of the velocity at the faces.\n    velocity_y_face (np.ndarray):\n        Y-component of the velocity at the faces.\n    chezy_face (np.ndarray):\n        Chezy roughness values at the faces.\n    dry_wet_threshold (float):\n        Threshold depth for detecting drying and flooding.\n    \"\"\"\n    self.x_node = x_node\n    self.y_node = y_node\n    self.n_nodes = n_nodes\n    self.face_node = face_node\n    self.bed_elevation_location = bed_elevation_location\n    self.bed_elevation_values = bed_elevation_values\n    self.water_level_face = water_level_face\n    self.water_depth_face = water_depth_face\n    self.velocity_x_face = velocity_x_face\n    self.velocity_y_face = velocity_y_face\n    self.chezy_face = chezy_face\n    self.dry_wet_threshold = dry_wet_threshold\n</code></pre>"},{"location":"api/io.html#dfastbe.io.data_models.BaseSimulationData.clip","title":"<code>clip(river_center_line: LineString, max_distance: float)</code>","text":"<p>Clip the simulation mesh.</p> <p>Clipping data to the area of interest, that is sufficiently close to the reference line.</p> <p>Parameters:</p> Name Type Description Default <code>river_center_line</code> <code>ndarray</code> <p>Reference line.</p> required <code>max_distance</code> <code>float</code> <p>Maximum distance between the reference line and a point in the area of interest defined based on the search lines for the banks and the search distance.</p> required Notes <p>The function uses the Shapely library to create a buffer around the river profile and checks if the nodes are within that buffer. If they are not, they are removed from the simulation data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.data_models import BaseSimulationData\n&gt;&gt;&gt; sim_data = BaseSimulationData.read(\"tests/data/erosion/inputs/sim0075/SDS-j19_map.nc\")\nNo message found for read_grid\nNo message found for read_bathymetry\nNo message found for read_water_level\nNo message found for read_water_depth\nNo message found for read_velocity\nNo message found for read_chezy\nNo message found for read_drywet\n&gt;&gt;&gt; river_center_line = LineString([\n...     [194949.796875, 361366.90625],\n...     [194966.515625, 361399.46875],\n...     [194982.8125, 361431.03125]\n... ])\n&gt;&gt;&gt; max_distance = 10.0\n&gt;&gt;&gt; sim_data.clip(river_center_line, max_distance)\n&gt;&gt;&gt; print(sim_data.x_node)\n[194949.796875 194966.515625 194982.8125  ]\n</code></pre> Source code in <code>src/dfastbe/io/data_models.py</code> <pre><code>def clip(self, river_center_line: LineString, max_distance: float):\n    \"\"\"Clip the simulation mesh.\n\n    Clipping data to the area of interest,\n    that is sufficiently close to the reference line.\n\n    Args:\n        river_center_line (np.ndarray):\n            Reference line.\n        max_distance (float):\n            Maximum distance between the reference line and a point in the area of\n            interest defined based on the search lines for the banks and the search\n            distance.\n\n    Notes:\n        The function uses the Shapely library to create a buffer around the river\n        profile and checks if the nodes are within that buffer. If they are not,\n        they are removed from the simulation data.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.data_models import BaseSimulationData\n        &gt;&gt;&gt; sim_data = BaseSimulationData.read(\"tests/data/erosion/inputs/sim0075/SDS-j19_map.nc\")\n        No message found for read_grid\n        No message found for read_bathymetry\n        No message found for read_water_level\n        No message found for read_water_depth\n        No message found for read_velocity\n        No message found for read_chezy\n        No message found for read_drywet\n        &gt;&gt;&gt; river_center_line = LineString([\n        ...     [194949.796875, 361366.90625],\n        ...     [194966.515625, 361399.46875],\n        ...     [194982.8125, 361431.03125]\n        ... ])\n        &gt;&gt;&gt; max_distance = 10.0\n        &gt;&gt;&gt; sim_data.clip(river_center_line, max_distance)\n        &gt;&gt;&gt; print(sim_data.x_node)\n        [194949.796875 194966.515625 194982.8125  ]\n\n        ```\n    \"\"\"\n    xy_buffer = river_center_line.buffer(max_distance + max_distance)\n    bbox = xy_buffer.envelope.exterior\n    x_min = bbox.coords[0][0]\n    x_max = bbox.coords[1][0]\n    y_min = bbox.coords[0][1]\n    y_max = bbox.coords[2][1]\n\n    # mark which nodes to keep\n    prepare(xy_buffer)\n    x = self.x_node\n    y = self.y_node\n    nnodes = x.shape\n    keep = (x &gt; x_min) &amp; (x &lt; x_max) &amp; (y &gt; y_min) &amp; (y &lt; y_max)\n    for i in range(x.size):\n        if keep[i] and not xy_buffer.contains(Point((x[i], y[i]))):\n            keep[i] = False\n\n    # mark which faces to keep\n    fnc = self.face_node\n    keep_face_nodes = np.ma.masked_array(keep[fnc], fnc.mask)\n    keep_face = keep_face_nodes.all(axis=1)\n    renum = np.zeros(nnodes, dtype=int)\n    renum[keep] = range(sum(keep))\n    self.face_node = np.ma.masked_array(renum[fnc[keep_face]], fnc.mask[keep_face])\n\n    self.x_node = x[keep]\n    self.y_node = y[keep]\n    if self.bed_elevation_location == \"node\":\n        self.bed_elevation_values = self.bed_elevation_values[keep]\n    else:\n        self.bed_elevation_values = self.bed_elevation_values[keep_face]\n\n    self.n_nodes = self.n_nodes[keep_face]\n    self.water_level_face = self.water_level_face[keep_face]\n    self.water_depth_face = self.water_depth_face[keep_face]\n    self.velocity_x_face = self.velocity_x_face[keep_face]\n    self.velocity_y_face = self.velocity_y_face[keep_face]\n    self.chezy_face = self.chezy_face[keep_face]\n</code></pre>"},{"location":"api/io.html#dfastbe.io.data_models.BaseSimulationData.read","title":"<code>read(file_name: str, indent: str = '') -&gt; BaseSimulationData</code>  <code>classmethod</code>","text":"<p>Read a default set of quantities from a UGRID netCDF file.</p> <p>Supported files are coming from D-Flow FM (or similar).</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Name of the simulation output file to be read.</p> required <code>indent</code> <code>str</code> <p>String to use for each line as indentation (default empty).</p> <code>''</code> <p>Raises:</p> Type Description <code>SimulationFilesError</code> <p>If the file is not recognized as a D-Flow FM map-file.</p> <p>Returns:</p> Name Type Description <code>BaseSimulationData</code> <code>Tuple[BaseSimulationData, float]</code> <p>Dictionary containing the data read from the simulation output file.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.data_models import BaseSimulationData\n&gt;&gt;&gt; sim_data = BaseSimulationData.read(\"tests/data/erosion/inputs/sim0075/SDS-j19_map.nc\") # doctest: +ELLIPSIS\nNo message ... read_drywet\n&gt;&gt;&gt; print(sim_data.x_node[0:3])\n[194949.796875 194966.515625 194982.8125  ]\n</code></pre> Source code in <code>src/dfastbe/io/data_models.py</code> <pre><code>@classmethod\ndef read(cls, file_name: str, indent: str = \"\") -&gt; \"BaseSimulationData\":\n    \"\"\"Read a default set of quantities from a UGRID netCDF file.\n\n    Supported files are coming from D-Flow FM (or similar).\n\n    Args:\n        file_name (str):\n            Name of the simulation output file to be read.\n        indent (str):\n            String to use for each line as indentation (default empty).\n\n    Raises:\n        SimulationFilesError:\n            If the file is not recognized as a D-Flow FM map-file.\n\n    Returns:\n        BaseSimulationData (Tuple[BaseSimulationData, float]):\n            Dictionary containing the data read from the simulation output file.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.data_models import BaseSimulationData\n        &gt;&gt;&gt; sim_data = BaseSimulationData.read(\"tests/data/erosion/inputs/sim0075/SDS-j19_map.nc\") # doctest: +ELLIPSIS\n        No message ... read_drywet\n        &gt;&gt;&gt; print(sim_data.x_node[0:3])\n        [194949.796875 194966.515625 194982.8125  ]\n\n        ```\n    \"\"\"\n    name = Path(file_name).name\n    if name.endswith(\"map.nc\"):\n        LogData().log_text(\"read_grid\", indent=indent)\n\n        # read the node coordinates\n        x_node = _read_fm_map(file_name, \"x\", location=\"node\")\n        y_node = _read_fm_map(file_name, \"y\", location=\"node\")\n\n        # read the face node connectivity and make sure it's a masked array\n        f_nc_read = _read_fm_map(file_name, \"face_node_connectivity\")\n        if isinstance(f_nc_read, np.ma.MaskedArray):\n            f_nc = f_nc_read\n            # make sure the mask is a full array\n            if f_nc.mask.size == 1:\n                f_nc.mask = np.full(f_nc.shape, False)\n        else:\n            f_nc = np.ma.MaskedArray(f_nc_read, np.full(f_nc_read.shape, False))\n\n        # sometimes the _FillValue is not correctly set or applied in all preprocessing steps\n        # clean-up the indices to make the code more robust:\n\n        # 1) remove negative node indices\n        f_nc.mask[f_nc.data &lt; 0] = True\n        # 2) remove node indices larger than the number of nodes\n        f_nc.mask[f_nc.data &gt; x_node.size-1] = True\n\n        # set all masked node indices to 0, such that indexing operations don't fail\n        f_nc.data[f_nc.mask] = 0\n        n_nodes_per_face = f_nc.mask.shape[1] - f_nc.mask.sum(axis=1)\n\n        face_node = f_nc\n        LogData().log_text(\"read_bathymetry\", indent=indent)\n        bed_elevation_location = \"node\"\n        bed_elevation_values = _read_fm_map(file_name, \"altitude\", location=\"node\")\n        LogData().log_text(\"read_water_level\", indent=indent)\n        water_level_face = _read_fm_map(file_name, \"Water level\")\n        LogData().log_text(\"read_water_depth\", indent=indent)\n        water_depth_face = np.maximum(\n            _read_fm_map(file_name, \"sea_floor_depth_below_sea_surface\"), 0.0\n        )\n        LogData().log_text(\"read_velocity\", indent=indent)\n        velocity_x_face = _read_fm_map(file_name, \"sea_water_x_velocity\")\n        velocity_y_face = _read_fm_map(file_name, \"sea_water_y_velocity\")\n        LogData().log_text(\"read_chezy\", indent=indent)\n        chezy_face = _read_fm_map(file_name, \"Chezy roughness\")\n\n        LogData().log_text(\"read_drywet\", indent=indent)\n        root_group = netCDF4.Dataset(file_name)\n        try:\n            file_source = root_group.converted_from\n            if file_source == \"SIMONA\":\n                dry_wet_threshold = 0.1\n            else:\n                dry_wet_threshold = 0.01\n        except AttributeError:\n            dry_wet_threshold = 0.01\n\n    elif name.startswith(\"SDS\"):\n        raise SimulationFilesError(\n            f\"WAQUA output files not yet supported. Unable to process {name}\"\n        )\n    elif name.startswith(\"trim\"):\n        raise SimulationFilesError(\n            f\"Delft3D map files not yet supported. Unable to process {name}\"\n        )\n    else:\n        raise SimulationFilesError(f\"Unable to determine file type for {name}\")\n\n    return cls(\n        x_node=x_node,\n        y_node=y_node,\n        n_nodes=n_nodes_per_face,\n        face_node=face_node,\n        bed_elevation_location=bed_elevation_location,\n        bed_elevation_values=bed_elevation_values,\n        water_level_face=water_level_face,\n        water_depth_face=water_depth_face,\n        velocity_x_face=velocity_x_face,\n        velocity_y_face=velocity_y_face,\n        chezy_face=chezy_face,\n        dry_wet_threshold=dry_wet_threshold,\n    )\n</code></pre>"},{"location":"api/io.html#dfastbe.io.data_models.LineGeometry","title":"<code>LineGeometry</code>","text":"<p>Center line class.</p> Source code in <code>src/dfastbe/io/data_models.py</code> <pre><code>class LineGeometry:\n    \"\"\"Center line class.\"\"\"\n\n    def __init__(self, line: LineString | np.ndarray, mask: Tuple[float, float] = None, crs: str = None):\n        \"\"\"Geometry Line initialization.\n\n        Args:\n            line (LineString):\n                River center line as a linestring.\n            mask (Tuple[float, float], optional):\n                Lower and upper limit for the chainage. Defaults to None.\n            crs (str, Optional):\n                the coordinate reference system number as a string.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; line_string = LineString([(0, 0, 0), (1, 1, 1), (2, 2, 2)])\n            &gt;&gt;&gt; mask = (0.5, 1.5)\n            &gt;&gt;&gt; center_line = LineGeometry(line_string, mask)\n            No message found for clip_chainage\n            &gt;&gt;&gt; np.array(center_line.values.coords)\n            array([[0.5, 0.5, 0.5],\n                   [1. , 1. , 1. ],\n                   [1.5, 1.5, 1.5]])\n\n            ```\n        \"\"\"\n        self.station_bounds = mask\n        self.crs = crs\n        self._data = {}\n        if isinstance(line, np.ndarray):\n            line = LineString(line)\n        if mask is None:\n            self.values = line\n        else:\n            self.values: LineString = self.mask(line, mask)\n\n            LogData().log_text(\n                \"clip_chainage\", data={\"low\": self.station_bounds[0], \"high\": self.station_bounds[1]}\n            )\n\n    @property\n    def data(self) -&gt; Dict[str, np.ndarray]:\n        \"\"\"any data assigned to the line using the `add_data` method.\"\"\"\n        return self._data\n\n    def as_array(self) -&gt; np.ndarray:\n        return np.array(self.values.coords)\n\n    def add_data(self, data: Dict[str, np.ndarray]) -&gt; None:\n        \"\"\"\n        Add data to the LineGeometry object.\n\n        Args:\n            data (Dict[str, np.ndarray]):\n                Dictionary of quantities to be added, each np array should have length k.\n        \"\"\"\n        self._data = self.data | data\n\n    def to_file(\n            self, file_name: str, data: Dict[str, np.ndarray] = None,\n    ) -&gt; None:\n        \"\"\"\n        Write a shape point file with x, y, and values.\n\n        Args:\n            file_name : str\n                Name of the file to be written.\n            data : Dict[str, np.ndarray]\n                Dictionary of quantities to be written, each np array should have length k.\n        \"\"\"\n        xy = self.as_array()\n        geom = [Point(xy_i) for xy_i in xy]\n        if data is None:\n            data = self.data\n        else:\n            data = data | self.data\n        GeoDataFrame(data, geometry=geom, crs=self.crs).to_file(file_name)\n\n    @staticmethod\n    def mask(line_string: LineString, bounds: Tuple[float, float]) -&gt; LineString:\n        \"\"\"Clip a LineGeometry to the relevant reach.\n\n        Args:\n            line_string (LineString):\n                river center line as a linestring.\n            bounds (Tuple[float, float]):\n                Lower and upper limit for the chainage.\n\n        Returns:\n            LineString: Clipped river chainage line.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; line_string = LineString([(0, 0, 0), (1, 1, 1), (2, 2, 2)])\n            &gt;&gt;&gt; bounds = (0.5, 1.5)\n            &gt;&gt;&gt; center_line = LineGeometry.mask(line_string, bounds)\n            &gt;&gt;&gt; np.array(center_line.coords)\n            array([[0.5, 0.5, 0.5],\n                   [1. , 1. , 1. ],\n                   [1.5, 1.5, 1.5]])\n\n            ```\n        \"\"\"\n        line_string_coords = line_string.coords\n        start_index = LineGeometry._find_mask_index(bounds[0], line_string_coords)\n        end_index = LineGeometry._find_mask_index(bounds[1], line_string_coords)\n        lower_bound_point, start_index = LineGeometry._handle_bound(\n            start_index, bounds[0], True, line_string_coords\n        )\n        upper_bound_point, end_index = LineGeometry._handle_bound(\n            end_index, bounds[1], False, line_string_coords\n        )\n\n        if lower_bound_point is None and upper_bound_point is None:\n            return line_string\n        elif lower_bound_point is None:\n            return LineString(line_string_coords[: end_index + 1] + [upper_bound_point])\n        elif upper_bound_point is None:\n            return LineString([lower_bound_point] + line_string_coords[start_index:])\n        else:\n            return LineString(\n                [lower_bound_point]\n                + line_string_coords[start_index:end_index]\n                + [upper_bound_point]\n            )\n\n    @staticmethod\n    def _find_mask_index(\n            station_bound: float, line_string_coords: np.ndarray\n    ) -&gt; Optional[int]:\n        \"\"\"Find the start and end indices for clipping the chainage line.\n\n        Args:\n            station_bound (float):\n                Station bound for clipping.\n            line_string_coords (np.ndarray):\n                Coordinates of the line string.\n\n        Returns:\n            Optional[int]: index for clipping.\n        \"\"\"\n        mask_index = next(\n            (\n                index\n                for index, coord in enumerate(line_string_coords)\n                if coord[2] &gt;= station_bound\n            ),\n            None,\n        )\n        return mask_index\n\n    @staticmethod\n    def _handle_bound(\n        index: Optional[int],\n        station_bound: float,\n        is_lower: bool,\n        line_string_coords: np.ndarray,\n    ) -&gt; Tuple[Optional[Tuple[float, float, float]], Optional[int]]:\n        \"\"\"Handle the clipping of the stations line for a given bound.\n\n        Args:\n            index (Optional[int]):\n                Index for clipping (start or end).\n            station_bound (float):\n                Station bound for clipping.\n            is_lower (bool):\n                True if handling the lower bound, False for the upper bound.\n            line_string_coords (np.ndarray):\n                Coordinates of the line string.\n\n        Returns:\n            Tuple[Optional[Tuple[float, float, float]], Optional[int]]:\n                Adjusted bound point and updated index.\n        \"\"\"\n        if index is None:\n            bound_type = \"Lower\" if is_lower else \"Upper\"\n            end_station = line_string_coords[-1][2]\n            if is_lower or (station_bound - end_station &gt; 0.1):\n                raise ValueError(\n                    f\"{bound_type} chainage bound {station_bound} \"\n                    f\"is larger than the maximum chainage {end_station} available\"\n                )\n            return None, index\n\n        if index == 0:\n            bound_type = \"Lower\" if is_lower else \"Upper\"\n            start_station = line_string_coords[0][2]\n            if not is_lower or (start_station - station_bound &gt; 0.1):\n                raise ValueError(\n                    f\"{bound_type} chainage bound {station_bound} \"\n                    f\"is smaller than the minimum chainage {start_station} available\"\n                )\n            return None, index\n\n        # Interpolate the point\n        alpha, interpolated_point = LineGeometry._interpolate_point(\n            index, station_bound, line_string_coords\n        )\n\n        # Adjust the index based on the interpolation factor\n        if is_lower and alpha &gt; 0.9:\n            index += 1\n        elif not is_lower and alpha &lt; 0.1:\n            index -= 1\n\n        return interpolated_point, index\n\n    @staticmethod\n    def _interpolate_point(\n        index: int, station_bound: float, line_string_coords: np.ndarray\n    ) -&gt; Tuple[float, Tuple[float, float, float]]:\n        \"\"\"Interpolate a point between two coordinates.\n\n        Args:\n            index (int):\n                Index of the coordinate to interpolate.\n            station_bound (float):\n                Station bound for interpolation.\n            line_string_coords (np.ndarray):\n                Coordinates of the line string.\n\n        Returns:\n            float: Interpolation factor.\n            Tuple[float, float, float]: Interpolated point.\n        \"\"\"\n        alpha = (station_bound - line_string_coords[index - 1][2]) / (\n                line_string_coords[index][2] - line_string_coords[index - 1][2]\n        )\n        interpolated_point = tuple(\n            prev_coord + alpha * (next_coord - prev_coord)\n            for prev_coord, next_coord in zip(\n                line_string_coords[index - 1], line_string_coords[index]\n            )\n        )\n        return alpha, interpolated_point\n\n    def intersect_with_line(\n        self, reference_line_with_stations: np.ndarray\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Project chainage(stations) values from a reference line onto a target line by spatial proximity and interpolation.\n\n        Project chainage values from source line L1 onto another line L2.\n\n        The chainage values are giving along a line L1 (xykm_numpy). For each node\n        of the line L2 (line_xy) on which we would like to know the chainage, first\n        the closest node (discrete set of nodes) on L1 is determined and\n        subsequently the exact chainage is obtained by determining the closest point\n        (continuous line) on L1 for which the chainage is determined using by means\n        of interpolation.\n\n        Args:\n            reference_line_with_stations (np.ndarray):\n                Mx3 array with x, y, and chainage values for the reference line.\n\n        Returns:\n            line_km (np.ndarray):\n                1D Array containing the chainage(stations in km) for every coordinate specified in line_xy.\n        \"\"\"\n        coords = self.as_array()\n        # pre-allocates the array for the mapped chainage values\n        projected_stations = np.zeros(coords.shape[0])\n\n        # get an array with only the x,y coordinates of line L1\n        ref_coords = reference_line_with_stations[:, :2]\n        last_index = reference_line_with_stations.shape[0] - 1\n\n        # for each node rp on line L2 get the chainage ...\n        for i, station_i in enumerate(coords):\n            # find the node on L1 closest to rp\n            # get the distance to all the nodes on the reference line, and find the closest one\n            closest_ind = np.argmin(((station_i - ref_coords) ** 2).sum(axis=1))\n            closest_coords = ref_coords[closest_ind]\n\n            # determine the distance between that node and rp\n            squared_distance = ((station_i - closest_coords) ** 2).sum()\n\n            # chainage value of that node\n            station = reference_line_with_stations[closest_ind, 2]\n\n            # if we didn't get the first node\n            if closest_ind &gt; 0:\n                # project rp onto the line segment before this node\n                closest_coord_minus_1 = ref_coords[closest_ind - 1]\n                alpha = (\n                                (closest_coord_minus_1[0] - closest_coords[0]) * (station_i[0] - closest_coords[0])\n                                + (closest_coord_minus_1[1] - closest_coords[1]) * (station_i[1] - closest_coords[1])\n                        ) / ((closest_coord_minus_1[0] - closest_coords[0]) ** 2 + (closest_coord_minus_1[1] - closest_coords[1]) ** 2)\n                # if there is a closest point not coinciding with the nodes ...\n                if 0 &lt; alpha &lt; 1:\n                    dist2link = (station_i[0] - closest_coords[0] - alpha * (closest_coord_minus_1[0] - closest_coords[0])) ** 2 + (\n                            station_i[1] - closest_coords[1] - alpha * (closest_coord_minus_1[1] - closest_coords[1])\n                    ) ** 2\n                    # if it's actually closer than the node ...\n                    if dist2link &lt; squared_distance:\n                        # update the closest point information\n                        squared_distance = dist2link\n                        station = reference_line_with_stations[closest_ind, 2] + alpha * (\n                                reference_line_with_stations[closest_ind - 1, 2] - reference_line_with_stations[closest_ind, 2]\n                        )\n\n            # if we didn't get the last node\n            if closest_ind &lt; last_index:\n                # project rp onto the line segment after this node\n                closest_coord_minus_1 = ref_coords[closest_ind + 1]\n                alpha = (\n                                (closest_coord_minus_1[0] - closest_coords[0]) * (station_i[0] - closest_coords[0])\n                                + (closest_coord_minus_1[1] - closest_coords[1]) * (station_i[1] - closest_coords[1])\n                        ) / ((closest_coord_minus_1[0] - closest_coords[0]) ** 2 + (closest_coord_minus_1[1] - closest_coords[1]) ** 2)\n                # if there is a closest point not coinciding with the nodes ...\n                if alpha &gt; 0 and alpha &lt; 1:\n                    dist2link = (station_i[0] - closest_coords[0] - alpha * (closest_coord_minus_1[0] - closest_coords[0])) ** 2 + (\n                            station_i[1] - closest_coords[1] - alpha * (closest_coord_minus_1[1] - closest_coords[1])\n                    ) ** 2\n                    # if it's actually closer than the previous value ...\n                    if dist2link &lt; squared_distance:\n                        # update the closest point information\n                        # squared_distance = dist2link\n                        station = reference_line_with_stations[closest_ind, 2] + alpha * (\n                                reference_line_with_stations[closest_ind + 1, 2] - reference_line_with_stations[closest_ind, 2]\n                        )\n            # store the chainage value, loop ... and return\n            projected_stations[i] = station\n        return projected_stations\n\n    def get_bbox(\n        self, buffer: float = 0.1\n    ) -&gt; Tuple[float, float, float, float]:\n        \"\"\"\n        Derive the bounding box from a line.\n\n        Args:\n            buffer : float\n                Buffer fraction surrounding the tight bounding box\n\n        Returns:\n            bbox (Tuple[float, float, float, float]):\n                bounding box consisting of [min x, min y, max x, max y)\n        \"\"\"\n        coords = self.as_array()\n        x = coords[:, 0]\n        y = coords[:, 1]\n        x_min = x.min()\n        y_min = y.min()\n        x_max = x.max()\n        y_max = y.max()\n        d = buffer * max(x_max - x_min, y_max - y_min)\n        bbox = (x_min - d, y_min - d, x_max + d, y_max + d)\n\n        return bbox\n</code></pre>"},{"location":"api/io.html#dfastbe.io.data_models.LineGeometry.data","title":"<code>data: Dict[str, np.ndarray]</code>  <code>property</code>","text":"<p>any data assigned to the line using the <code>add_data</code> method.</p>"},{"location":"api/io.html#dfastbe.io.data_models.LineGeometry.__init__","title":"<code>__init__(line: LineString | np.ndarray, mask: Tuple[float, float] = None, crs: str = None)</code>","text":"<p>Geometry Line initialization.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>LineString</code> <p>River center line as a linestring.</p> required <code>mask</code> <code>Tuple[float, float]</code> <p>Lower and upper limit for the chainage. Defaults to None.</p> <code>None</code> <code>crs</code> <code>(str, Optional)</code> <p>the coordinate reference system number as a string.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; line_string = LineString([(0, 0, 0), (1, 1, 1), (2, 2, 2)])\n&gt;&gt;&gt; mask = (0.5, 1.5)\n&gt;&gt;&gt; center_line = LineGeometry(line_string, mask)\nNo message found for clip_chainage\n&gt;&gt;&gt; np.array(center_line.values.coords)\narray([[0.5, 0.5, 0.5],\n       [1. , 1. , 1. ],\n       [1.5, 1.5, 1.5]])\n</code></pre> Source code in <code>src/dfastbe/io/data_models.py</code> <pre><code>def __init__(self, line: LineString | np.ndarray, mask: Tuple[float, float] = None, crs: str = None):\n    \"\"\"Geometry Line initialization.\n\n    Args:\n        line (LineString):\n            River center line as a linestring.\n        mask (Tuple[float, float], optional):\n            Lower and upper limit for the chainage. Defaults to None.\n        crs (str, Optional):\n            the coordinate reference system number as a string.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; line_string = LineString([(0, 0, 0), (1, 1, 1), (2, 2, 2)])\n        &gt;&gt;&gt; mask = (0.5, 1.5)\n        &gt;&gt;&gt; center_line = LineGeometry(line_string, mask)\n        No message found for clip_chainage\n        &gt;&gt;&gt; np.array(center_line.values.coords)\n        array([[0.5, 0.5, 0.5],\n               [1. , 1. , 1. ],\n               [1.5, 1.5, 1.5]])\n\n        ```\n    \"\"\"\n    self.station_bounds = mask\n    self.crs = crs\n    self._data = {}\n    if isinstance(line, np.ndarray):\n        line = LineString(line)\n    if mask is None:\n        self.values = line\n    else:\n        self.values: LineString = self.mask(line, mask)\n\n        LogData().log_text(\n            \"clip_chainage\", data={\"low\": self.station_bounds[0], \"high\": self.station_bounds[1]}\n        )\n</code></pre>"},{"location":"api/io.html#dfastbe.io.data_models.LineGeometry.add_data","title":"<code>add_data(data: Dict[str, np.ndarray]) -&gt; None</code>","text":"<p>Add data to the LineGeometry object.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, ndarray]</code> <p>Dictionary of quantities to be added, each np array should have length k.</p> required Source code in <code>src/dfastbe/io/data_models.py</code> <pre><code>def add_data(self, data: Dict[str, np.ndarray]) -&gt; None:\n    \"\"\"\n    Add data to the LineGeometry object.\n\n    Args:\n        data (Dict[str, np.ndarray]):\n            Dictionary of quantities to be added, each np array should have length k.\n    \"\"\"\n    self._data = self.data | data\n</code></pre>"},{"location":"api/io.html#dfastbe.io.data_models.LineGeometry.get_bbox","title":"<code>get_bbox(buffer: float = 0.1) -&gt; Tuple[float, float, float, float]</code>","text":"<p>Derive the bounding box from a line.</p> <p>Parameters:</p> Name Type Description Default <code>buffer </code> <p>float Buffer fraction surrounding the tight bounding box</p> required <p>Returns:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>bounding box consisting of [min x, min y, max x, max y)</p> Source code in <code>src/dfastbe/io/data_models.py</code> <pre><code>def get_bbox(\n    self, buffer: float = 0.1\n) -&gt; Tuple[float, float, float, float]:\n    \"\"\"\n    Derive the bounding box from a line.\n\n    Args:\n        buffer : float\n            Buffer fraction surrounding the tight bounding box\n\n    Returns:\n        bbox (Tuple[float, float, float, float]):\n            bounding box consisting of [min x, min y, max x, max y)\n    \"\"\"\n    coords = self.as_array()\n    x = coords[:, 0]\n    y = coords[:, 1]\n    x_min = x.min()\n    y_min = y.min()\n    x_max = x.max()\n    y_max = y.max()\n    d = buffer * max(x_max - x_min, y_max - y_min)\n    bbox = (x_min - d, y_min - d, x_max + d, y_max + d)\n\n    return bbox\n</code></pre>"},{"location":"api/io.html#dfastbe.io.data_models.LineGeometry.intersect_with_line","title":"<code>intersect_with_line(reference_line_with_stations: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Project chainage(stations) values from a reference line onto a target line by spatial proximity and interpolation.</p> <p>Project chainage values from source line L1 onto another line L2.</p> <p>The chainage values are giving along a line L1 (xykm_numpy). For each node of the line L2 (line_xy) on which we would like to know the chainage, first the closest node (discrete set of nodes) on L1 is determined and subsequently the exact chainage is obtained by determining the closest point (continuous line) on L1 for which the chainage is determined using by means of interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>reference_line_with_stations</code> <code>ndarray</code> <p>Mx3 array with x, y, and chainage values for the reference line.</p> required <p>Returns:</p> Name Type Description <code>line_km</code> <code>ndarray</code> <p>1D Array containing the chainage(stations in km) for every coordinate specified in line_xy.</p> Source code in <code>src/dfastbe/io/data_models.py</code> <pre><code>def intersect_with_line(\n    self, reference_line_with_stations: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"\n    Project chainage(stations) values from a reference line onto a target line by spatial proximity and interpolation.\n\n    Project chainage values from source line L1 onto another line L2.\n\n    The chainage values are giving along a line L1 (xykm_numpy). For each node\n    of the line L2 (line_xy) on which we would like to know the chainage, first\n    the closest node (discrete set of nodes) on L1 is determined and\n    subsequently the exact chainage is obtained by determining the closest point\n    (continuous line) on L1 for which the chainage is determined using by means\n    of interpolation.\n\n    Args:\n        reference_line_with_stations (np.ndarray):\n            Mx3 array with x, y, and chainage values for the reference line.\n\n    Returns:\n        line_km (np.ndarray):\n            1D Array containing the chainage(stations in km) for every coordinate specified in line_xy.\n    \"\"\"\n    coords = self.as_array()\n    # pre-allocates the array for the mapped chainage values\n    projected_stations = np.zeros(coords.shape[0])\n\n    # get an array with only the x,y coordinates of line L1\n    ref_coords = reference_line_with_stations[:, :2]\n    last_index = reference_line_with_stations.shape[0] - 1\n\n    # for each node rp on line L2 get the chainage ...\n    for i, station_i in enumerate(coords):\n        # find the node on L1 closest to rp\n        # get the distance to all the nodes on the reference line, and find the closest one\n        closest_ind = np.argmin(((station_i - ref_coords) ** 2).sum(axis=1))\n        closest_coords = ref_coords[closest_ind]\n\n        # determine the distance between that node and rp\n        squared_distance = ((station_i - closest_coords) ** 2).sum()\n\n        # chainage value of that node\n        station = reference_line_with_stations[closest_ind, 2]\n\n        # if we didn't get the first node\n        if closest_ind &gt; 0:\n            # project rp onto the line segment before this node\n            closest_coord_minus_1 = ref_coords[closest_ind - 1]\n            alpha = (\n                            (closest_coord_minus_1[0] - closest_coords[0]) * (station_i[0] - closest_coords[0])\n                            + (closest_coord_minus_1[1] - closest_coords[1]) * (station_i[1] - closest_coords[1])\n                    ) / ((closest_coord_minus_1[0] - closest_coords[0]) ** 2 + (closest_coord_minus_1[1] - closest_coords[1]) ** 2)\n            # if there is a closest point not coinciding with the nodes ...\n            if 0 &lt; alpha &lt; 1:\n                dist2link = (station_i[0] - closest_coords[0] - alpha * (closest_coord_minus_1[0] - closest_coords[0])) ** 2 + (\n                        station_i[1] - closest_coords[1] - alpha * (closest_coord_minus_1[1] - closest_coords[1])\n                ) ** 2\n                # if it's actually closer than the node ...\n                if dist2link &lt; squared_distance:\n                    # update the closest point information\n                    squared_distance = dist2link\n                    station = reference_line_with_stations[closest_ind, 2] + alpha * (\n                            reference_line_with_stations[closest_ind - 1, 2] - reference_line_with_stations[closest_ind, 2]\n                    )\n\n        # if we didn't get the last node\n        if closest_ind &lt; last_index:\n            # project rp onto the line segment after this node\n            closest_coord_minus_1 = ref_coords[closest_ind + 1]\n            alpha = (\n                            (closest_coord_minus_1[0] - closest_coords[0]) * (station_i[0] - closest_coords[0])\n                            + (closest_coord_minus_1[1] - closest_coords[1]) * (station_i[1] - closest_coords[1])\n                    ) / ((closest_coord_minus_1[0] - closest_coords[0]) ** 2 + (closest_coord_minus_1[1] - closest_coords[1]) ** 2)\n            # if there is a closest point not coinciding with the nodes ...\n            if alpha &gt; 0 and alpha &lt; 1:\n                dist2link = (station_i[0] - closest_coords[0] - alpha * (closest_coord_minus_1[0] - closest_coords[0])) ** 2 + (\n                        station_i[1] - closest_coords[1] - alpha * (closest_coord_minus_1[1] - closest_coords[1])\n                ) ** 2\n                # if it's actually closer than the previous value ...\n                if dist2link &lt; squared_distance:\n                    # update the closest point information\n                    # squared_distance = dist2link\n                    station = reference_line_with_stations[closest_ind, 2] + alpha * (\n                            reference_line_with_stations[closest_ind + 1, 2] - reference_line_with_stations[closest_ind, 2]\n                    )\n        # store the chainage value, loop ... and return\n        projected_stations[i] = station\n    return projected_stations\n</code></pre>"},{"location":"api/io.html#dfastbe.io.data_models.LineGeometry.mask","title":"<code>mask(line_string: LineString, bounds: Tuple[float, float]) -&gt; LineString</code>  <code>staticmethod</code>","text":"<p>Clip a LineGeometry to the relevant reach.</p> <p>Parameters:</p> Name Type Description Default <code>line_string</code> <code>LineString</code> <p>river center line as a linestring.</p> required <code>bounds</code> <code>Tuple[float, float]</code> <p>Lower and upper limit for the chainage.</p> required <p>Returns:</p> Name Type Description <code>LineString</code> <code>LineString</code> <p>Clipped river chainage line.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; line_string = LineString([(0, 0, 0), (1, 1, 1), (2, 2, 2)])\n&gt;&gt;&gt; bounds = (0.5, 1.5)\n&gt;&gt;&gt; center_line = LineGeometry.mask(line_string, bounds)\n&gt;&gt;&gt; np.array(center_line.coords)\narray([[0.5, 0.5, 0.5],\n       [1. , 1. , 1. ],\n       [1.5, 1.5, 1.5]])\n</code></pre> Source code in <code>src/dfastbe/io/data_models.py</code> <pre><code>@staticmethod\ndef mask(line_string: LineString, bounds: Tuple[float, float]) -&gt; LineString:\n    \"\"\"Clip a LineGeometry to the relevant reach.\n\n    Args:\n        line_string (LineString):\n            river center line as a linestring.\n        bounds (Tuple[float, float]):\n            Lower and upper limit for the chainage.\n\n    Returns:\n        LineString: Clipped river chainage line.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; line_string = LineString([(0, 0, 0), (1, 1, 1), (2, 2, 2)])\n        &gt;&gt;&gt; bounds = (0.5, 1.5)\n        &gt;&gt;&gt; center_line = LineGeometry.mask(line_string, bounds)\n        &gt;&gt;&gt; np.array(center_line.coords)\n        array([[0.5, 0.5, 0.5],\n               [1. , 1. , 1. ],\n               [1.5, 1.5, 1.5]])\n\n        ```\n    \"\"\"\n    line_string_coords = line_string.coords\n    start_index = LineGeometry._find_mask_index(bounds[0], line_string_coords)\n    end_index = LineGeometry._find_mask_index(bounds[1], line_string_coords)\n    lower_bound_point, start_index = LineGeometry._handle_bound(\n        start_index, bounds[0], True, line_string_coords\n    )\n    upper_bound_point, end_index = LineGeometry._handle_bound(\n        end_index, bounds[1], False, line_string_coords\n    )\n\n    if lower_bound_point is None and upper_bound_point is None:\n        return line_string\n    elif lower_bound_point is None:\n        return LineString(line_string_coords[: end_index + 1] + [upper_bound_point])\n    elif upper_bound_point is None:\n        return LineString([lower_bound_point] + line_string_coords[start_index:])\n    else:\n        return LineString(\n            [lower_bound_point]\n            + line_string_coords[start_index:end_index]\n            + [upper_bound_point]\n        )\n</code></pre>"},{"location":"api/io.html#dfastbe.io.data_models.LineGeometry.to_file","title":"<code>to_file(file_name: str, data: Dict[str, np.ndarray] = None) -&gt; None</code>","text":"<p>Write a shape point file with x, y, and values.</p> <p>Parameters:</p> Name Type Description Default <code>file_name </code> <p>str Name of the file to be written.</p> required <code>data </code> <p>Dict[str, np.ndarray] Dictionary of quantities to be written, each np array should have length k.</p> required Source code in <code>src/dfastbe/io/data_models.py</code> <pre><code>def to_file(\n        self, file_name: str, data: Dict[str, np.ndarray] = None,\n) -&gt; None:\n    \"\"\"\n    Write a shape point file with x, y, and values.\n\n    Args:\n        file_name : str\n            Name of the file to be written.\n        data : Dict[str, np.ndarray]\n            Dictionary of quantities to be written, each np array should have length k.\n    \"\"\"\n    xy = self.as_array()\n    geom = [Point(xy_i) for xy_i in xy]\n    if data is None:\n        data = self.data\n    else:\n        data = data | self.data\n    GeoDataFrame(data, geometry=geom, crs=self.crs).to_file(file_name)\n</code></pre>"},{"location":"api/io.html#file-utilities","title":"File Utilities","text":"<p>The file utilities component provides functions for file operations, such as reading and writing files.</p>"},{"location":"api/io.html#dfastbe.io.file_utils","title":"<code>dfastbe.io.file_utils</code>","text":"<p>Copyright (C) 2025 Stichting Deltares.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation version 2.1.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, see http://www.gnu.org/licenses/.</p> <p>contact: delft3d.support@deltares.nl Stichting Deltares P.O. Box 177 2600 MH Delft, The Netherlands</p> <p>All indications and logos of, and references to, \"Delft3D\" and \"Deltares\" are registered trademarks of Stichting Deltares, and remain the property of Stichting Deltares. All rights reserved.</p> <p>INFORMATION This file is part of D-FAST Bank Erosion: https://github.com/Deltares/D-FAST_Bank_Erosion</p>"},{"location":"api/io.html#dfastbe.io.file_utils.absolute_path","title":"<code>absolute_path(rootdir: str, path: str) -&gt; str</code>","text":"<p>Convert a relative path to an absolute path.</p> <p>Parameters:</p> Name Type Description Default <code>rootdir</code> <code>str</code> <p>Any relative paths should be given relative to this location.</p> required <code>path</code> <code>str</code> <p>A relative or absolute location.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>An absolute location.</p> Source code in <code>src/dfastbe/io/file_utils.py</code> <pre><code>def absolute_path(rootdir: str, path: str) -&gt; str:\n    \"\"\"\n    Convert a relative path to an absolute path.\n\n    Args:\n        rootdir (str): Any relative paths should be given relative to this location.\n        path (str): A relative or absolute location.\n\n    Returns:\n        str: An absolute location.\n    \"\"\"\n    if not path:\n        return path\n    root_path = Path(rootdir).resolve()\n    target_path = Path(path)\n\n    if target_path.is_absolute():\n        return str(target_path)\n\n    resolved_path = (root_path / target_path).resolve()\n    return str(resolved_path)\n</code></pre>"},{"location":"api/io.html#dfastbe.io.file_utils.relative_path","title":"<code>relative_path(rootdir: str, file: str) -&gt; str</code>","text":"<p>Convert an absolute path to a relative path.</p> <p>Parameters:</p> Name Type Description Default <code>rootdir</code> <code>str</code> <p>Any relative paths will be given relative to this location.</p> required <code>file</code> <code>str</code> <p>An absolute location.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A relative location if possible, otherwise the absolute location.</p> Source code in <code>src/dfastbe/io/file_utils.py</code> <pre><code>def relative_path(rootdir: str, file: str) -&gt; str:\n    \"\"\"\n    Convert an absolute path to a relative path.\n\n    Args:\n        rootdir (str): Any relative paths will be given relative to this location.\n        file (str): An absolute location.\n\n    Returns:\n        str: A relative location if possible, otherwise the absolute location.\n    \"\"\"\n    if not file:\n        return file\n\n    root_path = Path(rootdir).resolve()\n    file_path = Path(file).resolve()\n\n    try:\n        return str(file_path.relative_to(root_path))\n    except ValueError:\n        return str(file_path)\n</code></pre>"},{"location":"api/io.html#logging","title":"Logging","text":"<p>The logging component handles logging information during the execution of the software.</p>"},{"location":"api/io.html#dfastbe.io.logger","title":"<code>dfastbe.io.logger</code>","text":"<p>Copyright (C) 2025 Stichting Deltares.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation version 2.1.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, see http://www.gnu.org/licenses/.</p> <p>contact: delft3d.support@deltares.nl Stichting Deltares P.O. Box 177 2600 MH Delft, The Netherlands</p> <p>All indications and logos of, and references to, \"Delft3D\" and \"Deltares\" are registered trademarks of Stichting Deltares, and remain the property of Stichting Deltares. All rights reserved.</p> <p>INFORMATION This file is part of D-FAST Bank Erosion: https://github.com/Deltares/D-FAST_Bank_Erosion</p>"},{"location":"api/io.html#dfastbe.io.logger.LogData","title":"<code>LogData</code>","text":"<p>Singleton class for managing localized log messages from INI-style configuration files.</p> <p>LogData provides a centralized mechanism for loading and retrieving localized text messages used throughout the application. It implements the singleton pattern to ensure only one instance exists, maintaining consistent access to log messages across the entire application.</p> <p>The class reads INI-style configuration files where keys are enclosed in square brackets (e.g., <code>[key_name]</code>) and the following lines until the next key contain the associated text content. This supports multi-language logging by loading different message files (e.g., <code>messages.UK.ini</code>, <code>messages.NL.ini</code>).</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Dict[str, List[str]]</code> <p>Dictionary mapping message keys to lists of text lines.</p> <p>Examples:</p> <ul> <li>Create a LogData instance with a message file:     <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from dfastbe.io.logger import LogData\n&gt;&gt;&gt; LogData.reset()\n&gt;&gt;&gt; log_data = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n&gt;&gt;&gt; type(log_data)\n&lt;class 'dfastbe.io.logger.LogData'&gt;\n</code></pre></li> <li>Verify the singleton pattern returns the same instance:     <pre><code>&gt;&gt;&gt; log_data2 = LogData()\n&gt;&gt;&gt; log_data is log_data2\nTrue\n</code></pre></li> <li>Access the loaded message data structure:     <pre><code>&gt;&gt;&gt; sorted(log_data.data.keys())[:4]\n['', 'confirm', 'filename_report.out', 'reach']\n</code></pre></li> <li>Retrieve a specific message by key:     <pre><code>&gt;&gt;&gt; log_data.get_text(\"confirm\")\n['Confirm using \"y\" ...', '']\n</code></pre></li> </ul> See Also <p>log_text: Module-level convenience function for logging. timed_logger: Function for logging with timing information.</p> Source code in <code>src/dfastbe/io/logger.py</code> <pre><code>class LogData:\n    \"\"\"Singleton class for managing localized log messages from INI-style configuration files.\n\n    LogData provides a centralized mechanism for loading and retrieving localized\n    text messages used throughout the application. It implements the singleton pattern\n    to ensure only one instance exists, maintaining consistent access to log messages\n    across the entire application.\n\n    The class reads INI-style configuration files where keys are enclosed in square\n    brackets (e.g., ``[key_name]``) and the following lines until the next key contain\n    the associated text content. This supports multi-language logging by loading\n    different message files (e.g., ``messages.UK.ini``, ``messages.NL.ini``).\n\n    Attributes:\n        data (Dict[str, List[str]]): Dictionary mapping message keys to lists of\n            text lines.\n\n    Examples:\n        - Create a LogData instance with a message file:\n            ```python\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from dfastbe.io.logger import LogData\n            &gt;&gt;&gt; LogData.reset()\n            &gt;&gt;&gt; log_data = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n            &gt;&gt;&gt; type(log_data)\n            &lt;class 'dfastbe.io.logger.LogData'&gt;\n\n            ```\n        - Verify the singleton pattern returns the same instance:\n            ```python\n            &gt;&gt;&gt; log_data2 = LogData()\n            &gt;&gt;&gt; log_data is log_data2\n            True\n\n            ```\n        - Access the loaded message data structure:\n            ```python\n            &gt;&gt;&gt; sorted(log_data.data.keys())[:4]\n            ['', 'confirm', 'filename_report.out', 'reach']\n\n            ```\n        - Retrieve a specific message by key:\n            ```python\n            &gt;&gt;&gt; log_data.get_text(\"confirm\")\n            ['Confirm using \"y\" ...', '']\n\n            ```\n\n    See Also:\n        log_text: Module-level convenience function for logging.\n        timed_logger: Function for logging with timing information.\n    \"\"\"\n\n    _instance: Optional[\"LogData\"] = None\n\n    def __new__(cls, file_name: Optional[str | Path] = None) -&gt; \"LogData\":\n        \"\"\"Create or return the singleton LogData instance.\n\n        Implements the singleton pattern using ``__new__``. On first call,\n        creates a new instance and stores it. Subsequent calls return the\n        existing instance.\n\n        Args:\n            file_name: Path to the INI-style message file. Required on first\n                instantiation, optional on subsequent calls.\n\n        Returns:\n            The singleton LogData instance.\n\n        Raises:\n            ValueError: If ``file_name`` is None on first instantiation.\n\n        Examples:\n            - First instantiation requires a file path:\n                ```python\n                &gt;&gt;&gt; from pathlib import Path\n                &gt;&gt;&gt; from dfastbe.io.logger import LogData\n                &gt;&gt;&gt; LogData.reset()\n                &gt;&gt;&gt; log_data = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n                &gt;&gt;&gt; log_data._initialized\n                True\n\n                ```\n            - Subsequent calls without file_name return the same instance:\n                ```python\n                &gt;&gt;&gt; log_data2 = LogData()\n                &gt;&gt;&gt; log_data is log_data2\n                True\n\n                ```\n        \"\"\"\n        if cls._instance is None:\n            if file_name is None:\n                raise ValueError(\"file_name must be provided on first instantiation\")\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n\n    def __init__(self, file_name: Optional[str | Path] = None) -&gt; None:\n        \"\"\"Initialize the LogData singleton instance.\n\n        Loads and parses the message file on first initialization. Subsequent\n        calls to ``__init__`` are ignored since the instance is already initialized.\n\n        Args:\n            file_name: Path to the INI-style message file. Required on first\n                instantiation, ignored on subsequent calls.\n\n        Raises:\n            ValueError: If ``file_name`` is None on first instantiation.\n\n        Examples:\n            - Initialize with a message file and access loaded data:\n                ```python\n                &gt;&gt;&gt; from pathlib import Path\n                &gt;&gt;&gt; from dfastbe.io.logger import LogData\n                &gt;&gt;&gt; LogData.reset()\n                &gt;&gt;&gt; log_data = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n                &gt;&gt;&gt; len(log_data.data) &gt; 0\n                True\n                &gt;&gt;&gt; \"confirm\" in log_data.data\n                True\n\n                ```\n\n        \"\"\"\n        if not self._initialized:\n            if file_name is None:\n                raise ValueError(\"file_name must be provided on first instantiation\")\n            self.data = self.read_data(file_name)\n            self._initialized = True\n\n    @classmethod\n    def reset(cls) -&gt; None:\n        \"\"\"Reset the singleton instance to allow re-initialization.\n\n        This class method clears the singleton instance, allowing a new instance\n        to be created with a different message file. Useful for testing or\n        switching between language files.\n\n        Examples:\n            - Reset and reinitialize with a different file:\n                ```python\n                &gt;&gt;&gt; from pathlib import Path\n                &gt;&gt;&gt; from dfastbe.io.logger import LogData\n                &gt;&gt;&gt; LogData.reset()\n                &gt;&gt;&gt; log_data1 = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n                &gt;&gt;&gt; id1 = id(log_data1)\n                &gt;&gt;&gt; LogData.reset()\n                &gt;&gt;&gt; log_data2 = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n                &gt;&gt;&gt; id1 != id(log_data2)\n                True\n\n                ```\n        \"\"\"\n        cls._instance = None\n\n    def read_data(self, file_name: str | Path) -&gt; dict[str, list[str]]:\n        \"\"\"Load and parse texts from an INI-style configuration file.\n\n        Reads the specified file and parses it into a dictionary where keys are\n        identified by lines enclosed in square brackets (e.g., ``[key_name]``).\n        All lines following a key until the next key become the value (as a list\n        of strings). This format supports multi-language localization.\n\n        Args:\n            file_name: Path to the INI-style message file to read and parse.\n\n        Returns:\n            Dictionary mapping string keys to lists of text lines. Each key\n            corresponds to a bracketed section header, and the value contains\n            all lines between that header and the next.\n\n        Raises:\n            ValueError: If a duplicate key is found in the file.\n            FileNotFoundError: If the specified file does not exist.\n\n        Examples:\n            - Read and parse a message file:\n                ```python\n                &gt;&gt;&gt; from pathlib import Path\n                &gt;&gt;&gt; from dfastbe.io.logger import LogData\n                &gt;&gt;&gt; LogData.reset()\n                &gt;&gt;&gt; log_data = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n                &gt;&gt;&gt; data = log_data.data\n                &gt;&gt;&gt; type(data)\n                &lt;class 'dict'&gt;\n\n                ```\n            - Examine the structure of parsed data:\n                ```python\n                &gt;&gt;&gt; data[\"confirm\"]\n                ['Confirm using \"y\" ...', '']\n                &gt;&gt;&gt; data[\"reach\"]\n                ['The measure is located on reach {reach}']\n\n                ```\n            - Empty key captures content before first bracketed section:\n                ```python\n                &gt;&gt;&gt; data[\"\"]\n                ['']\n\n                ```\n        \"\"\"\n        with open(file_name, \"r\", encoding=\"utf-8\") as f:\n            all_lines = f.read().splitlines()\n\n        data: Dict[str, List[str]] = {}\n        text: List[str] = []\n        key = None\n\n        for line in all_lines:\n            r_line = line.strip()\n            if r_line.startswith(\"[\") and r_line.endswith(\"]\"):\n                if key is not None:\n                    if key in data:\n                        raise ValueError(f\"Duplicate entry for '{key}' in {file_name}.\")\n                    data[key] = text\n                key = r_line[1:-1]\n                text = []\n            else:\n                text.append(line)\n\n        # Handle the last key\n        if key is not None:\n            if key in data:\n                raise ValueError(f\"Duplicate entry for '{key}' in {file_name}.\")\n            data[key] = text\n\n        return data\n\n\n    def get_text(self, key: str) -&gt; List[str]:\n        \"\"\"Retrieve text lines associated with a message key.\n\n        Queries the internal message dictionary and returns the list of strings\n        stored for the given key. If the key is not found, returns a default\n        \"not found\" message.\n\n        Args:\n            key: The message key to look up in the dictionary.\n\n        Returns:\n            List of strings containing the text for the key. If the key is not\n            found, returns ``[\"No message found for &lt;key&gt;\"]``.\n\n        Examples:\n            - Retrieve an existing message:\n                ```python\n                &gt;&gt;&gt; from pathlib import Path\n                &gt;&gt;&gt; from dfastbe.io.logger import LogData\n                &gt;&gt;&gt; LogData.reset()\n                &gt;&gt;&gt; log_data = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n                &gt;&gt;&gt; log_data.get_text(\"confirm\")\n                ['Confirm using \"y\" ...', '']\n\n                ```\n            - Retrieve a message with placeholder:\n                ```python\n                &gt;&gt;&gt; log_data.get_text(\"reach\")\n                ['The measure is located on reach {reach}']\n\n                ```\n            - Handle non-existent key:\n                ```python\n                &gt;&gt;&gt; log_data.get_text(\"nonexistent_key\")\n                ['No message found for nonexistent_key']\n\n                ```\n            - Empty string key retrieves empty line content:\n                ```python\n                &gt;&gt;&gt; log_data.get_text(\"\")\n                ['']\n\n                ```\n        \"\"\"\n        if key in self.data:\n            val = self.data[key]\n        else:\n            val = [f\"No message found for {key}\"]\n        return val\n\n    def log_text(\n        self,\n        key: str,\n        file: Optional[TextIO] = None,\n        data: Optional[Dict[str, Any]] = None,\n        repeat: int = 1,\n        indent: str = \"\",\n    ) -&gt; None:\n        \"\"\"Write a localized message to standard output or a file.\n\n        Retrieves the text associated with the given key and outputs it to either\n        standard output or a specified file. Supports placeholder expansion using\n        Python's string formatting, repetition, and indentation.\n\n        Args:\n            key: The message key to retrieve and output.\n            file: File object to write to. If None, writes to standard output.\n            data: Dictionary for placeholder expansion in the message text.\n                Placeholders in the message (e.g., ``{reach}``) are replaced\n                with corresponding values from this dictionary.\n            repeat: Number of times to output the message. Defaults to 1.\n            indent: String to prepend to each output line for indentation.\n                Defaults to empty string.\n\n        Examples:\n            - Write a message to a StringIO buffer:\n\n                ```python\n                &gt;&gt;&gt; from pathlib import Path\n                &gt;&gt;&gt; from io import StringIO\n                &gt;&gt;&gt; from dfastbe.io.logger import LogData\n                &gt;&gt;&gt; LogData.reset()\n                &gt;&gt;&gt; log_data = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n                &gt;&gt;&gt; output = StringIO()\n                &gt;&gt;&gt; log_data.log_text(\"confirm\", file=output)\n                &gt;&gt;&gt; output.getvalue().splitlines()\n                ['Confirm using \"y\" ...', '']\n\n                ```\n            - Write a message with placeholder expansion:\n                ```python\n                &gt;&gt;&gt; output = StringIO()\n                &gt;&gt;&gt; log_data.log_text(\"reach\", file=output, data={\"reach\": \"River_ABC\"})\n                &gt;&gt;&gt; output.getvalue().strip()\n                'The measure is located on reach River_ABC'\n\n                ```\n            - Write to a file with indentation:\n                ```python\n                &gt;&gt;&gt; output = StringIO()\n                &gt;&gt;&gt; log_data.log_text(\"reach\", file=output, data={\"reach\": \"Test\"}, indent=\"  \")\n                &gt;&gt;&gt; output.getvalue()\n                '  The measure is located on reach Test\\\\n'\n\n                ```\n            - Repeat a message multiple times:\n                ```python\n                &gt;&gt;&gt; output = StringIO()\n                &gt;&gt;&gt; log_data.log_text(\"\", file=output, repeat=3)\n                &gt;&gt;&gt; len(output.getvalue().splitlines())\n                3\n\n                ```\n\n        See Also:\n            get_text: Retrieve raw message text without output.\n\n        \"\"\"\n        if data is None:\n            data = {}\n        str_value = self.get_text(key)\n        for _ in range(repeat):\n            for s in str_value:\n                try:\n                    sexp = s.format(**data)\n                except KeyError as e:\n                    raise KeyError(\n                        f\"Missing placeholder {e} in message '{key}'. \"\n                        f\"Available data keys: {list(data.keys())}\"\n                    ) from e\n                if file is None:\n                    print(indent + sexp)\n                else:\n                    file.write(indent + sexp + \"\\n\")\n</code></pre>"},{"location":"api/io.html#dfastbe.io.logger.LogData.__init__","title":"<code>__init__(file_name: Optional[str | Path] = None) -&gt; None</code>","text":"<p>Initialize the LogData singleton instance.</p> <p>Loads and parses the message file on first initialization. Subsequent calls to <code>__init__</code> are ignored since the instance is already initialized.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>Optional[str | Path]</code> <p>Path to the INI-style message file. Required on first instantiation, ignored on subsequent calls.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>file_name</code> is None on first instantiation.</p> <p>Examples:</p> <ul> <li>Initialize with a message file and access loaded data:     <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from dfastbe.io.logger import LogData\n&gt;&gt;&gt; LogData.reset()\n&gt;&gt;&gt; log_data = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n&gt;&gt;&gt; len(log_data.data) &gt; 0\nTrue\n&gt;&gt;&gt; \"confirm\" in log_data.data\nTrue\n</code></pre></li> </ul> Source code in <code>src/dfastbe/io/logger.py</code> <pre><code>def __init__(self, file_name: Optional[str | Path] = None) -&gt; None:\n    \"\"\"Initialize the LogData singleton instance.\n\n    Loads and parses the message file on first initialization. Subsequent\n    calls to ``__init__`` are ignored since the instance is already initialized.\n\n    Args:\n        file_name: Path to the INI-style message file. Required on first\n            instantiation, ignored on subsequent calls.\n\n    Raises:\n        ValueError: If ``file_name`` is None on first instantiation.\n\n    Examples:\n        - Initialize with a message file and access loaded data:\n            ```python\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from dfastbe.io.logger import LogData\n            &gt;&gt;&gt; LogData.reset()\n            &gt;&gt;&gt; log_data = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n            &gt;&gt;&gt; len(log_data.data) &gt; 0\n            True\n            &gt;&gt;&gt; \"confirm\" in log_data.data\n            True\n\n            ```\n\n    \"\"\"\n    if not self._initialized:\n        if file_name is None:\n            raise ValueError(\"file_name must be provided on first instantiation\")\n        self.data = self.read_data(file_name)\n        self._initialized = True\n</code></pre>"},{"location":"api/io.html#dfastbe.io.logger.LogData.__new__","title":"<code>__new__(file_name: Optional[str | Path] = None) -&gt; 'LogData'</code>","text":"<p>Create or return the singleton LogData instance.</p> <p>Implements the singleton pattern using <code>__new__</code>. On first call, creates a new instance and stores it. Subsequent calls return the existing instance.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>Optional[str | Path]</code> <p>Path to the INI-style message file. Required on first instantiation, optional on subsequent calls.</p> <code>None</code> <p>Returns:</p> Type Description <code>'LogData'</code> <p>The singleton LogData instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>file_name</code> is None on first instantiation.</p> <p>Examples:</p> <ul> <li>First instantiation requires a file path:     <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from dfastbe.io.logger import LogData\n&gt;&gt;&gt; LogData.reset()\n&gt;&gt;&gt; log_data = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n&gt;&gt;&gt; log_data._initialized\nTrue\n</code></pre></li> <li>Subsequent calls without file_name return the same instance:     <pre><code>&gt;&gt;&gt; log_data2 = LogData()\n&gt;&gt;&gt; log_data is log_data2\nTrue\n</code></pre></li> </ul> Source code in <code>src/dfastbe/io/logger.py</code> <pre><code>def __new__(cls, file_name: Optional[str | Path] = None) -&gt; \"LogData\":\n    \"\"\"Create or return the singleton LogData instance.\n\n    Implements the singleton pattern using ``__new__``. On first call,\n    creates a new instance and stores it. Subsequent calls return the\n    existing instance.\n\n    Args:\n        file_name: Path to the INI-style message file. Required on first\n            instantiation, optional on subsequent calls.\n\n    Returns:\n        The singleton LogData instance.\n\n    Raises:\n        ValueError: If ``file_name`` is None on first instantiation.\n\n    Examples:\n        - First instantiation requires a file path:\n            ```python\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from dfastbe.io.logger import LogData\n            &gt;&gt;&gt; LogData.reset()\n            &gt;&gt;&gt; log_data = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n            &gt;&gt;&gt; log_data._initialized\n            True\n\n            ```\n        - Subsequent calls without file_name return the same instance:\n            ```python\n            &gt;&gt;&gt; log_data2 = LogData()\n            &gt;&gt;&gt; log_data is log_data2\n            True\n\n            ```\n    \"\"\"\n    if cls._instance is None:\n        if file_name is None:\n            raise ValueError(\"file_name must be provided on first instantiation\")\n        cls._instance = super().__new__(cls)\n        cls._instance._initialized = False\n    return cls._instance\n</code></pre>"},{"location":"api/io.html#dfastbe.io.logger.LogData.get_text","title":"<code>get_text(key: str) -&gt; List[str]</code>","text":"<p>Retrieve text lines associated with a message key.</p> <p>Queries the internal message dictionary and returns the list of strings stored for the given key. If the key is not found, returns a default \"not found\" message.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The message key to look up in the dictionary.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of strings containing the text for the key. If the key is not</p> <code>List[str]</code> <p>found, returns <code>[\"No message found for &lt;key&gt;\"]</code>.</p> <p>Examples:</p> <ul> <li>Retrieve an existing message:     <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from dfastbe.io.logger import LogData\n&gt;&gt;&gt; LogData.reset()\n&gt;&gt;&gt; log_data = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n&gt;&gt;&gt; log_data.get_text(\"confirm\")\n['Confirm using \"y\" ...', '']\n</code></pre></li> <li>Retrieve a message with placeholder:     <pre><code>&gt;&gt;&gt; log_data.get_text(\"reach\")\n['The measure is located on reach {reach}']\n</code></pre></li> <li>Handle non-existent key:     <pre><code>&gt;&gt;&gt; log_data.get_text(\"nonexistent_key\")\n['No message found for nonexistent_key']\n</code></pre></li> <li>Empty string key retrieves empty line content:     <pre><code>&gt;&gt;&gt; log_data.get_text(\"\")\n['']\n</code></pre></li> </ul> Source code in <code>src/dfastbe/io/logger.py</code> <pre><code>def get_text(self, key: str) -&gt; List[str]:\n    \"\"\"Retrieve text lines associated with a message key.\n\n    Queries the internal message dictionary and returns the list of strings\n    stored for the given key. If the key is not found, returns a default\n    \"not found\" message.\n\n    Args:\n        key: The message key to look up in the dictionary.\n\n    Returns:\n        List of strings containing the text for the key. If the key is not\n        found, returns ``[\"No message found for &lt;key&gt;\"]``.\n\n    Examples:\n        - Retrieve an existing message:\n            ```python\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from dfastbe.io.logger import LogData\n            &gt;&gt;&gt; LogData.reset()\n            &gt;&gt;&gt; log_data = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n            &gt;&gt;&gt; log_data.get_text(\"confirm\")\n            ['Confirm using \"y\" ...', '']\n\n            ```\n        - Retrieve a message with placeholder:\n            ```python\n            &gt;&gt;&gt; log_data.get_text(\"reach\")\n            ['The measure is located on reach {reach}']\n\n            ```\n        - Handle non-existent key:\n            ```python\n            &gt;&gt;&gt; log_data.get_text(\"nonexistent_key\")\n            ['No message found for nonexistent_key']\n\n            ```\n        - Empty string key retrieves empty line content:\n            ```python\n            &gt;&gt;&gt; log_data.get_text(\"\")\n            ['']\n\n            ```\n    \"\"\"\n    if key in self.data:\n        val = self.data[key]\n    else:\n        val = [f\"No message found for {key}\"]\n    return val\n</code></pre>"},{"location":"api/io.html#dfastbe.io.logger.LogData.log_text","title":"<code>log_text(key: str, file: Optional[TextIO] = None, data: Optional[Dict[str, Any]] = None, repeat: int = 1, indent: str = '') -&gt; None</code>","text":"<p>Write a localized message to standard output or a file.</p> <p>Retrieves the text associated with the given key and outputs it to either standard output or a specified file. Supports placeholder expansion using Python's string formatting, repetition, and indentation.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The message key to retrieve and output.</p> required <code>file</code> <code>Optional[TextIO]</code> <p>File object to write to. If None, writes to standard output.</p> <code>None</code> <code>data</code> <code>Optional[Dict[str, Any]]</code> <p>Dictionary for placeholder expansion in the message text. Placeholders in the message (e.g., <code>{reach}</code>) are replaced with corresponding values from this dictionary.</p> <code>None</code> <code>repeat</code> <code>int</code> <p>Number of times to output the message. Defaults to 1.</p> <code>1</code> <code>indent</code> <code>str</code> <p>String to prepend to each output line for indentation. Defaults to empty string.</p> <code>''</code> <p>Examples:</p> <ul> <li> <p>Write a message to a StringIO buffer:</p> <p><pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from io import StringIO\n&gt;&gt;&gt; from dfastbe.io.logger import LogData\n&gt;&gt;&gt; LogData.reset()\n&gt;&gt;&gt; log_data = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n&gt;&gt;&gt; output = StringIO()\n&gt;&gt;&gt; log_data.log_text(\"confirm\", file=output)\n&gt;&gt;&gt; output.getvalue().splitlines()\n['Confirm using \"y\" ...', '']\n</code></pre> - Write a message with placeholder expansion: <pre><code>&gt;&gt;&gt; output = StringIO()\n&gt;&gt;&gt; log_data.log_text(\"reach\", file=output, data={\"reach\": \"River_ABC\"})\n&gt;&gt;&gt; output.getvalue().strip()\n'The measure is located on reach River_ABC'\n</code></pre> - Write to a file with indentation: <pre><code>&gt;&gt;&gt; output = StringIO()\n&gt;&gt;&gt; log_data.log_text(\"reach\", file=output, data={\"reach\": \"Test\"}, indent=\"  \")\n&gt;&gt;&gt; output.getvalue()\n'  The measure is located on reach Test\\n'\n</code></pre> - Repeat a message multiple times: <pre><code>&gt;&gt;&gt; output = StringIO()\n&gt;&gt;&gt; log_data.log_text(\"\", file=output, repeat=3)\n&gt;&gt;&gt; len(output.getvalue().splitlines())\n3\n</code></pre></p> </li> </ul> See Also <p>get_text: Retrieve raw message text without output.</p> Source code in <code>src/dfastbe/io/logger.py</code> <pre><code>def log_text(\n    self,\n    key: str,\n    file: Optional[TextIO] = None,\n    data: Optional[Dict[str, Any]] = None,\n    repeat: int = 1,\n    indent: str = \"\",\n) -&gt; None:\n    \"\"\"Write a localized message to standard output or a file.\n\n    Retrieves the text associated with the given key and outputs it to either\n    standard output or a specified file. Supports placeholder expansion using\n    Python's string formatting, repetition, and indentation.\n\n    Args:\n        key: The message key to retrieve and output.\n        file: File object to write to. If None, writes to standard output.\n        data: Dictionary for placeholder expansion in the message text.\n            Placeholders in the message (e.g., ``{reach}``) are replaced\n            with corresponding values from this dictionary.\n        repeat: Number of times to output the message. Defaults to 1.\n        indent: String to prepend to each output line for indentation.\n            Defaults to empty string.\n\n    Examples:\n        - Write a message to a StringIO buffer:\n\n            ```python\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from io import StringIO\n            &gt;&gt;&gt; from dfastbe.io.logger import LogData\n            &gt;&gt;&gt; LogData.reset()\n            &gt;&gt;&gt; log_data = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n            &gt;&gt;&gt; output = StringIO()\n            &gt;&gt;&gt; log_data.log_text(\"confirm\", file=output)\n            &gt;&gt;&gt; output.getvalue().splitlines()\n            ['Confirm using \"y\" ...', '']\n\n            ```\n        - Write a message with placeholder expansion:\n            ```python\n            &gt;&gt;&gt; output = StringIO()\n            &gt;&gt;&gt; log_data.log_text(\"reach\", file=output, data={\"reach\": \"River_ABC\"})\n            &gt;&gt;&gt; output.getvalue().strip()\n            'The measure is located on reach River_ABC'\n\n            ```\n        - Write to a file with indentation:\n            ```python\n            &gt;&gt;&gt; output = StringIO()\n            &gt;&gt;&gt; log_data.log_text(\"reach\", file=output, data={\"reach\": \"Test\"}, indent=\"  \")\n            &gt;&gt;&gt; output.getvalue()\n            '  The measure is located on reach Test\\\\n'\n\n            ```\n        - Repeat a message multiple times:\n            ```python\n            &gt;&gt;&gt; output = StringIO()\n            &gt;&gt;&gt; log_data.log_text(\"\", file=output, repeat=3)\n            &gt;&gt;&gt; len(output.getvalue().splitlines())\n            3\n\n            ```\n\n    See Also:\n        get_text: Retrieve raw message text without output.\n\n    \"\"\"\n    if data is None:\n        data = {}\n    str_value = self.get_text(key)\n    for _ in range(repeat):\n        for s in str_value:\n            try:\n                sexp = s.format(**data)\n            except KeyError as e:\n                raise KeyError(\n                    f\"Missing placeholder {e} in message '{key}'. \"\n                    f\"Available data keys: {list(data.keys())}\"\n                ) from e\n            if file is None:\n                print(indent + sexp)\n            else:\n                file.write(indent + sexp + \"\\n\")\n</code></pre>"},{"location":"api/io.html#dfastbe.io.logger.LogData.read_data","title":"<code>read_data(file_name: str | Path) -&gt; dict[str, list[str]]</code>","text":"<p>Load and parse texts from an INI-style configuration file.</p> <p>Reads the specified file and parses it into a dictionary where keys are identified by lines enclosed in square brackets (e.g., <code>[key_name]</code>). All lines following a key until the next key become the value (as a list of strings). This format supports multi-language localization.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str | Path</code> <p>Path to the INI-style message file to read and parse.</p> required <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>Dictionary mapping string keys to lists of text lines. Each key</p> <code>dict[str, list[str]]</code> <p>corresponds to a bracketed section header, and the value contains</p> <code>dict[str, list[str]]</code> <p>all lines between that header and the next.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a duplicate key is found in the file.</p> <code>FileNotFoundError</code> <p>If the specified file does not exist.</p> <p>Examples:</p> <ul> <li>Read and parse a message file:     <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from dfastbe.io.logger import LogData\n&gt;&gt;&gt; LogData.reset()\n&gt;&gt;&gt; log_data = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n&gt;&gt;&gt; data = log_data.data\n&gt;&gt;&gt; type(data)\n&lt;class 'dict'&gt;\n</code></pre></li> <li>Examine the structure of parsed data:     <pre><code>&gt;&gt;&gt; data[\"confirm\"]\n['Confirm using \"y\" ...', '']\n&gt;&gt;&gt; data[\"reach\"]\n['The measure is located on reach {reach}']\n</code></pre></li> <li>Empty key captures content before first bracketed section:     <pre><code>&gt;&gt;&gt; data[\"\"]\n['']\n</code></pre></li> </ul> Source code in <code>src/dfastbe/io/logger.py</code> <pre><code>def read_data(self, file_name: str | Path) -&gt; dict[str, list[str]]:\n    \"\"\"Load and parse texts from an INI-style configuration file.\n\n    Reads the specified file and parses it into a dictionary where keys are\n    identified by lines enclosed in square brackets (e.g., ``[key_name]``).\n    All lines following a key until the next key become the value (as a list\n    of strings). This format supports multi-language localization.\n\n    Args:\n        file_name: Path to the INI-style message file to read and parse.\n\n    Returns:\n        Dictionary mapping string keys to lists of text lines. Each key\n        corresponds to a bracketed section header, and the value contains\n        all lines between that header and the next.\n\n    Raises:\n        ValueError: If a duplicate key is found in the file.\n        FileNotFoundError: If the specified file does not exist.\n\n    Examples:\n        - Read and parse a message file:\n            ```python\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from dfastbe.io.logger import LogData\n            &gt;&gt;&gt; LogData.reset()\n            &gt;&gt;&gt; log_data = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n            &gt;&gt;&gt; data = log_data.data\n            &gt;&gt;&gt; type(data)\n            &lt;class 'dict'&gt;\n\n            ```\n        - Examine the structure of parsed data:\n            ```python\n            &gt;&gt;&gt; data[\"confirm\"]\n            ['Confirm using \"y\" ...', '']\n            &gt;&gt;&gt; data[\"reach\"]\n            ['The measure is located on reach {reach}']\n\n            ```\n        - Empty key captures content before first bracketed section:\n            ```python\n            &gt;&gt;&gt; data[\"\"]\n            ['']\n\n            ```\n    \"\"\"\n    with open(file_name, \"r\", encoding=\"utf-8\") as f:\n        all_lines = f.read().splitlines()\n\n    data: Dict[str, List[str]] = {}\n    text: List[str] = []\n    key = None\n\n    for line in all_lines:\n        r_line = line.strip()\n        if r_line.startswith(\"[\") and r_line.endswith(\"]\"):\n            if key is not None:\n                if key in data:\n                    raise ValueError(f\"Duplicate entry for '{key}' in {file_name}.\")\n                data[key] = text\n            key = r_line[1:-1]\n            text = []\n        else:\n            text.append(line)\n\n    # Handle the last key\n    if key is not None:\n        if key in data:\n            raise ValueError(f\"Duplicate entry for '{key}' in {file_name}.\")\n        data[key] = text\n\n    return data\n</code></pre>"},{"location":"api/io.html#dfastbe.io.logger.LogData.reset","title":"<code>reset() -&gt; None</code>  <code>classmethod</code>","text":"<p>Reset the singleton instance to allow re-initialization.</p> <p>This class method clears the singleton instance, allowing a new instance to be created with a different message file. Useful for testing or switching between language files.</p> <p>Examples:</p> <ul> <li>Reset and reinitialize with a different file:     <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from dfastbe.io.logger import LogData\n&gt;&gt;&gt; LogData.reset()\n&gt;&gt;&gt; log_data1 = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n&gt;&gt;&gt; id1 = id(log_data1)\n&gt;&gt;&gt; LogData.reset()\n&gt;&gt;&gt; log_data2 = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n&gt;&gt;&gt; id1 != id(log_data2)\nTrue\n</code></pre></li> </ul> Source code in <code>src/dfastbe/io/logger.py</code> <pre><code>@classmethod\ndef reset(cls) -&gt; None:\n    \"\"\"Reset the singleton instance to allow re-initialization.\n\n    This class method clears the singleton instance, allowing a new instance\n    to be created with a different message file. Useful for testing or\n    switching between language files.\n\n    Examples:\n        - Reset and reinitialize with a different file:\n            ```python\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from dfastbe.io.logger import LogData\n            &gt;&gt;&gt; LogData.reset()\n            &gt;&gt;&gt; log_data1 = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n            &gt;&gt;&gt; id1 = id(log_data1)\n            &gt;&gt;&gt; LogData.reset()\n            &gt;&gt;&gt; log_data2 = LogData(Path(\"tests/data/files/messages.UK.ini\"))\n            &gt;&gt;&gt; id1 != id(log_data2)\n            True\n\n            ```\n    \"\"\"\n    cls._instance = None\n</code></pre>"},{"location":"api/io.html#dfastbe.io.logger.timed_logger","title":"<code>timed_logger(label: str) -&gt; None</code>","text":"<p>Write a message with time information.</p>"},{"location":"api/io.html#dfastbe.io.logger.timed_logger--arguments","title":"Arguments","text":"<p>label : str     Message string.</p> Source code in <code>src/dfastbe/io/logger.py</code> <pre><code>def timed_logger(label: str) -&gt; None:\n    \"\"\"\n    Write a message with time information.\n\n    Arguments\n    ---------\n    label : str\n        Message string.\n    \"\"\"\n    time, diff = _timer()\n    print(time + diff + label)\n</code></pre>"},{"location":"api/io.html#workflow","title":"Workflow","text":"<p>The typical workflow for using the I/O module is:</p> <ol> <li>Read a configuration file using the <code>ConfigFile.read</code> method</li> <li>Use the configuration to load input data (hydrodynamic simulation results, bank lines, etc.)</li> <li>Process the data using the Bank Lines and Bank Erosion modules</li> <li>Save the results using the I/O module's functions</li> </ol>"},{"location":"api/io.html#usage-example","title":"Usage Example","text":"<pre><code>from dfastbe.io.config import ConfigFile\nfrom dfastbe.bank_erosion.bank_erosion import Erosion\n\n# Read configuration file\nconfig_file = ConfigFile.read(\"config.cfg\")\n\n# Use configuration to initialize Erosion object\nerosion = Erosion(config_file)\n\n# Run erosion calculation (which will use I/O module to load and save data)\nerosion.run()\n</code></pre> <p>For more details on the specific classes and functions, refer to the API reference below.</p>"},{"location":"api/plotting.html","title":"Plotting Module","text":"<p>The Plotting module provides functions for generating visualizations of bank lines, erosion results, and other data in the D-FAST Bank Erosion software.</p>"},{"location":"api/plotting.html#overview","title":"Overview","text":"<p>The Plotting module contains functions for creating various types of plots and visualizations that help users understand the results of bank line detection and erosion calculations. These visualizations include maps of bank lines, erosion profiles, and time series of erosion volumes.</p>"},{"location":"api/plotting.html#components","title":"Components","text":"<p>The Plotting module consists of the following components:</p>"},{"location":"api/plotting.html#plotting-functions","title":"Plotting Functions","text":"<p>The plotting functions component provides functions for creating various types of visualizations, such as:</p> <ul> <li>Maps of bank lines and erosion results</li> <li>Profiles of bank erosion</li> <li>Time series of erosion volumes</li> <li>Visualizations of hydrodynamic data</li> </ul>"},{"location":"api/plotting.html#dfastbe.plotting","title":"<code>dfastbe.plotting</code>","text":"<p>Copyright (C) 2025 Stichting Deltares.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation version 2.1.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, see http://www.gnu.org/licenses/.</p> <p>contact: delft3d.support@deltares.nl Stichting Deltares P.O. Box 177 2600 MH Delft, The Netherlands</p> <p>All indications and logos of, and references to, \"Delft3D\" and \"Deltares\" are registered trademarks of Stichting Deltares, and remain the property of Stichting Deltares. All rights reserved.</p> <p>INFORMATION This file is part of D-FAST Bank Erosion: https://github.com/Deltares/D-FAST_Bank_Erosion</p>"},{"location":"api/plotting.html#dfastbe.plotting.BasePlot","title":"<code>BasePlot</code>","text":"Source code in <code>src/dfastbe/plotting.py</code> <pre><code>class BasePlot:\n\n    def __init__(self, gui, plot_flags: PlotProperties) -&gt; None:\n        self.gui = gui\n        self.flags = plot_flags\n\n    def stations_marker(\n        self,\n        river_center_line_arr: np.ndarray,\n        ax: Axes,\n        float_format: int = 1,\n        scale: float = 1000,\n    ) -&gt; None:\n        \"\"\"\n        Add markers indicating the river chainage to a plot.\n\n        Arguments\n        ---------\n        river_center_line_arr : np.ndarray\n            Array containing the x, y, and chainage; unit m for x and y, km for chainage.\n        ax : matplotlib.axes.Axes\n            Axes object in which to add the markers.\n        float_format : int\n            Number of decimals used for marks.\n        scale: float\n            Indicates whether the axes are in m (1) or km (1000).\n        \"\"\"\n        step = 10 ** (-float_format)\n        label_str = \" {:.\" + str(float_format) + \"f}\"\n        km_rescaled = river_center_line_arr[:, 2] / step\n        mask = np.isclose(np.round(km_rescaled), km_rescaled)\n        ax.plot(\n            river_center_line_arr[mask, 0] / scale,\n            river_center_line_arr[mask, 1] / scale,\n            linestyle=\"None\",\n            marker=\"+\",\n            color=\"k\",\n        )\n        for i in np.nonzero(mask)[0]:\n            ax.text(\n                river_center_line_arr[i, 0] / scale,\n                river_center_line_arr[i, 1] / scale,\n                label_str.format(river_center_line_arr[i, 2]),\n                fontsize=\"x-small\",\n                clip_on=True,\n            )\n\n    # def plot_mesh(\n    #     self,\n    #     ax: Axes,\n    #     xe: np.ndarray,\n    #     ye: np.ndarray,\n    #     scale: float = 1000,\n    # ) -&gt; None:\n    #     \"\"\"\n    #     Add a mesh to a plot.\n    #\n    #     Arguments\n    #     ---------\n    #     ax : matplotlib.axes.Axes\n    #         Axes object in which to add the mesh.\n    #     xe : np.ndarray\n    #         M x 2 array of begin/end x-coordinates of mesh edges.\n    #     ye : np.ndarray\n    #         M x 2 array of begin/end y-coordinates of mesh edges.\n    #     scale : float\n    #         Indicates whether the axes are in m (1) or km (1000).\n    #     \"\"\"\n    #     xe1 = xe[:, (0, 1, 1)] / scale\n    #     xe1[:, 2] = np.nan\n    #     xev = xe1.reshape((xe1.size,))\n    #\n    #     ye1 = ye[:, (0, 1, 1)] / scale\n    #     ye1[:, 2] = np.nan\n    #     yev = ye1.reshape((ye1.size,))\n    #\n    #     # to avoid OverflowError: In draw_path: Exceeded cell block limit\n    #     # plot the data in chunks ...\n    #     for i in range(0, len(xev), 3000):\n    #         ax.plot(\n    #             xev[i : i + 3000],\n    #             yev[i : i + 3000],\n    #             color=(0.5, 0.5, 0.5),\n    #             linewidth=0.25,\n    #         )\n\n    def mesh_patches(\n        self,\n        ax: Axes,\n        simulation_data: BaseSimulationData,\n        minval: Optional[float] = None,\n        maxval: Optional[float] = None,\n        scale: float = 1000,\n    ) -&gt; matplotlib.collections.PolyCollection:\n        \"\"\"\n        Add a collection of patches to the plot one for every face of the mesh.\n\n        Arguments\n        ---------\n        ax : matplotlib.axes.Axes\n            Axes object in which to add the mesh.\n        minval : Optional[float]\n            Lower limit for the color scale.\n        maxval : Optional[float]\n            Upper limit for the color scale.\n        scale : float\n            Indicates whether the axes are in m (1) or km (1000).\n\n        Returns\n        -------\n        p : matplotlib.collections.PolyCollection\n            Patches object.\n        \"\"\"\n        tfn_list = []\n        tval_list = []\n        for n in range(3, max(simulation_data.n_nodes) + 1):\n            mask = simulation_data.n_nodes &gt;= n\n            fn_masked = simulation_data.face_node[mask, :]\n            tfn_list.append(fn_masked[:, (0, n - 2, n - 1)])\n            tval_list.append(simulation_data.water_depth_face[mask])\n        tfn = np.concatenate(tfn_list, axis=0)\n        tval = np.concatenate(tval_list, axis=0)\n\n        if minval is None:\n            minval = np.min(tval)\n        if maxval is None:\n            maxval = np.max(tval)\n        p = ax.tripcolor(\n            simulation_data.x_node / scale,\n            simulation_data.y_node / scale,\n            tfn,\n            facecolors=tval,\n            cmap=\"Spectral\",\n            vmin=minval,\n            vmax=maxval,\n        )\n        return p\n\n    def get_colors(self, cmap_name: str, n: int) -&gt; List[Tuple[float, float, float]]:\n        \"\"\"\n        Obtain N colors from the specified colormap.\n\n        Arguments\n        ---------\n        cmap_name : str\n            Name of the color map.\n        n : int\n            Number of colors to be returned.\n\n        Returns\n        -------\n        clrcyc : List[Tuple[float, float, float]]\n            List of colour tuplets.\n        \"\"\"\n        cmap = matplotlib.cm.get_cmap(cmap_name)\n        clrs = [cmap(i / (n - 1)) for i in range(n)]\n        return clrs\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.BasePlot.get_colors","title":"<code>get_colors(cmap_name: str, n: int) -&gt; List[Tuple[float, float, float]]</code>","text":"<p>Obtain N colors from the specified colormap.</p>"},{"location":"api/plotting.html#dfastbe.plotting.BasePlot.get_colors--arguments","title":"Arguments","text":"<p>cmap_name : str     Name of the color map. n : int     Number of colors to be returned.</p>"},{"location":"api/plotting.html#dfastbe.plotting.BasePlot.get_colors--returns","title":"Returns","text":"<p>clrcyc : List[Tuple[float, float, float]]     List of colour tuplets.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def get_colors(self, cmap_name: str, n: int) -&gt; List[Tuple[float, float, float]]:\n    \"\"\"\n    Obtain N colors from the specified colormap.\n\n    Arguments\n    ---------\n    cmap_name : str\n        Name of the color map.\n    n : int\n        Number of colors to be returned.\n\n    Returns\n    -------\n    clrcyc : List[Tuple[float, float, float]]\n        List of colour tuplets.\n    \"\"\"\n    cmap = matplotlib.cm.get_cmap(cmap_name)\n    clrs = [cmap(i / (n - 1)) for i in range(n)]\n    return clrs\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.BasePlot.mesh_patches","title":"<code>mesh_patches(ax: Axes, simulation_data: BaseSimulationData, minval: Optional[float] = None, maxval: Optional[float] = None, scale: float = 1000) -&gt; matplotlib.collections.PolyCollection</code>","text":"<p>Add a collection of patches to the plot one for every face of the mesh.</p>"},{"location":"api/plotting.html#dfastbe.plotting.BasePlot.mesh_patches--arguments","title":"Arguments","text":"<p>ax : matplotlib.axes.Axes     Axes object in which to add the mesh. minval : Optional[float]     Lower limit for the color scale. maxval : Optional[float]     Upper limit for the color scale. scale : float     Indicates whether the axes are in m (1) or km (1000).</p>"},{"location":"api/plotting.html#dfastbe.plotting.BasePlot.mesh_patches--returns","title":"Returns","text":"<p>p : matplotlib.collections.PolyCollection     Patches object.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def mesh_patches(\n    self,\n    ax: Axes,\n    simulation_data: BaseSimulationData,\n    minval: Optional[float] = None,\n    maxval: Optional[float] = None,\n    scale: float = 1000,\n) -&gt; matplotlib.collections.PolyCollection:\n    \"\"\"\n    Add a collection of patches to the plot one for every face of the mesh.\n\n    Arguments\n    ---------\n    ax : matplotlib.axes.Axes\n        Axes object in which to add the mesh.\n    minval : Optional[float]\n        Lower limit for the color scale.\n    maxval : Optional[float]\n        Upper limit for the color scale.\n    scale : float\n        Indicates whether the axes are in m (1) or km (1000).\n\n    Returns\n    -------\n    p : matplotlib.collections.PolyCollection\n        Patches object.\n    \"\"\"\n    tfn_list = []\n    tval_list = []\n    for n in range(3, max(simulation_data.n_nodes) + 1):\n        mask = simulation_data.n_nodes &gt;= n\n        fn_masked = simulation_data.face_node[mask, :]\n        tfn_list.append(fn_masked[:, (0, n - 2, n - 1)])\n        tval_list.append(simulation_data.water_depth_face[mask])\n    tfn = np.concatenate(tfn_list, axis=0)\n    tval = np.concatenate(tval_list, axis=0)\n\n    if minval is None:\n        minval = np.min(tval)\n    if maxval is None:\n        maxval = np.max(tval)\n    p = ax.tripcolor(\n        simulation_data.x_node / scale,\n        simulation_data.y_node / scale,\n        tfn,\n        facecolors=tval,\n        cmap=\"Spectral\",\n        vmin=minval,\n        vmax=maxval,\n    )\n    return p\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.BasePlot.stations_marker","title":"<code>stations_marker(river_center_line_arr: np.ndarray, ax: Axes, float_format: int = 1, scale: float = 1000) -&gt; None</code>","text":"<p>Add markers indicating the river chainage to a plot.</p>"},{"location":"api/plotting.html#dfastbe.plotting.BasePlot.stations_marker--arguments","title":"Arguments","text":"<p>river_center_line_arr : np.ndarray     Array containing the x, y, and chainage; unit m for x and y, km for chainage. ax : matplotlib.axes.Axes     Axes object in which to add the markers. float_format : int     Number of decimals used for marks. scale: float     Indicates whether the axes are in m (1) or km (1000).</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def stations_marker(\n    self,\n    river_center_line_arr: np.ndarray,\n    ax: Axes,\n    float_format: int = 1,\n    scale: float = 1000,\n) -&gt; None:\n    \"\"\"\n    Add markers indicating the river chainage to a plot.\n\n    Arguments\n    ---------\n    river_center_line_arr : np.ndarray\n        Array containing the x, y, and chainage; unit m for x and y, km for chainage.\n    ax : matplotlib.axes.Axes\n        Axes object in which to add the markers.\n    float_format : int\n        Number of decimals used for marks.\n    scale: float\n        Indicates whether the axes are in m (1) or km (1000).\n    \"\"\"\n    step = 10 ** (-float_format)\n    label_str = \" {:.\" + str(float_format) + \"f}\"\n    km_rescaled = river_center_line_arr[:, 2] / step\n    mask = np.isclose(np.round(km_rescaled), km_rescaled)\n    ax.plot(\n        river_center_line_arr[mask, 0] / scale,\n        river_center_line_arr[mask, 1] / scale,\n        linestyle=\"None\",\n        marker=\"+\",\n        color=\"k\",\n    )\n    for i in np.nonzero(mask)[0]:\n        ax.text(\n            river_center_line_arr[i, 0] / scale,\n            river_center_line_arr[i, 1] / scale,\n            label_str.format(river_center_line_arr[i, 2]),\n            fontsize=\"x-small\",\n            clip_on=True,\n        )\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.Plot","title":"<code>Plot</code>","text":"Source code in <code>src/dfastbe/plotting.py</code> <pre><code>class Plot:\n\n    def __init__(\n        self,\n        plot_flags: PlotProperties,\n        scale: int = 1000,\n        aspect: int = None,\n        gui: bool = False,\n    ) -&gt; None:\n        \"\"\"\n\n        Args:\n            gui:\n            plot_flags:\n            scale: float\n                Indicates whether the axes are in m (1) or km (1000).\n        \"\"\"\n        self.gui = gui\n        self.flags = plot_flags\n        self._fig, self._ax = plt.subplots()\n        self.set_size()\n        if aspect:\n            self._ax.set_aspect(aspect)\n        self.scale = scale\n\n    @property\n    def fig(self) -&gt; Figure:\n        \"\"\"Get the figure object.\"\"\"\n        return self._fig\n\n    @property\n    def ax(self) -&gt; Axes:\n        \"\"\"Get the axes object.\"\"\"\n        return self._ax\n\n    def set_size(self) -&gt; None:\n        \"\"\"\n        Set the size of a figure.\n\n        Currently, the size is hardcoded, but functionality may be extended in the\n        future.\n        \"\"\"\n        # the size of an a3 is (16.5, 11.75)\n        # the size of an a3 is (16.5, 11.75)\n        self.fig.set_size_inches(11.75, 8.25)  # a4\n\n    def save_fig(self, path: Union[str, Path]) -&gt; None:\n        \"\"\"\n        Save a single figure to file.\n\n        Args:\n            path : str\n                Name of the file to be written.\n        \"\"\"\n        plt.show(block=False)\n        self.fig.savefig(path, dpi=300)\n\n    def save(\n        self,\n        figure_index: int,\n        plot_name: str,\n        zoom_coords: Optional[List[Tuple[float, float, float, float]]],\n        zoom_xy: bool,\n    ) -&gt; int:\n        \"\"\"Save the plot to a file.\"\"\"\n        figure_index += 1\n        path = Path(self.flags.save_dir) / f\"{figure_index}_{plot_name}\"\n        if self.flags.save_zoomed_plot and zoom_xy:\n            self._zoom_xy_and_save(path, self.flags.plot_extension, zoom_coords)\n        elif self.flags.save_zoomed_plot:\n            self._zoom_x_and_save(path, self.flags.plot_extension, zoom_coords)\n\n        fig_path = path.with_suffix(self.flags.plot_extension)\n        self.save_fig(fig_path)\n        return figure_index\n\n    def _zoom_x_and_save(\n        self,\n        path: Path,\n        plot_ext: str,\n        xzoom: List[Tuple[float, float]],\n    ) -&gt; None:\n        \"\"\"\n        Zoom in on subregions of the x-axis and save the figure.\n\n        Args:\n            path: Path\n\n            plot_ext : str\n                File extension of the figure to be saved.\n            xzoom : List[list[float,float]]\n                Values at which to split the x-axis.\n        \"\"\"\n        x_min, x_max = self.ax.get_xlim()\n        for ix, zoom in enumerate(xzoom):\n            self.ax.set_xlim(xmin=zoom[0], xmax=zoom[1])\n            path = path.with_name(f\"{path.stem}.sub{str(ix + 1)}{plot_ext}\")\n            self.save_fig(path)\n        self.ax.set_xlim(xmin=x_min, xmax=x_max)\n\n    def _zoom_xy_and_save(\n        self,\n        fig_base: Path,\n        plot_ext: str,\n        xyzoom: List[Tuple[float, float, float, float]],\n    ) -&gt; None:\n        \"\"\"\n        Zoom in on subregions in x,y-space and save the figure.\n\n        Args:\n            fig_base : str\n                Base name of the figure to be saved.\n            plot_ext : str\n                File extension of the figure to be saved.\n            xyzoom : List[List[float, float, float, float]]\n                List of xmin, xmax, ymin, ymax values to zoom into.\n        \"\"\"\n        xmin, xmax = self.ax.get_xlim()\n        ymin, ymax = self.ax.get_ylim()\n\n        dx_zoom = 0\n        xy_ratio = (ymax - ymin) / (xmax - xmin)\n        for zoom in xyzoom:\n            xmin0 = zoom[0]\n            xmax0 = zoom[1]\n            ymin0 = zoom[2]\n            ymax0 = zoom[3]\n            dx = xmax0 - xmin0\n            dy = ymax0 - ymin0\n            if dy &lt; xy_ratio * dx:\n                # x range limiting\n                dx_zoom = max(dx_zoom, dx)\n            else:\n                # y range limiting\n                dx_zoom = max(dx_zoom, dy / xy_ratio)\n        dy_zoom = dx_zoom * xy_ratio\n\n        for ix, zoom in enumerate(xyzoom):\n            x0 = (zoom[0] + zoom[1]) / 2\n            y0 = (zoom[2] + zoom[3]) / 2\n            self.ax.set_xlim(\n                xmin=(x0 - dx_zoom / 2) / self.scale, xmax=(x0 + dx_zoom / 2) / self.scale\n            )\n            self.ax.set_ylim(\n                ymin=(y0 - dy_zoom / 2) / self.scale, ymax=(y0 + dy_zoom / 2) / self.scale\n            )\n            path = fig_base.with_name(f\"{fig_base.stem}.sub{str(ix + 1)}{plot_ext}\")\n            self.save_fig(path)\n\n        self.ax.set_xlim(xmin=xmin, xmax=xmax)\n        self.ax.set_ylim(ymin=ymin, ymax=ymax)\n\n    def set_axes_properties(\n        self,\n        x_label: str,\n        y_label: str,\n        grid: bool,\n        title_txt: str,\n        handles: Optional[List[Any]] = None,\n        labels: Optional[List[str]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Set the properties of the axes.\n\n        Args:\n            ax (Axes): The axes object to set properties for.\n            x_label (str): Label for the horizontal chainage axes.\n            y_label (str): Label for the vertical axes.\n            title_txt (str): Title for the plot.\n        \"\"\"\n        self.ax.set_xlabel(x_label)\n        self.ax.set_ylabel(y_label)\n        self.ax.grid(grid)\n        self.ax.set_title(title_txt)\n        if handles and labels:\n            self.ax.legend(handles, labels, loc=\"upper right\")\n        else:\n            self.ax.legend(loc=\"upper right\")\n\n    def set_bbox(\n        self,\n        bbox: Tuple[float, float, float, float],\n    ) -&gt; None:\n        \"\"\"\n        Specify the bounding limits of an axes object.\n\n        Args:\n            bbox : Tuple[float, float, float, float]\n                Tuple containing boundary limits (xmin, ymin, xmax, ymax); unit m.\n        \"\"\"\n        self.ax.set_xlim(xmin=bbox[0] / self.scale, xmax=bbox[2] / self.scale)\n        self.ax.set_ylim(ymin=bbox[1] / self.scale, ymax=bbox[3] / self.scale)\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.Plot.ax","title":"<code>ax: Axes</code>  <code>property</code>","text":"<p>Get the axes object.</p>"},{"location":"api/plotting.html#dfastbe.plotting.Plot.fig","title":"<code>fig: Figure</code>  <code>property</code>","text":"<p>Get the figure object.</p>"},{"location":"api/plotting.html#dfastbe.plotting.Plot.__init__","title":"<code>__init__(plot_flags: PlotProperties, scale: int = 1000, aspect: int = None, gui: bool = False) -&gt; None</code>","text":"<p>Parameters:</p> Name Type Description Default <code>gui</code> <code>bool</code> <code>False</code> <code>plot_flags</code> <code>PlotProperties</code> required <code>scale</code> <code>int</code> <p>float Indicates whether the axes are in m (1) or km (1000).</p> <code>1000</code> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def __init__(\n    self,\n    plot_flags: PlotProperties,\n    scale: int = 1000,\n    aspect: int = None,\n    gui: bool = False,\n) -&gt; None:\n    \"\"\"\n\n    Args:\n        gui:\n        plot_flags:\n        scale: float\n            Indicates whether the axes are in m (1) or km (1000).\n    \"\"\"\n    self.gui = gui\n    self.flags = plot_flags\n    self._fig, self._ax = plt.subplots()\n    self.set_size()\n    if aspect:\n        self._ax.set_aspect(aspect)\n    self.scale = scale\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.Plot.save","title":"<code>save(figure_index: int, plot_name: str, zoom_coords: Optional[List[Tuple[float, float, float, float]]], zoom_xy: bool) -&gt; int</code>","text":"<p>Save the plot to a file.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def save(\n    self,\n    figure_index: int,\n    plot_name: str,\n    zoom_coords: Optional[List[Tuple[float, float, float, float]]],\n    zoom_xy: bool,\n) -&gt; int:\n    \"\"\"Save the plot to a file.\"\"\"\n    figure_index += 1\n    path = Path(self.flags.save_dir) / f\"{figure_index}_{plot_name}\"\n    if self.flags.save_zoomed_plot and zoom_xy:\n        self._zoom_xy_and_save(path, self.flags.plot_extension, zoom_coords)\n    elif self.flags.save_zoomed_plot:\n        self._zoom_x_and_save(path, self.flags.plot_extension, zoom_coords)\n\n    fig_path = path.with_suffix(self.flags.plot_extension)\n    self.save_fig(fig_path)\n    return figure_index\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.Plot.save_fig","title":"<code>save_fig(path: Union[str, Path]) -&gt; None</code>","text":"<p>Save a single figure to file.</p> <p>Parameters:</p> Name Type Description Default <code>path </code> <p>str Name of the file to be written.</p> required Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def save_fig(self, path: Union[str, Path]) -&gt; None:\n    \"\"\"\n    Save a single figure to file.\n\n    Args:\n        path : str\n            Name of the file to be written.\n    \"\"\"\n    plt.show(block=False)\n    self.fig.savefig(path, dpi=300)\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.Plot.set_axes_properties","title":"<code>set_axes_properties(x_label: str, y_label: str, grid: bool, title_txt: str, handles: Optional[List[Any]] = None, labels: Optional[List[str]] = None) -&gt; None</code>","text":"<p>Set the properties of the axes.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes object to set properties for.</p> required <code>x_label</code> <code>str</code> <p>Label for the horizontal chainage axes.</p> required <code>y_label</code> <code>str</code> <p>Label for the vertical axes.</p> required <code>title_txt</code> <code>str</code> <p>Title for the plot.</p> required Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def set_axes_properties(\n    self,\n    x_label: str,\n    y_label: str,\n    grid: bool,\n    title_txt: str,\n    handles: Optional[List[Any]] = None,\n    labels: Optional[List[str]] = None,\n) -&gt; None:\n    \"\"\"\n    Set the properties of the axes.\n\n    Args:\n        ax (Axes): The axes object to set properties for.\n        x_label (str): Label for the horizontal chainage axes.\n        y_label (str): Label for the vertical axes.\n        title_txt (str): Title for the plot.\n    \"\"\"\n    self.ax.set_xlabel(x_label)\n    self.ax.set_ylabel(y_label)\n    self.ax.grid(grid)\n    self.ax.set_title(title_txt)\n    if handles and labels:\n        self.ax.legend(handles, labels, loc=\"upper right\")\n    else:\n        self.ax.legend(loc=\"upper right\")\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.Plot.set_bbox","title":"<code>set_bbox(bbox: Tuple[float, float, float, float]) -&gt; None</code>","text":"<p>Specify the bounding limits of an axes object.</p> <p>Parameters:</p> Name Type Description Default <code>bbox </code> <p>Tuple[float, float, float, float] Tuple containing boundary limits (xmin, ymin, xmax, ymax); unit m.</p> required Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def set_bbox(\n    self,\n    bbox: Tuple[float, float, float, float],\n) -&gt; None:\n    \"\"\"\n    Specify the bounding limits of an axes object.\n\n    Args:\n        bbox : Tuple[float, float, float, float]\n            Tuple containing boundary limits (xmin, ymin, xmax, ymax); unit m.\n    \"\"\"\n    self.ax.set_xlim(xmin=bbox[0] / self.scale, xmax=bbox[2] / self.scale)\n    self.ax.set_ylim(ymin=bbox[1] / self.scale, ymax=bbox[3] / self.scale)\n</code></pre>"},{"location":"api/plotting.html#dfastbe.plotting.Plot.set_size","title":"<code>set_size() -&gt; None</code>","text":"<p>Set the size of a figure.</p> <p>Currently, the size is hardcoded, but functionality may be extended in the future.</p> Source code in <code>src/dfastbe/plotting.py</code> <pre><code>def set_size(self) -&gt; None:\n    \"\"\"\n    Set the size of a figure.\n\n    Currently, the size is hardcoded, but functionality may be extended in the\n    future.\n    \"\"\"\n    # the size of an a3 is (16.5, 11.75)\n    # the size of an a3 is (16.5, 11.75)\n    self.fig.set_size_inches(11.75, 8.25)  # a4\n</code></pre>"},{"location":"api/plotting.html#workflow","title":"Workflow","text":"<p>The typical workflow for using the Plotting module is:</p> <ol> <li>Perform bank line detection or erosion calculation</li> <li>Call the appropriate plotting functions to visualize the results</li> <li>Display the plots or save them to files</li> </ol>"},{"location":"api/plotting.html#usage-example","title":"Usage Example","text":"<pre><code>import matplotlib.pyplot as plt\nfrom dfastbe import plotting as df_plt\nfrom dfastbe.io.config import ConfigFile\nfrom dfastbe.bank_erosion.bank_erosion import Erosion\n\n# Load configuration file\nconfig_file = ConfigFile.read(\"config.cfg\")\n\n# Initialize Erosion object\nerosion = Erosion(config_file)\n\n# Run erosion calculation\nerosion.run()\n\n# Create a plot of the results\nfig, ax = plt.subplots(figsize=(10, 8))\ndf_plt.plot_bank_lines(ax, bank_lines, color='blue', linewidth=1.5)\ndf_plt.plot_erosion_results(ax, erosion_results, cmap='viridis')\nplt.savefig(\"erosion_results.png\")\nplt.show()\n</code></pre> <p>For more details on the specific functions, refer to the API reference below.</p>"},{"location":"api/runner.html","title":"Command Module","text":"<p>The Command module serves as the main entry point for the D-FAST Bank Erosion software, handling command-line arguments and orchestrating the execution of the different operational modes.</p>"},{"location":"api/runner.html#overview","title":"Overview","text":"<p>The Command module provides the interface between the user (via command-line or GUI) and the core functionality of the D-FAST Bank Erosion software. It parses command-line arguments, initializes the appropriate language settings, and launches the requested operational mode (BANKLINES, BANKEROSION, or GUI).</p>"},{"location":"api/runner.html#components","title":"Components","text":"<p>The Command module consists of the following components:</p>"},{"location":"api/runner.html#run-function","title":"Run Function","text":"<p>The <code>run</code> function is the main entry point for the D-FAST Bank Erosion software. It initializes the language settings and launches the requested operational mode.</p>"},{"location":"api/runner.html#dfastbe.runner","title":"<code>dfastbe.runner</code>","text":"<p>Copyright (C) 2025 Stichting Deltares.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation version 2.1.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, see http://www.gnu.org/licenses/.</p> <p>contact: delft3d.support@deltares.nl Stichting Deltares P.O. Box 177 2600 MH Delft, The Netherlands</p> <p>All indications and logos of, and references to, \"Delft3D\" and \"Deltares\" are registered trademarks of Stichting Deltares, and remain the property of Stichting Deltares. All rights reserved.</p> <p>INFORMATION This file is part of D-FAST Bank Erosion: https://github.com/Deltares/D-FAST_Bank_Erosion</p>"},{"location":"api/runner.html#dfastbe.runner.Runner","title":"<code>Runner</code>","text":"Source code in <code>src/dfastbe/runner.py</code> <pre><code>class Runner:\n    def __init__(\n        self,\n        language: str = \"UK\",\n        run_mode: str = \"GUI\",\n        configfile: Path | None = None,\n    ):\n\n        self.language = language.upper()\n        self.run_mode = self._validate_run_mode(run_mode)\n        self.log_data = LogData(LOG_DATA_DIR / f\"messages.{language}.ini\")\n        self.configfile = configfile\n\n    @staticmethod\n    def _validate_run_mode(run_mode: str) -&gt; str:\n        if run_mode not in AVAILABLE_RUN_MODES:\n            raise ValueError(f\"Invalid run mode {run_mode} specified. Should read 'BANKLINES', 'BANKEROSION' or 'GUI'.\")\n        else:\n            run_mode = run_mode.upper()\n        return run_mode\n\n    def run(self) -&gt; None:\n        \"\"\"\n        Initializes the language file and starts the chosen run mode.\n\n        This function loads the appropriate language file and executes one of the\n        available modes: 'BANKLINES', 'BANKEROSION', or 'GUI'. The default configuration\n        file is `dfastbe.cfg`.\n\n        Args:\n            language (str, optional):\n                Display language code. Acceptable values are 'NL' (Dutch) or 'UK' (English).\n                Defaults to 'UK'.\n            run_mode (str, optional):\n                Mode in which the program should run. Available options:\n\n                - 'BANKLINES': Runs the bank lines processing.\n                - 'BANKEROSION': Runs the bank erosion processing.\n                - 'GUI': Launches the graphical user interface.\n\n                Defaults to 'GUI'.\n            configfile (str, optional):\n                Path to the configuration file. Defaults to None.\n\n        Raises:\n            Exception: If an invalid `run_mode` is provided. The valid options are\n                'BANKLINES', 'BANKEROSION', or 'GUI'.\n\n        Example:\n            Running the program with Dutch language and bank erosion mode:\n\n            ```python\n            run(language=\"NL\", run_mode=\"BANKEROSION\", configfile=\"custom_config.cfg\")\n            ```\n\n            Running the program in default mode (GUI) with the English language:\n\n            ```python\n            run()\n            ```\n        \"\"\"\n\n        if self.run_mode == \"GUI\":\n            main(self.configfile)\n        else:\n            config_file = ConfigFile.read(self.configfile)\n\n            if self.run_mode == \"BANKLINES\":\n                bank_lines = BankLines(config_file)\n                bank_lines.detect()\n                bank_lines.plot()\n                bank_lines.save()\n            elif self.run_mode == \"BANKEROSION\":\n                erosion = Erosion(config_file)\n                erosion.run()\n                erosion.plot()\n                erosion.save()\n                self.log_data.log_text(\"end_bankerosion\")\n                timed_logger(\"-- end analysis --\")\n            else:\n                raise ValueError(\n                    f\"Invalid run mode {self.run_mode} specified. Should read 'BANKLINES', 'BANKEROSION' or 'GUI'.\"\n                )\n</code></pre>"},{"location":"api/runner.html#dfastbe.runner.Runner.run","title":"<code>run() -&gt; None</code>","text":"<p>Initializes the language file and starts the chosen run mode.</p> <p>This function loads the appropriate language file and executes one of the available modes: 'BANKLINES', 'BANKEROSION', or 'GUI'. The default configuration file is <code>dfastbe.cfg</code>.</p> <p>Parameters:</p> Name Type Description Default <code>language</code> <code>str</code> <p>Display language code. Acceptable values are 'NL' (Dutch) or 'UK' (English). Defaults to 'UK'.</p> required <code>run_mode</code> <code>str</code> <p>Mode in which the program should run. Available options:</p> <ul> <li>'BANKLINES': Runs the bank lines processing.</li> <li>'BANKEROSION': Runs the bank erosion processing.</li> <li>'GUI': Launches the graphical user interface.</li> </ul> <p>Defaults to 'GUI'.</p> required <code>configfile</code> <code>str</code> <p>Path to the configuration file. Defaults to None.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If an invalid <code>run_mode</code> is provided. The valid options are 'BANKLINES', 'BANKEROSION', or 'GUI'.</p> Example <p>Running the program with Dutch language and bank erosion mode:</p> <pre><code>run(language=\"NL\", run_mode=\"BANKEROSION\", configfile=\"custom_config.cfg\")\n</code></pre> <p>Running the program in default mode (GUI) with the English language:</p> <pre><code>run()\n</code></pre> Source code in <code>src/dfastbe/runner.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Initializes the language file and starts the chosen run mode.\n\n    This function loads the appropriate language file and executes one of the\n    available modes: 'BANKLINES', 'BANKEROSION', or 'GUI'. The default configuration\n    file is `dfastbe.cfg`.\n\n    Args:\n        language (str, optional):\n            Display language code. Acceptable values are 'NL' (Dutch) or 'UK' (English).\n            Defaults to 'UK'.\n        run_mode (str, optional):\n            Mode in which the program should run. Available options:\n\n            - 'BANKLINES': Runs the bank lines processing.\n            - 'BANKEROSION': Runs the bank erosion processing.\n            - 'GUI': Launches the graphical user interface.\n\n            Defaults to 'GUI'.\n        configfile (str, optional):\n            Path to the configuration file. Defaults to None.\n\n    Raises:\n        Exception: If an invalid `run_mode` is provided. The valid options are\n            'BANKLINES', 'BANKEROSION', or 'GUI'.\n\n    Example:\n        Running the program with Dutch language and bank erosion mode:\n\n        ```python\n        run(language=\"NL\", run_mode=\"BANKEROSION\", configfile=\"custom_config.cfg\")\n        ```\n\n        Running the program in default mode (GUI) with the English language:\n\n        ```python\n        run()\n        ```\n    \"\"\"\n\n    if self.run_mode == \"GUI\":\n        main(self.configfile)\n    else:\n        config_file = ConfigFile.read(self.configfile)\n\n        if self.run_mode == \"BANKLINES\":\n            bank_lines = BankLines(config_file)\n            bank_lines.detect()\n            bank_lines.plot()\n            bank_lines.save()\n        elif self.run_mode == \"BANKEROSION\":\n            erosion = Erosion(config_file)\n            erosion.run()\n            erosion.plot()\n            erosion.save()\n            self.log_data.log_text(\"end_bankerosion\")\n            timed_logger(\"-- end analysis --\")\n        else:\n            raise ValueError(\n                f\"Invalid run mode {self.run_mode} specified. Should read 'BANKLINES', 'BANKEROSION' or 'GUI'.\"\n            )\n</code></pre>"},{"location":"api/runner.html#operational-modes","title":"Operational Modes","text":"<p>The D-FAST Bank Erosion software supports three operational modes:</p> <ol> <li>BANKLINES: Detects bank lines from hydrodynamic simulation results</li> <li>BANKEROSION: Calculates bank erosion based on detected bank lines and hydrodynamic data</li> <li>GUI: Provides a graphical user interface for configuring and running the above processes</li> </ol>"},{"location":"api/runner.html#workflow","title":"Workflow","text":"<p>The typical workflow for using the Command module is:</p> <ol> <li>Call the <code>run</code> function with the desired language, run mode, and configuration file</li> <li>The <code>run</code> function initializes the language settings</li> <li>Depending on the run mode, the <code>run</code> function:</li> <li>Launches the GUI</li> <li>Runs bank line detection</li> <li>Runs bank erosion calculation</li> </ol>"},{"location":"api/runner.html#usage-example","title":"Usage Example","text":"<pre><code>from dfastbe.runner import Runner\n\n# Run in GUI mode with English language\nrunner = Runner(language=\"UK\", run_mode=\"GUI\", configfile=\"config.cfg\")\nrunner.run()\n\n# Run bank line detection with Dutch language\nrunner = Runner(language=\"NL\", run_mode=\"BANKLINES\", configfile=\"config.cfg\")\nrunner.run()\n# Run bank erosion calculation with English language\nrunner = Runner(language=\"UK\", run_mode=\"BANKEROSION\", configfile=\"config.cfg\")\nrunner.run()\n</code></pre> <p>For more details on the specific functions, refer to the API reference below.</p>"},{"location":"api/utils.html","title":"Utilities Module","text":"<p>The Utilities module provides general utility functions used across the D-FAST Bank Erosion software. These functions support various operations in the Bank Lines and Bank Erosion modules.</p>"},{"location":"api/utils.html#overview","title":"Overview","text":"<p>The Utilities module contains a collection of helper functions that are used by multiple components of the D-FAST Bank Erosion software. These functions handle common tasks such as geometric operations, data processing, and visualization support.</p>"},{"location":"api/utils.html#components","title":"Components","text":"<p>The Utilities module consists of the following components:</p>"},{"location":"api/utils.html#general-utilities","title":"General Utilities","text":"<p>The general utilities component provides functions for various common tasks, such as:</p> <ul> <li>Geometric operations (e.g., checking if a point is on the right side of a line)</li> <li>Visualization support (e.g., getting zoom extents for plots)</li> <li>Data processing (e.g., interpolation, filtering)</li> </ul>"},{"location":"api/utils.html#dfastbe.utils","title":"<code>dfastbe.utils</code>","text":"<p>Copyright (C) 2025 Stichting Deltares.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation version 2.1.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, see http://www.gnu.org/licenses/.</p> <p>contact: delft3d.support@deltares.nl Stichting Deltares P.O. Box 177 2600 MH Delft, The Netherlands</p> <p>All indications and logos of, and references to, \"Delft3D\" and \"Deltares\" are registered trademarks of Stichting Deltares, and remain the property of Stichting Deltares. All rights reserved.</p> <p>INFORMATION This file is part of D-FAST Bank Erosion: https://github.com/Deltares/D-FAST_Bank_Erosion</p>"},{"location":"api/utils.html#dfastbe.utils.get_zoom_extends","title":"<code>get_zoom_extends(km_min: float, km_max: float, zoom_step_km: float, bank_crds: List[np.ndarray], bank_km: List[np.ndarray]) -&gt; tuple[list[tuple[float, float]], list[tuple[float, float, float, float]]]</code>","text":"<p>Zoom.</p> <p>Parameters:</p> Name Type Description Default <code>km_min</code> <code>float</code> <p>Minimum value for the chainage range of interest.</p> required <code>km_max</code> <code>float</code> <p>Maximum value for the chainage range of interest.</p> required <code>zoom_step_km</code> <code>float</code> <p>Preferred chainage length of zoom box.</p> required <code>bank_crds</code> <code>List[ndarray]</code> <p>List of N x 2 np arrays of coordinates per bank.</p> required <code>bank_km</code> <code>List[ndarray]</code> <p>List of N np arrays of chainage values per bank.</p> required <p>Returns:</p> Name Type Description <code>station_zoom</code> <code>List[Tuple[float, float]]</code> <p>Zoom ranges for plots with chainage along x-axis.</p> <code>coords_zoom</code> <code>List[Tuple[float, float, float, float]]</code> <p>Zoom ranges for xy-plots.</p> Source code in <code>src/dfastbe/utils.py</code> <pre><code>def get_zoom_extends(\n    km_min: float,\n    km_max: float,\n    zoom_step_km: float,\n    bank_crds: List[np.ndarray],\n    bank_km: List[np.ndarray],\n) -&gt; tuple[list[tuple[float, float]], list[tuple[float, float, float, float]]]:\n    \"\"\"Zoom.\n\n    Args:\n        km_min (float):\n            Minimum value for the chainage range of interest.\n        km_max (float):\n            Maximum value for the chainage range of interest.\n        zoom_step_km (float):\n            Preferred chainage length of zoom box.\n        bank_crds (List[np.ndarray]):\n            List of N x 2 np arrays of coordinates per bank.\n        bank_km (List[np.ndarray]):\n            List of N np arrays of chainage values per bank.\n\n    Returns:\n        station_zoom (List[Tuple[float, float]]):\n            Zoom ranges for plots with chainage along x-axis.\n        coords_zoom (List[Tuple[float, float, float, float]]):\n            Zoom ranges for xy-plots.\n    \"\"\"\n    from dfastbe.bank_erosion.utils import get_km_bins\n\n    zoom_km_bin = (km_min, km_max, zoom_step_km)\n    zoom_km_bnd = get_km_bins(zoom_km_bin, station_type=\"all\", adjust=True)\n    eps = 0.1 * zoom_step_km\n\n    station_zoom: List[Tuple[float, float]] = []\n    coords_zoom: List[Tuple[float, float, float, float]] = []\n    inf = float('inf')\n    for i in range(len(zoom_km_bnd) - 1):\n        km_min = zoom_km_bnd[i] - eps\n        km_max = zoom_km_bnd[i + 1] + eps\n        station_zoom.append((km_min, km_max))\n\n        x_min = inf\n        x_max = -inf\n        y_min = inf\n        y_max = -inf\n        for ib in range(len(bank_km)):\n            ind = (bank_km[ib] &gt;= km_min) &amp; (bank_km[ib] &lt;= km_max)\n            range_crds = bank_crds[ib][ind, :]\n            x = range_crds[:, 0]\n            y = range_crds[:, 1]\n            if len(x) &gt; 0:\n                x_min = min(x_min, min(x))\n                x_max = max(x_max, max(x))\n                y_min = min(y_min, min(y))\n                y_max = max(y_max, max(y))\n        coords_zoom.append((x_min, x_max, y_min, y_max))\n\n    return station_zoom, coords_zoom\n</code></pre>"},{"location":"api/utils.html#dfastbe.utils.on_right_side","title":"<code>on_right_side(line_xy: np.ndarray, ref_xy: np.ndarray) -&gt; bool</code>","text":"<p>Determine whether line_xy is to the left or right of ref_xy.</p> <p>Left and right are relative to the path along ref_xy from the first to the last node. It is assumed that line_xy can be uniquely identified as on the left or right side of ref_xy, i.e., the lines may not cross each other or themselves. Also, line_xy should be alongside ref_xy and not \"before\" or \"after\" ref_xy. The typical use case is to relate a bank line line_xy to a center line ref_xy.</p> <p>Parameters:</p> Name Type Description Default <code>line_xy </code> <p>np.ndarray Array containing the x,y coordinates of a line.</p> required <code>ref_xy </code> <p>np.ndarray Array containing the x,y,chainage data.</p> required <p>Returns:</p> Name Type Description <code>right_side</code> <code>bool</code> <p>bool Flag indicating whether the line is on the right side.</p> Source code in <code>src/dfastbe/utils.py</code> <pre><code>def on_right_side(line_xy: np.ndarray, ref_xy: np.ndarray) -&gt; bool:\n    \"\"\"\n    Determine whether line_xy is to the left or right of ref_xy.\n\n    Left and right are relative to the path along ref_xy from the first to the\n    last node. It is assumed that line_xy can be uniquely identified as on the\n    left or right side of ref_xy, i.e., the lines may not cross each other or\n    themselves. Also, line_xy should be alongside ref_xy and not \"before\" or\n    \"after\" ref_xy. The typical use case is to relate a bank line line_xy to a\n    center line ref_xy.\n\n    Args:\n        line_xy : np.ndarray\n            Array containing the x,y coordinates of a line.\n        ref_xy : np.ndarray\n            Array containing the x,y,chainage data.\n\n    Returns:\n        right_side : bool\n            Flag indicating whether the line is on the right side.\n    \"\"\"\n\n    # determine the reference point based on the line with the fewest points\n    ref_npnt = ref_xy.shape[0]\n    npnt = line_xy.shape[0]\n    if ref_npnt &lt; npnt:\n        # determine the mid-point p0 of ref_xy\n        if ref_npnt == 2:\n            imin = 0\n            imind = 0\n            iminu = 1\n            p0 = (ref_xy[0] + ref_xy[1]) / 2\n        else:\n            imin = int(ref_npnt / 2)\n            imind = imin - 1\n            iminu = imin + 1\n            p0 = ref_xy[imin]\n\n        # find the node on line_xy closest to p0\n        hpnt = np.argmin(((p0 - line_xy) ** 2).sum(axis=1))\n        hpxy = line_xy[hpnt]\n    else:\n        # determine the mid-point hpxy of line_xy\n        hpnt = int(npnt / 2)\n        hpxy = line_xy[hpnt]\n\n        # find the node on ref_xy closest to hpxy\n        imin = np.argmin(((hpxy - ref_xy) ** 2).sum(axis=1))\n        imind = imin - 1\n        iminu = imin + 1\n        p0 = ref_xy[imin]\n\n    # direction to the midpoint of line_xy\n    theta = math.atan2(hpxy[1] - p0[1], hpxy[0] - p0[0])\n\n    # direction from which ref_xy comes\n    if ref_xy.shape[0] == 1:\n        raise Exception(\"One point is not a reference line.\")\n    elif imin &gt; 0:\n        phi1 = math.atan2(ref_xy[imind, 1] - p0[1], ref_xy[imind, 0] - p0[0])\n        # direction to which ref_xy goes\n        if imin &lt; ref_xy.shape[0] - 1:\n            phi2 = math.atan2(ref_xy[iminu, 1] - p0[1], ref_xy[iminu, 0] - p0[0])\n        else:\n            phi2 = -phi1\n    else:\n        # direction to which ref_xy goes\n        phi2 = math.atan2(ref_xy[iminu, 1] - p0[1], ref_xy[iminu, 0] - p0[0])\n        phi1 = -phi2\n\n    # adjust the directions of ref_xy such that both are larger than the\n    # angle of the direction towards the midpoint of line_xy\n    if phi1 &lt; theta:\n        phi1 = phi1 + 2 * math.pi\n    if phi2 &lt; theta:\n        phi2 = phi2 + 2 * math.pi\n\n    # theta points to the right relative to a line coming from phi1 and going\n    # to phi2 if we encounter the to direction phi2 before the from direction\n    # phi1 when searching from theta in counter clockwise direction.\n    right_side = phi2 &lt; phi1\n\n    return right_side\n</code></pre>"},{"location":"api/utils.html#usage-example","title":"Usage Example","text":"<pre><code>from dfastbe.utils import get_zoom_extends, on_right_side\n\n# Check if a point is on the right side of a line\nis_on_right = on_right_side(line_start, line_end, point)\n\n# Get zoom extents for plotting\nx_min, x_max, y_min, y_max = get_zoom_extends(x, y, margin=0.1)\n</code></pre> <p>For more details on the specific functions, refer to the API reference below.</p>"},{"location":"api/bank_erosion/bank_erosion.html","title":"Bank Erosion Module","text":"<p>The Bank Erosion module is responsible for calculating bank erosion based on hydrodynamic data and detected bank lines. It is one of the core components of the D-FAST Bank Erosion software.</p>"},{"location":"api/bank_erosion/bank_erosion.html#overview","title":"Overview","text":"<p>The Bank Erosion module calculates the amount of bank material that will be eroded during the first year and until equilibrium, based on hydrodynamic simulation results and detected bank lines. It takes into account various factors such as river geometry, discharge levels, and shipping parameters.</p> <pre><code>classDiagram\n    %% Main Classes\n\n    %% Generic Base Class\n    class BaseBank~T~ {\n        +T left\n        +T right\n        +Optional[int] id\n        +get_bank(int)\n        +from_column_arrays(Dict, Type, Tuple)\n        +__iter__()\n    }\n    class Erosion {\n        -ConfigFile config_file\n        -bool gui\n        -Path bank_dir\n        -Path output_dir\n        -bool debug\n        -dict plot_flags\n        -ErosionCalculator erosion_calculator\n        +__init__(ConfigFile, bool)\n        +run()\n        -_process_river_axis_by_center_line()\n        -_get_fairway_data(LineGeometry, MeshData)\n        +calculate_fairway_bank_line_distance(BankData, FairwayData, ErosionSimulationData)\n        -_prepare_initial_conditions(ConfigFile, List, FairwayData)\n        -_process_discharge_levels(array, tuple, ConfigFile, ErosionInputs, BankData, FairwayData)\n        -_postprocess_erosion_results(tuple, array, BankData, ErosionResults)\n        +compute_erosion_per_level(int, BankData, ErosionSimulationData, FairwayData, SingleLevelParameters, ErosionInputs, tuple, int, array)\n        -_write_bankline_shapefiles(list, list, ConfigFile)\n        -_write_volume_outputs(ErosionResults, array)\n        -_generate_plots(array, ErosionSimulationData, list, array, float, ErosionInputs, WaterLevelData, MeshData, BankData, ErosionResults)\n    }\n\n    class ErosionCalculator {\n        +comp_erosion_eq(array, array, array, SingleParameters, array, array, SingleErosion)\n        +compute_bank_erosion_dynamics(SingleCalculation, array, array, array, array, SingleParameters, float, array, SingleErosion)\n        +comp_hw_ship_at_bank(array, array, array, array, array, array, array)\n    }\n\n    class ConfigFile {\n        -ConfigParser config\n        -str path\n        +__init__(ConfigParser, Path)\n        +read(Path)\n        +write(str)\n        +make_paths_absolute()\n        +get_str(str, str, str)\n        +get_bool(str, str, bool)\n        +get_float(str, str, float, bool)\n        +get_int(str, str, int, bool)\n        +get_sim_file(str, str)\n        +get_start_end_stations()\n        +get_search_lines()\n        +read_bank_lines(str)\n        +get_parameter(str, str, List, Any, str, bool, List, bool)\n        +get_bank_search_distances(int)\n        +get_range(str, str)\n        +get_river_center_line()\n        +resolve(str)\n        +relative_to(str)\n        +get_plotting_flags(Path)\n        +get_output_dir(str)\n    }\n\n    %% Data Models - Bank Erosion\n    class ErosionRiverData {\n        -ConfigFile config_file\n        -LineString river_center_line\n        -Tuple station_bounds\n        +__init__(ConfigFile)\n        +simulation_data()\n        -_get_bank_output_dir()\n        -_get_bank_line_dir()\n        -_read_river_axis()\n    }\n\n    class ErosionSimulationData {\n        +compute_mesh_topology()\n        +apply_masked_indexing(array, array)\n        +calculate_bank_velocity(SingleBank, array)\n        +calculate_bank_height(SingleBank, array)\n    }\n\n    class BankData {\n        +List banks\n        +from_column_arrays(dict, Type, GeoDataFrame, int, Tuple)\n        +bank_line_coords()\n        +is_right_bank()\n        +bank_chainage_midpoints()\n        +num_stations_per_bank()\n    }\n\n    class SingleBank {\n        +LineString bank_line\n        +array face_indices\n        +array chainage\n        +bool is_right\n        +__post_init__()\n        -_segment_length()\n        -_dx()\n        -_dy()\n        +get_mid_points(bool, str)\n    }\n\n    class FairwayData {\n        +LineString fairway_axis\n        +Polygon fairway_polygon\n        +array fairway_initial_water_levels\n        +array fairway_velocities\n        +array fairway_chezy_coefficients\n    }\n\n    class ErosionInputs {\n        +List banks\n        +dict shipping_data\n        +from_column_arrays(dict, Type, Dict, array, Tuple)\n        +bank_protection_level()\n        +tauc()\n    }\n\n    class SingleErosion {\n        +array wave_fairway_distance_0\n        +array wave_fairway_distance_1\n        +array bank_protection_level\n        +array tauc\n        +array bank_type\n    }\n\n    class ErosionResults {\n        +int erosion_time\n        +List velocity\n        +List bank_height\n        +List water_level\n        +List chezy\n        +List vol_per_discharge\n        +List ship_wave_max\n        +List ship_wave_min\n        +List line_size\n        +List flow_erosion_dist\n        +List ship_erosion_dist\n        +List total_erosion_dist\n        +List total_eroded_vol\n        +List eq_erosion_dist\n        +List eq_eroded_vol\n        +array avg_erosion_rate\n        +array eq_eroded_vol_per_km\n        +array total_eroded_vol_per_km\n    }\n\n    class WaterLevelData {\n        +List water_levels\n        +array hfw_max\n    }\n\n    class MeshData {\n        +array x_node\n        +array y_node\n        +array n_nodes\n        +array face_node\n        +array face_x\n        +array face_y\n        +array face_area\n        +array face_nodes_count\n        +array face_nodes_indices\n    }\n\n    class DischargeLevels {\n        +List levels\n        +__init__(List)\n        +__getitem__(int)\n        +__len__()\n        +append(SingleDischargeLevel)\n        +get_max_hfw_level()\n        +total_erosion_volume()\n        +__iter__()\n        +accumulate(str, str)\n        -_accumulate_attribute_side(str, str)\n        -_get_attr_both_sides_level(str, object)\n        +get_attr_level(str)\n        +get_water_level_data(array)\n    }\n\n    class SingleDischargeLevel {\n        +List banks\n        +from_column_arrays(dict, Type, float, Tuple)\n    }\n\n    class SingleCalculation {\n        +array water_level\n        +array velocity\n        +array chezy\n        +array flow_erosion_dist\n        +array ship_erosion_dist\n        +array total_erosion_dist\n        +array total_eroded_vol\n        +array eq_erosion_dist\n        +array eq_eroded_vol\n    }\n\n    class SingleLevelParameters {\n        +List banks\n    }\n\n    class SingleParameters {\n        +float discharge\n        +float probability\n        +dict ship_parameters\n    }\n\n    %% Data Models - IO\n    class LineGeometry {\n        +LineString line\n        +dict data\n        +__init__(LineString, Tuple, str)\n        +as_array()\n        +add_data(Dict)\n        +to_file(str, Dict)\n        +mask(LineString, Tuple)\n        -_find_mask_index(float, array)\n        -_handle_bound(int, float, bool, array)\n        -_interpolate_point(int, float, array)\n        +intersect_with_line(array)\n    }\n\n    class BaseSimulationData {\n        +array x_node\n        +array y_node\n        +array n_nodes\n        +array face_node\n        +array bed_elevation_location\n        +array bed_elevation_values\n        +array water_level_face\n        +array water_depth_face\n        +array velocity_x_face\n        +array velocity_y_face\n        +array chezy_face\n        +float dry_wet_threshold\n        +__init__(array, array, array, array, array, array, array, array, array, array, array, float)\n        +read(str, str)\n        +clip(LineString, float)\n    }\n\n    class BaseRiverData {\n        -ConfigFile config_file\n        -LineString river_center_line\n        -Tuple station_bounds\n        +__init__(ConfigFile)\n        +get_bbox(array, float)\n        +get_erosion_sim_data(int)\n    }\n\n    %% Relationships\n    Erosion --&gt; ConfigFile : uses\n    Erosion --&gt; ErosionRiverData : uses\n    Erosion --&gt; ErosionSimulationData : uses\n    Erosion --&gt; BankData : uses\n    Erosion --&gt; FairwayData : uses\n    Erosion --&gt; ErosionInputs : uses\n    Erosion --&gt; ErosionResults : uses\n    Erosion --&gt; DischargeLevels : uses\n    Erosion --&gt; WaterLevelData : uses\n    Erosion --&gt; MeshData : uses\n    Erosion --&gt; SingleCalculation : uses\n    Erosion --&gt; SingleLevelParameters : uses\n    Erosion --&gt; SingleDischargeLevel : uses\n    Erosion --&gt; SingleParameters : uses\n    Erosion --&gt; SingleErosion : uses\n    Erosion --&gt; Debugger : uses\n    Erosion --&gt; BankLinesProcessor : uses\n    Erosion --&gt; LineGeometry : uses\n    Erosion --&gt; ErosionCalculator : uses\n\n    ErosionRiverData --|&gt; BaseRiverData : inherits\n    ErosionRiverData --&gt; ConfigFile : uses\n\n    ErosionSimulationData --|&gt; BaseSimulationData : inherits\n    ErosionSimulationData --&gt; MeshData : uses\n    ErosionSimulationData --&gt; SingleBank : uses\n\n    %% Inheritance relationships\n    BankData --|&gt; BaseBank : inherits\n    BankData --|&gt; BaseBank : inherits\n    ErosionInputs --|&gt; BaseBank : inherits\n    SingleDischargeLevel --|&gt; BaseBank : inherits\n    SingleLevelParameters --|&gt; BaseBank : inherits\n\n    %% Containment relationships\n    BankData --&gt; SingleBank : contains\n    ErosionInputs --&gt; SingleErosion : contains\n    SingleDischargeLevel --&gt; SingleCalculation : contains\n    SingleLevelParameters --&gt; SingleParameters : contains\n    DischargeLevels --&gt; SingleDischargeLevel : contains\n\n    BaseRiverData --&gt; ConfigFile : uses\n    BaseRiverData --&gt; LineGeometry : uses</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#components","title":"Components","text":"<p>The Bank Erosion module consists of the following components:</p>"},{"location":"api/bank_erosion/bank_erosion.html#main-classes","title":"Main Classes","text":""},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.bank_erosion","title":"<code>dfastbe.bank_erosion.bank_erosion</code>","text":"<p>Copyright (C) 2025 Stichting Deltares.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation version 2.1.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, see http://www.gnu.org/licenses/.</p> <p>contact: delft3d.support@deltares.nl Stichting Deltares P.O. Box 177 2600 MH Delft, The Netherlands</p> <p>All indications and logos of, and references to, \"Delft3D\" and \"Deltares\" are registered trademarks of Stichting Deltares, and remain the property of Stichting Deltares. All rights reserved.</p> <p>INFORMATION This file is part of D-FAST Bank Erosion: https://github.com/Deltares/D-FAST_Bank_Erosion</p>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.bank_erosion.Erosion","title":"<code>Erosion</code>","text":"<p>               Bases: <code>BaseCalculator</code></p> <p>Class to handle the bank erosion calculations.</p> Source code in <code>src/dfastbe/bank_erosion/bank_erosion.py</code> <pre><code>class Erosion(BaseCalculator):\n    \"\"\"Class to handle the bank erosion calculations.\"\"\"\n\n    def __init__(self, config_file: ConfigFile, gui: bool = False):\n        \"\"\"Initialize the Erosion class.\"\"\"\n        super().__init__(config_file, gui)\n\n        self.river_data = ErosionRiverData(config_file)\n        self.simulation_data = self.river_data.simulation_data()\n        self.sim_files, self.p_discharge = self.river_data.get_erosion_sim_data(\n            self.river_data.num_discharge_levels\n        )\n        self.debugger = Debugger(config_file.crs, self.river_data.output_dir)\n        self.erosion_calculator = ErosionCalculator()\n\n    def calculate_fairway_bank_line_distance(\n        self,\n        bank_data: BankData,\n        fairway_data: FairwayData,\n        simulation_data: ErosionSimulationData,\n    ):\n        \"\"\"Map bank data to fairway data.\n\n        Args:\n            bank_data (BankData):\n            fairway_data (FairwayData):\n            simulation_data (ErosionSimulationData):\n\n        Returns:\n            FairwayData:\n                The method updates the following attributes in the `bank_data` instance\n                    - fairway_face_indices\n                    - fairway_distances\n            BankData:\n                the following attributes in the `fairway_data` instance\n                    - fairway_initial_water_levels\n        \"\"\"\n        # distance fairway-bankline (bank-fairway)\n        LogData().log_text(\"bank_distance_fairway\")\n\n        num_fairway_face_ind = len(fairway_data.fairway_face_indices)\n\n        for bank_i, single_bank in enumerate(bank_data):\n            bank_coords = single_bank.bank_line_coords\n            coords_mid = (bank_coords[:-1] + bank_coords[1:]) / 2\n            bank_fairway_dist = np.zeros(len(coords_mid))\n            bp_fw_face_idx = np.zeros(len(coords_mid), dtype=int)\n\n            for ind, coord_i in enumerate(coords_mid):\n                # find closest fairway support node\n                closest_ind = np.argmin(\n                    ((coord_i - fairway_data.intersection_coords) ** 2).sum(axis=1)\n                )\n                fairway_coord = fairway_data.intersection_coords[closest_ind]\n                fairway_bank_distance = ((coord_i - fairway_coord) ** 2).sum() ** 0.5\n                # If fairway support node is also the closest projected fairway point, then it likely\n                # that that point is one of the original support points (a corner) of the fairway path\n                # and located inside a grid cell. The segments before and after that point will then\n                # both be located inside that same grid cell, so let's pick the segment before the point.\n                # If the point happens to coincide with a grid edge and the two segments are located\n                # in different grid cells, then we could either simply choose one or add complexity to\n                # average the values of the two grid cells. Let's go for the simplest approach ...\n                iseg = max(closest_ind - 1, 0)\n                if closest_ind &gt; 0:\n                    alpha = calculate_alpha(\n                        fairway_data.intersection_coords,\n                        closest_ind,\n                        closest_ind - 1,\n                        coord_i,\n                    )\n                    if 0 &lt; alpha &lt; 1:\n                        fwp1 = fairway_data.intersection_coords[\n                            closest_ind - 1\n                        ] + alpha * (\n                            fairway_data.intersection_coords[closest_ind]\n                            - fairway_data.intersection_coords[closest_ind - 1]\n                        )\n                        d1 = ((coord_i - fwp1) ** 2).sum() ** 0.5\n                        if d1 &lt; fairway_bank_distance:\n                            fairway_bank_distance = d1\n                            # projected point located on segment before, which corresponds to initial choice: iseg = ifw - 1\n                if closest_ind &lt; num_fairway_face_ind:\n                    alpha = calculate_alpha(\n                        fairway_data.intersection_coords,\n                        closest_ind + 1,\n                        closest_ind,\n                        coord_i,\n                    )\n                    if 0 &lt; alpha &lt; 1:\n                        fwp1 = fairway_data.intersection_coords[closest_ind] + alpha * (\n                            fairway_data.intersection_coords[closest_ind + 1]\n                            - fairway_data.intersection_coords[closest_ind]\n                        )\n                        d1 = ((coord_i - fwp1) ** 2).sum() ** 0.5\n                        if d1 &lt; fairway_bank_distance:\n                            fairway_bank_distance = d1\n                            iseg = closest_ind\n\n                bp_fw_face_idx[ind] = fairway_data.fairway_face_indices[iseg]\n                bank_fairway_dist[ind] = fairway_bank_distance\n\n            if self.river_data.debug:\n                line_geom = LineGeometry(coords_mid, crs=self.config_file.crs)\n                line_geom.to_file(\n                    file_name=f\"{self.river_data.output_dir}/bank_{bank_i + 1}_chainage_and_fairway_face_idx.shp\",\n                    data={\n                        \"chainage\": single_bank.bank_chainage_midpoints,\n                        \"iface_fw\": bp_fw_face_idx[bank_i],\n                    },\n                )\n\n            single_bank.fairway_face_indices = bp_fw_face_idx\n            single_bank.fairway_distances = bank_fairway_dist\n\n        # water level at fairway\n        water_level_fairway_ref = []\n        for single_bank in bank_data:\n            ii = single_bank.fairway_face_indices\n            water_level_fairway_ref.append(simulation_data.water_level_face[ii])\n        fairway_data.fairway_initial_water_levels = water_level_fairway_ref\n\n    def _prepare_initial_conditions(\n        self,\n        num_stations_per_bank: List[int],\n        fairway_data: FairwayData,\n    ) -&gt; ErosionInputs:\n        # wave reduction s0, s1\n        parameters = self._get_parameters(num_stations_per_bank)\n        wave_fairway_distance_0 = parameters[\"Wave0\"]\n        wave_fairway_distance_1 = parameters[\"Wave1\"]\n\n        # save 1_banklines\n        # read vship, nship, nwave, draught (tship), shiptype ... independent of level number\n        ships_parameters = ShipsParameters.get_ship_data(\n            num_stations_per_bank, self.config_file\n        )\n\n        # read classes flag (yes: banktype = taucp, no: banktype = tauc) and banktype (taucp: 0-4 ... or ... tauc = critical shear value)\n        classes = self.config_file.get_bool(\"Erosion\", \"Classes\")\n        if classes:\n            bank_type = parameters[\"BankType\"]\n            tauc = []\n            for bank in bank_type:\n                tauc.append(ErosionInputs.taucls[bank])\n        else:\n            tauc = parameters[\"BankType\"]\n            thr = (ErosionInputs.taucls[:-1] + ErosionInputs.taucls[1:]) / 2\n            bank_type = [None] * len(thr)\n            for ib, shear_stress in enumerate(tauc):\n                bt = np.zeros(shear_stress.size)\n                for thr_i in thr:\n                    bt[shear_stress &lt; thr_i] += 1\n                bank_type[ib] = bt\n\n        dike_height_default = -1000\n        dike_height = parameters[\"ProtectionLevel\"]\n        # if dike_height undefined, set dike_height equal to water_level_fairway_ref - 1\n        for ib, one_zss in enumerate(dike_height):\n            mask = one_zss == dike_height_default\n            one_zss[mask] = fairway_data.fairway_initial_water_levels[ib][mask] - 1\n\n        data = {\n            'wave_fairway_distance_0': wave_fairway_distance_0,\n            'wave_fairway_distance_1': wave_fairway_distance_1,\n            'bank_protection_level': dike_height,\n            'tauc': tauc,\n        }\n        return ErosionInputs.from_column_arrays(\n            data, SingleErosion, shipping_data=ships_parameters, bank_type=bank_type\n        )\n\n    def _get_erosion_input_parameters(self) -&gt; List[Parameters]:\n        return [\n            Parameters(name=\"Wave0\", default=200, valid=True, onefile=True, positive=None, ext=None),\n            Parameters(name=\"Wave1\", default=150, valid=True, onefile=True, positive=None, ext=None),\n            Parameters(name=\"BankType\", default=0, valid=None, onefile=None, positive=None, ext=\".btp\"),\n            Parameters(name=\"ProtectionLevel\", default=-1000, valid=None, onefile=None, positive=None, ext=\".bpl\"),\n        ]\n\n    def _get_parameters(self, num_stations_per_bank) -&gt; Dict[str, Any]:\n        \"\"\"Get a parameter from the configuration file.\"\"\"\n        data = {}\n        for parameter in self._get_erosion_input_parameters():\n            data[parameter.name] = self.config_file.get_parameter(\n                \"Erosion\",\n                parameter.name,\n                num_stations_per_bank,\n                default=parameter.default,\n                positive=parameter.positive,\n                onefile=parameter.onefile,\n                ext=parameter.ext,\n            )\n        return data\n\n    def _calculate_bank_height(\n        self, bank_data: BankData, simulation_data: ErosionSimulationData\n    ) -&gt; BankData:\n        # bank height = maximum bed elevation per cell\n        for bank_i in bank_data:\n            bank_i.height = simulation_data.calculate_bank_height(\n                bank_i, self.river_data.zb_dx\n            )\n\n        return bank_data\n\n    def _process_discharge_levels(\n        self,\n        km_mid,\n        km_bin,\n        erosion_inputs: ErosionInputs,\n        bank_data: BankData,\n        fairway_data: FairwayData,\n    ) -&gt; Tuple[WaterLevelData, ErosionResults]:\n\n        num_levels = self.river_data.num_discharge_levels\n        num_km = len(km_mid)\n\n        # initialize arrays for erosion loop over all discharges\n        discharge_levels = []\n\n        LogData().log_text(\"total_time\", data={\"t\": self.river_data.erosion_time})\n\n        for level_i in range(num_levels):\n            LogData().log_text(\n                \"discharge_header\",\n                data={\n                    \"i\": level_i + 1,\n                    \"p\": self.p_discharge[level_i],\n                    \"t\": self.p_discharge[level_i] * self.river_data.erosion_time,\n                },\n            )\n\n            LogData().log_text(\"read_q_params\", indent=\"  \")\n            # 1) read level-specific parameters\n            # read ship_velocity, num_ship, nwave, draught, ship_type, slope, reed, fairway_depth, ... (level specific values)\n            level_parameters = erosion_inputs.shipping_data.read_discharge_parameters(\n                level_i, bank_data.num_stations_per_bank\n            )\n\n            # 2) load FM result\n            LogData().log_text(\"-\", indent=\"  \")\n            LogData().log_text(\n                \"read_simdata\", data={\"file\": self.sim_files[level_i]}, indent=\"  \"\n            )\n            simulation_data = ErosionSimulationData.read(\n                self.sim_files[level_i], indent=\"  \"\n            )\n            LogData().log_text(\"bank_erosion\", indent=\"  \")\n\n            if level_i == 0:\n                bank_data = self._calculate_bank_height(bank_data, simulation_data)\n\n            single_level, dvol_bank = self.compute_erosion_per_level(\n                level_i,\n                bank_data,\n                simulation_data,\n                fairway_data,\n                level_parameters,\n                erosion_inputs,\n                km_bin,\n                num_km,\n            )\n\n            discharge_levels.append(single_level)\n\n            error_vol_file = self.config_file.get_str(\n                \"Erosion\", f\"EroVol{level_i + 1}\", default=f\"erovolQ{level_i + 1}.evo\"\n            )\n            LogData().log_text(\"save_error_vol\", data={\"file\": error_vol_file}, indent=\"  \")\n            write_km_eroded_volumes(\n                km_mid, dvol_bank, f\"{self.river_data.output_dir}/{error_vol_file}\"\n            )\n\n        # shape is (num_levels, 2, (num_stations_per_bank))\n        # if num_levels = 13 and the num_stations_per_bank = [10, 15]\n        # then shape = (13, 2, (10, 15)) list of 13 elements, each element is a list of 2 elements\n        # first an array of 10 elements, and the second is array of 15 elements\n        discharge_levels = DischargeLevels(discharge_levels)\n        flow_erosion_dist = discharge_levels.accumulate(\"erosion_distance_flow\")\n        ship_erosion_dist = discharge_levels.accumulate(\"erosion_distance_shipping\")\n        total_erosion_dist = discharge_levels.accumulate(\"erosion_distance_tot\")\n        total_eroded_vol = discharge_levels.accumulate(\"erosion_volume_tot\")\n\n        erosion_results = ErosionResults(\n            erosion_time=self.river_data.erosion_time,\n            flow_erosion_dist=flow_erosion_dist,\n            ship_erosion_dist=ship_erosion_dist,\n            total_erosion_dist=total_erosion_dist,\n            total_eroded_vol=total_eroded_vol,\n            eq_erosion_dist=discharge_levels._get_attr_both_sides_level(\n                \"erosion_distance_eq\", num_levels - 1\n            ),\n            eq_eroded_vol=discharge_levels._get_attr_both_sides_level(\n                \"erosion_volume_eq\", num_levels - 1\n            ),\n        )\n        water_level_data = discharge_levels.get_water_level_data()\n\n        bank_data.left.bank_line_size, bank_data.right.bank_line_size = (\n            bank_data.left.segment_length,\n            bank_data.right.segment_length,\n        )\n\n        return water_level_data, erosion_results\n\n    def _postprocess_erosion_results(\n        self,\n        km_bin: Tuple[float, float, float],\n        km_mid,\n        bank_data: BankData,\n        erosion_results: ErosionResults,\n    ) -&gt; Tuple[List[LineString], List[LineString], List[LineString]]:\n        \"\"\"Postprocess the erosion results to get the new bank lines and volumes.\"\"\"\n        LogData().log_text(\"=\")\n        avg_erosion_rate = np.zeros(bank_data.n_bank_lines)\n        dn_max = np.zeros(bank_data.n_bank_lines)\n        d_nav_flow = np.zeros(bank_data.n_bank_lines)\n        d_nav_ship = np.zeros(bank_data.n_bank_lines)\n        d_nav_eq = np.zeros(bank_data.n_bank_lines)\n        dn_max_eq = np.zeros(bank_data.n_bank_lines)\n        eq_eroded_vol_per_km = np.zeros((len(km_mid), bank_data.n_bank_lines))\n        total_eroded_vol_per_km = np.zeros((len(km_mid), bank_data.n_bank_lines))\n        xy_line_new_list = []\n        bankline_new_list = []\n        xy_line_eq_list = []\n        bankline_eq_list = []\n        for ib, single_bank in enumerate(bank_data):\n            bank_coords = single_bank.bank_line_coords\n            avg_erosion_rate[ib] = (\n                erosion_results.total_erosion_dist[ib] * single_bank.bank_line_size\n            ).sum() / single_bank.bank_line_size.sum()\n            dn_max[ib] = erosion_results.total_erosion_dist[ib].max()\n            d_nav_flow[ib] = (\n                erosion_results.flow_erosion_dist[ib] * single_bank.bank_line_size\n            ).sum() / single_bank.bank_line_size.sum()\n            d_nav_ship[ib] = (\n                erosion_results.ship_erosion_dist[ib] * single_bank.bank_line_size\n            ).sum() / single_bank.bank_line_size.sum()\n            d_nav_eq[ib] = (\n                erosion_results.eq_erosion_dist[ib] * single_bank.bank_line_size\n            ).sum() / single_bank.bank_line_size.sum()\n            dn_max_eq[ib] = erosion_results.eq_erosion_dist[ib].max()\n            LogData().log_text(\"bank_dnav\", data={\"ib\": ib + 1, \"v\": avg_erosion_rate[ib]})\n            LogData().log_text(\"bank_dnavflow\", data={\"v\": d_nav_flow[ib]})\n            LogData().log_text(\"bank_dnavship\", data={\"v\": d_nav_ship[ib]})\n            LogData().log_text(\"bank_dnmax\", data={\"v\": dn_max[ib]})\n            LogData().log_text(\"bank_dnaveq\", data={\"v\": d_nav_eq[ib]})\n            LogData().log_text(\"bank_dnmaxeq\", data={\"v\": dn_max_eq[ib]})\n\n            xy_line_new = move_line(\n                bank_coords,\n                erosion_results.total_erosion_dist[ib],\n                single_bank.is_right_bank,\n            )\n            xy_line_new_list.append(xy_line_new)\n            bankline_new_list.append(LineString(xy_line_new))\n\n            xy_line_eq = move_line(\n                bank_coords,\n                erosion_results.eq_erosion_dist[ib],\n                single_bank.is_right_bank,\n            )\n            xy_line_eq_list.append(xy_line_eq)\n            bankline_eq_list.append(LineString(xy_line_eq))\n\n            dvol_eq = get_km_eroded_volume(\n                single_bank.bank_chainage_midpoints,\n                erosion_results.eq_eroded_vol[ib],\n                km_bin,\n            )\n            eq_eroded_vol_per_km[:, ib] = dvol_eq\n            dvol_tot = get_km_eroded_volume(\n                single_bank.bank_chainage_midpoints,\n                erosion_results.total_eroded_vol[ib],\n                km_bin,\n            )\n            total_eroded_vol_per_km[:, ib] = dvol_tot\n            if ib &lt; bank_data.n_bank_lines - 1:\n                LogData().log_text(\"-\")\n\n        erosion_results.avg_erosion_rate = avg_erosion_rate\n        erosion_results.eq_eroded_vol_per_km = eq_eroded_vol_per_km\n        erosion_results.total_eroded_vol_per_km = total_eroded_vol_per_km\n\n        return bankline_new_list, bankline_eq_list, xy_line_eq_list\n\n    def compute_erosion_per_level(\n        self,\n        level_i: int,\n        bank_data: BankData,\n        simulation_data: ErosionSimulationData,\n        fairway_data: FairwayData,\n        single_parameters: SingleLevelParameters,\n        erosion_inputs: ErosionInputs,\n        km_bin: Tuple[float, float, float],\n        num_km: int,\n    ) -&gt; Tuple[SingleDischargeLevel, np.ndarray]:\n        \"\"\"Compute the bank erosion for a given level.\"\"\"\n        num_levels = self.river_data.num_discharge_levels\n        dvol_bank = np.zeros((num_km, 2))\n        hfw_max_level = 0\n        par_list = []\n        for ind, bank_i in enumerate(bank_data):\n\n            single_calculation = SingleCalculation()\n            # bank_i = 0: left bank, bank_i = 1: right bank\n            # calculate velocity along banks ...\n            single_calculation.bank_velocity = simulation_data.calculate_bank_velocity(\n                bank_i, self.river_data.vel_dx\n            )\n\n            # get fairway face indices\n            fairway_face_indices = bank_i.fairway_face_indices\n            data = simulation_data.get_fairway_data(fairway_face_indices)\n            single_calculation.water_level = data[\"water_level\"]\n            single_calculation.chezy = data[\"chezy\"]\n            single_calculation.water_depth = data[\"water_depth\"]\n\n            # get water depth along the fair-way\n            hfw_max_level = max(hfw_max_level, single_calculation.water_depth.max())\n\n            # last discharge level\n            if level_i == num_levels - 1:\n                erosion_distance_eq, erosion_volume_eq = (\n                    self.erosion_calculator.comp_erosion_eq(\n                        bank_i.height,\n                        bank_i.segment_length,\n                        fairway_data.fairway_initial_water_levels[ind],\n                        single_parameters.get_bank(ind),\n                        bank_i.fairway_distances,\n                        single_calculation.water_depth,\n                        erosion_inputs.get_bank(ind),\n                    )\n                )\n                single_calculation.erosion_distance_eq = erosion_distance_eq\n                single_calculation.erosion_volume_eq = erosion_volume_eq\n\n            single_calculation = self.erosion_calculator.compute_bank_erosion_dynamics(\n                single_calculation,\n                bank_i.height,\n                bank_i.segment_length,\n                bank_i.fairway_distances,\n                fairway_data.fairway_initial_water_levels[ind],\n                single_parameters.get_bank(ind),\n                self.river_data.erosion_time * self.p_discharge[level_i],\n                erosion_inputs.get_bank(ind),\n            )\n\n            # accumulate eroded volumes per km\n            volume_per_discharge = get_km_eroded_volume(\n                bank_i.bank_chainage_midpoints,\n                single_calculation.erosion_volume_tot,\n                km_bin,\n            )\n            single_calculation.volume_per_discharge = volume_per_discharge\n            par_list.append(single_calculation)\n\n            dvol_bank[:, ind] += volume_per_discharge\n\n            if self.river_data.debug:\n                self._debug_output(\n                    level_i,\n                    ind,\n                    bank_data,\n                    fairway_data,\n                    erosion_inputs,\n                    single_parameters,\n                    num_levels,\n                    single_calculation,\n                )\n\n        level_calculation = SingleDischargeLevel(\n            left=par_list[0], right=par_list[1], hfw_max=hfw_max_level\n        )\n\n        return level_calculation, dvol_bank\n\n    def _debug_output(\n        self,\n        level_i,\n        ind,\n        bank_data: BankData,\n        fairway_data: FairwayData,\n        erosion_inputs: ErosionInputs,\n        single_level_parameters: SingleLevelParameters,\n        num_levels: int,\n        single_calculation: SingleCalculation,\n    ):\n        if level_i == num_levels - 1:\n            # EQ debug\n            self.debugger.last_discharge_level(\n                ind,\n                bank_data.get_bank(ind),\n                fairway_data,\n                erosion_inputs.get_bank(ind),\n                single_level_parameters.get_bank(ind),\n                single_calculation,\n            )\n        # Q-specific debug\n        self.debugger.middle_levels(\n            ind,\n            level_i,\n            bank_data.get_bank(ind),\n            fairway_data,\n            erosion_inputs.get_bank(ind),\n            single_level_parameters.get_bank(ind),\n            single_calculation,\n        )\n\n    def get_mesh_processor(self):\n        LogData().log_text(\"derive_topology\")\n        mesh_data = self.simulation_data.compute_mesh_topology(verbose=False)\n\n        return MeshProcessor(self.river_data, mesh_data, verbose=self.config_file.debug)\n\n    def run(self) -&gt; None:\n        \"\"\"Run the bank erosion analysis for a specified configuration.\"\"\"\n        timed_logger(\"-- start analysis --\")\n        LogData().log_text(\n            \"header_bankerosion\",\n            data={\n                \"version\": __version__,\n                \"location\": \"https://github.com/Deltares/D-FAST_Bank_Erosion\",\n            },\n        )\n        LogData().log_text(\"-\")\n\n        mesh_processor = self.get_mesh_processor()\n\n        river_axis = self.river_data.process_river_axis_by_center_line()\n        fairway_data = mesh_processor.get_fairway_data(river_axis)\n\n        # map to the output interval\n        km_bin = (\n            river_axis.data[\"stations\"].min(),\n            river_axis.data[\"stations\"].max(),\n            self.river_data.output_intervals,\n        )\n        km_mid = get_km_bins(km_bin, station_type=\"mid\")  # get mid-points\n\n        # map bank lines to mesh cells\n        LogData().log_text(\"intersect_bank_mesh\")\n        bank_data = mesh_processor.get_bank_data()\n        # map the bank data to the fairway data (the bank_data and fairway_data will be updated inside the `_map_bank_to_fairway` function)\n        self.calculate_fairway_bank_line_distance(\n            bank_data, fairway_data, self.simulation_data\n        )\n\n        erosion_inputs = self._prepare_initial_conditions(\n            bank_data.num_stations_per_bank, fairway_data\n        )\n\n        # initialize arrays for erosion loop over all discharges\n        water_level_data, erosion_results = self._process_discharge_levels(\n            km_mid,\n            km_bin,\n            erosion_inputs,\n            bank_data,\n            fairway_data,\n        )\n\n        bankline_new_list, bankline_eq_list, xy_line_eq_list = (\n            self._postprocess_erosion_results(\n                km_bin,\n                km_mid,\n                bank_data,\n                erosion_results,\n            )\n        )\n\n        self.results = {\n            \"river_axis\": river_axis,\n            \"bank_data\": bank_data,\n            \"water_level_data\": water_level_data,\n            \"erosion_results\": erosion_results,\n            \"erosion_inputs\": erosion_inputs,\n            \"bankline_new_list\": bankline_new_list,\n            \"bankline_eq_list\": bankline_eq_list,\n            \"xy_line_eq_list\": xy_line_eq_list,\n            \"km_mid\": km_mid,\n        }\n\n    def plot(self):\n        # create various plots\n        if self.river_data.plot_flags.plot_data:\n            plotter = ErosionPlotter(\n                self.gui,\n                self.river_data.plot_flags,\n                self.results[\"erosion_results\"],\n                self.results[\"bank_data\"],\n                self.results[\"water_level_data\"],\n                self.results[\"erosion_inputs\"],\n            )\n            plotter.plot_all(\n                self.results[\"river_axis\"].data[\"stations\"],\n                self.results[\"xy_line_eq_list\"],\n                self.results[\"km_mid\"],\n                self.river_data.output_intervals,\n                self.river_data.river_center_line.as_array(),\n                self.simulation_data,\n            )\n\n    def save(self):\n        self._write_bankline_shapefiles(\n            self.results[\"bankline_new_list\"],\n            self.results[\"bankline_eq_list\"],\n            self.config_file,\n        )\n        self._write_volume_outputs(\n            self.results[\"erosion_results\"], self.results[\"km_mid\"]\n        )\n\n    def _write_bankline_shapefiles(\n        self, bankline_new_list, bankline_eq_list, config_file: ConfigFile\n    ):\n        bankline_new_series = GeoSeries(bankline_new_list, crs=config_file.crs)\n        bank_lines_new = GeoDataFrame(geometry=bankline_new_series)\n        bank_name = self.config_file.get_str(\"General\", \"BankFile\", \"bankfile\")\n\n        bank_file = self.river_data.output_dir / f\"{bank_name}_new.shp\"\n        LogData().log_text(\"save_banklines\", data={\"file\": str(bank_file)})\n        bank_lines_new.to_file(bank_file)\n\n        bankline_eq_series = GeoSeries(bankline_eq_list, crs=config_file.crs)\n        banklines_eq = GeoDataFrame(geometry=bankline_eq_series)\n\n        bank_file = self.river_data.output_dir / f\"{bank_name}_eq.shp\"\n        LogData().log_text(\"save_banklines\", data={\"file\": str(bank_file)})\n        banklines_eq.to_file(bank_file)\n\n    def _write_volume_outputs(self, erosion_results: ErosionResults, km_mid):\n        erosion_vol_file = self.config_file.get_str(\n            \"Erosion\", \"EroVol\", default=\"erovol.evo\"\n        )\n        LogData().log_text(\"save_tot_erovol\", data={\"file\": erosion_vol_file})\n        write_km_eroded_volumes(\n            km_mid,\n            erosion_results.total_eroded_vol_per_km,\n            str(self.river_data.output_dir / erosion_vol_file),\n        )\n\n        # write eroded volumes per km (equilibrium)\n        erosion_vol_file = self.config_file.get_str(\n            \"Erosion\", \"EroVolEqui\", default=\"erovol_eq.evo\"\n        )\n        LogData().log_text(\"save_eq_erovol\", data={\"file\": erosion_vol_file})\n        write_km_eroded_volumes(\n            km_mid,\n            erosion_results.eq_eroded_vol_per_km,\n            str(self.river_data.output_dir / erosion_vol_file),\n        )\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.bank_erosion.Erosion.__init__","title":"<code>__init__(config_file: ConfigFile, gui: bool = False)</code>","text":"<p>Initialize the Erosion class.</p> Source code in <code>src/dfastbe/bank_erosion/bank_erosion.py</code> <pre><code>def __init__(self, config_file: ConfigFile, gui: bool = False):\n    \"\"\"Initialize the Erosion class.\"\"\"\n    super().__init__(config_file, gui)\n\n    self.river_data = ErosionRiverData(config_file)\n    self.simulation_data = self.river_data.simulation_data()\n    self.sim_files, self.p_discharge = self.river_data.get_erosion_sim_data(\n        self.river_data.num_discharge_levels\n    )\n    self.debugger = Debugger(config_file.crs, self.river_data.output_dir)\n    self.erosion_calculator = ErosionCalculator()\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.bank_erosion.Erosion.calculate_fairway_bank_line_distance","title":"<code>calculate_fairway_bank_line_distance(bank_data: BankData, fairway_data: FairwayData, simulation_data: ErosionSimulationData)</code>","text":"<p>Map bank data to fairway data.</p> <p>Parameters:</p> Name Type Description Default <code>bank_data</code> <code>BankData</code> required <code>fairway_data</code> <code>FairwayData</code> required <code>simulation_data</code> <code>ErosionSimulationData</code> required <p>Returns:</p> Name Type Description <code>FairwayData</code> <p>The method updates the following attributes in the <code>bank_data</code> instance     - fairway_face_indices     - fairway_distances</p> <code>BankData</code> <p>the following attributes in the <code>fairway_data</code> instance     - fairway_initial_water_levels</p> Source code in <code>src/dfastbe/bank_erosion/bank_erosion.py</code> <pre><code>def calculate_fairway_bank_line_distance(\n    self,\n    bank_data: BankData,\n    fairway_data: FairwayData,\n    simulation_data: ErosionSimulationData,\n):\n    \"\"\"Map bank data to fairway data.\n\n    Args:\n        bank_data (BankData):\n        fairway_data (FairwayData):\n        simulation_data (ErosionSimulationData):\n\n    Returns:\n        FairwayData:\n            The method updates the following attributes in the `bank_data` instance\n                - fairway_face_indices\n                - fairway_distances\n        BankData:\n            the following attributes in the `fairway_data` instance\n                - fairway_initial_water_levels\n    \"\"\"\n    # distance fairway-bankline (bank-fairway)\n    LogData().log_text(\"bank_distance_fairway\")\n\n    num_fairway_face_ind = len(fairway_data.fairway_face_indices)\n\n    for bank_i, single_bank in enumerate(bank_data):\n        bank_coords = single_bank.bank_line_coords\n        coords_mid = (bank_coords[:-1] + bank_coords[1:]) / 2\n        bank_fairway_dist = np.zeros(len(coords_mid))\n        bp_fw_face_idx = np.zeros(len(coords_mid), dtype=int)\n\n        for ind, coord_i in enumerate(coords_mid):\n            # find closest fairway support node\n            closest_ind = np.argmin(\n                ((coord_i - fairway_data.intersection_coords) ** 2).sum(axis=1)\n            )\n            fairway_coord = fairway_data.intersection_coords[closest_ind]\n            fairway_bank_distance = ((coord_i - fairway_coord) ** 2).sum() ** 0.5\n            # If fairway support node is also the closest projected fairway point, then it likely\n            # that that point is one of the original support points (a corner) of the fairway path\n            # and located inside a grid cell. The segments before and after that point will then\n            # both be located inside that same grid cell, so let's pick the segment before the point.\n            # If the point happens to coincide with a grid edge and the two segments are located\n            # in different grid cells, then we could either simply choose one or add complexity to\n            # average the values of the two grid cells. Let's go for the simplest approach ...\n            iseg = max(closest_ind - 1, 0)\n            if closest_ind &gt; 0:\n                alpha = calculate_alpha(\n                    fairway_data.intersection_coords,\n                    closest_ind,\n                    closest_ind - 1,\n                    coord_i,\n                )\n                if 0 &lt; alpha &lt; 1:\n                    fwp1 = fairway_data.intersection_coords[\n                        closest_ind - 1\n                    ] + alpha * (\n                        fairway_data.intersection_coords[closest_ind]\n                        - fairway_data.intersection_coords[closest_ind - 1]\n                    )\n                    d1 = ((coord_i - fwp1) ** 2).sum() ** 0.5\n                    if d1 &lt; fairway_bank_distance:\n                        fairway_bank_distance = d1\n                        # projected point located on segment before, which corresponds to initial choice: iseg = ifw - 1\n            if closest_ind &lt; num_fairway_face_ind:\n                alpha = calculate_alpha(\n                    fairway_data.intersection_coords,\n                    closest_ind + 1,\n                    closest_ind,\n                    coord_i,\n                )\n                if 0 &lt; alpha &lt; 1:\n                    fwp1 = fairway_data.intersection_coords[closest_ind] + alpha * (\n                        fairway_data.intersection_coords[closest_ind + 1]\n                        - fairway_data.intersection_coords[closest_ind]\n                    )\n                    d1 = ((coord_i - fwp1) ** 2).sum() ** 0.5\n                    if d1 &lt; fairway_bank_distance:\n                        fairway_bank_distance = d1\n                        iseg = closest_ind\n\n            bp_fw_face_idx[ind] = fairway_data.fairway_face_indices[iseg]\n            bank_fairway_dist[ind] = fairway_bank_distance\n\n        if self.river_data.debug:\n            line_geom = LineGeometry(coords_mid, crs=self.config_file.crs)\n            line_geom.to_file(\n                file_name=f\"{self.river_data.output_dir}/bank_{bank_i + 1}_chainage_and_fairway_face_idx.shp\",\n                data={\n                    \"chainage\": single_bank.bank_chainage_midpoints,\n                    \"iface_fw\": bp_fw_face_idx[bank_i],\n                },\n            )\n\n        single_bank.fairway_face_indices = bp_fw_face_idx\n        single_bank.fairway_distances = bank_fairway_dist\n\n    # water level at fairway\n    water_level_fairway_ref = []\n    for single_bank in bank_data:\n        ii = single_bank.fairway_face_indices\n        water_level_fairway_ref.append(simulation_data.water_level_face[ii])\n    fairway_data.fairway_initial_water_levels = water_level_fairway_ref\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.bank_erosion.Erosion.compute_erosion_per_level","title":"<code>compute_erosion_per_level(level_i: int, bank_data: BankData, simulation_data: ErosionSimulationData, fairway_data: FairwayData, single_parameters: SingleLevelParameters, erosion_inputs: ErosionInputs, km_bin: Tuple[float, float, float], num_km: int) -&gt; Tuple[SingleDischargeLevel, np.ndarray]</code>","text":"<p>Compute the bank erosion for a given level.</p> Source code in <code>src/dfastbe/bank_erosion/bank_erosion.py</code> <pre><code>def compute_erosion_per_level(\n    self,\n    level_i: int,\n    bank_data: BankData,\n    simulation_data: ErosionSimulationData,\n    fairway_data: FairwayData,\n    single_parameters: SingleLevelParameters,\n    erosion_inputs: ErosionInputs,\n    km_bin: Tuple[float, float, float],\n    num_km: int,\n) -&gt; Tuple[SingleDischargeLevel, np.ndarray]:\n    \"\"\"Compute the bank erosion for a given level.\"\"\"\n    num_levels = self.river_data.num_discharge_levels\n    dvol_bank = np.zeros((num_km, 2))\n    hfw_max_level = 0\n    par_list = []\n    for ind, bank_i in enumerate(bank_data):\n\n        single_calculation = SingleCalculation()\n        # bank_i = 0: left bank, bank_i = 1: right bank\n        # calculate velocity along banks ...\n        single_calculation.bank_velocity = simulation_data.calculate_bank_velocity(\n            bank_i, self.river_data.vel_dx\n        )\n\n        # get fairway face indices\n        fairway_face_indices = bank_i.fairway_face_indices\n        data = simulation_data.get_fairway_data(fairway_face_indices)\n        single_calculation.water_level = data[\"water_level\"]\n        single_calculation.chezy = data[\"chezy\"]\n        single_calculation.water_depth = data[\"water_depth\"]\n\n        # get water depth along the fair-way\n        hfw_max_level = max(hfw_max_level, single_calculation.water_depth.max())\n\n        # last discharge level\n        if level_i == num_levels - 1:\n            erosion_distance_eq, erosion_volume_eq = (\n                self.erosion_calculator.comp_erosion_eq(\n                    bank_i.height,\n                    bank_i.segment_length,\n                    fairway_data.fairway_initial_water_levels[ind],\n                    single_parameters.get_bank(ind),\n                    bank_i.fairway_distances,\n                    single_calculation.water_depth,\n                    erosion_inputs.get_bank(ind),\n                )\n            )\n            single_calculation.erosion_distance_eq = erosion_distance_eq\n            single_calculation.erosion_volume_eq = erosion_volume_eq\n\n        single_calculation = self.erosion_calculator.compute_bank_erosion_dynamics(\n            single_calculation,\n            bank_i.height,\n            bank_i.segment_length,\n            bank_i.fairway_distances,\n            fairway_data.fairway_initial_water_levels[ind],\n            single_parameters.get_bank(ind),\n            self.river_data.erosion_time * self.p_discharge[level_i],\n            erosion_inputs.get_bank(ind),\n        )\n\n        # accumulate eroded volumes per km\n        volume_per_discharge = get_km_eroded_volume(\n            bank_i.bank_chainage_midpoints,\n            single_calculation.erosion_volume_tot,\n            km_bin,\n        )\n        single_calculation.volume_per_discharge = volume_per_discharge\n        par_list.append(single_calculation)\n\n        dvol_bank[:, ind] += volume_per_discharge\n\n        if self.river_data.debug:\n            self._debug_output(\n                level_i,\n                ind,\n                bank_data,\n                fairway_data,\n                erosion_inputs,\n                single_parameters,\n                num_levels,\n                single_calculation,\n            )\n\n    level_calculation = SingleDischargeLevel(\n        left=par_list[0], right=par_list[1], hfw_max=hfw_max_level\n    )\n\n    return level_calculation, dvol_bank\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.bank_erosion.Erosion.run","title":"<code>run() -&gt; None</code>","text":"<p>Run the bank erosion analysis for a specified configuration.</p> Source code in <code>src/dfastbe/bank_erosion/bank_erosion.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Run the bank erosion analysis for a specified configuration.\"\"\"\n    timed_logger(\"-- start analysis --\")\n    LogData().log_text(\n        \"header_bankerosion\",\n        data={\n            \"version\": __version__,\n            \"location\": \"https://github.com/Deltares/D-FAST_Bank_Erosion\",\n        },\n    )\n    LogData().log_text(\"-\")\n\n    mesh_processor = self.get_mesh_processor()\n\n    river_axis = self.river_data.process_river_axis_by_center_line()\n    fairway_data = mesh_processor.get_fairway_data(river_axis)\n\n    # map to the output interval\n    km_bin = (\n        river_axis.data[\"stations\"].min(),\n        river_axis.data[\"stations\"].max(),\n        self.river_data.output_intervals,\n    )\n    km_mid = get_km_bins(km_bin, station_type=\"mid\")  # get mid-points\n\n    # map bank lines to mesh cells\n    LogData().log_text(\"intersect_bank_mesh\")\n    bank_data = mesh_processor.get_bank_data()\n    # map the bank data to the fairway data (the bank_data and fairway_data will be updated inside the `_map_bank_to_fairway` function)\n    self.calculate_fairway_bank_line_distance(\n        bank_data, fairway_data, self.simulation_data\n    )\n\n    erosion_inputs = self._prepare_initial_conditions(\n        bank_data.num_stations_per_bank, fairway_data\n    )\n\n    # initialize arrays for erosion loop over all discharges\n    water_level_data, erosion_results = self._process_discharge_levels(\n        km_mid,\n        km_bin,\n        erosion_inputs,\n        bank_data,\n        fairway_data,\n    )\n\n    bankline_new_list, bankline_eq_list, xy_line_eq_list = (\n        self._postprocess_erosion_results(\n            km_bin,\n            km_mid,\n            bank_data,\n            erosion_results,\n        )\n    )\n\n    self.results = {\n        \"river_axis\": river_axis,\n        \"bank_data\": bank_data,\n        \"water_level_data\": water_level_data,\n        \"erosion_results\": erosion_results,\n        \"erosion_inputs\": erosion_inputs,\n        \"bankline_new_list\": bankline_new_list,\n        \"bankline_eq_list\": bankline_eq_list,\n        \"xy_line_eq_list\": xy_line_eq_list,\n        \"km_mid\": km_mid,\n    }\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.bank_erosion.calculate_alpha","title":"<code>calculate_alpha(coords: np.ndarray, ind_1: int, ind_2: int, bp: Tuple[int, Any])</code>","text":"<p>Calculate the alpha value for the bank erosion model.</p> Source code in <code>src/dfastbe/bank_erosion/bank_erosion.py</code> <pre><code>def calculate_alpha(coords: np.ndarray, ind_1: int, ind_2: int, bp: Tuple[int, Any]):\n    \"\"\"Calculate the alpha value for the bank erosion model.\"\"\"\n    alpha = (\n        (coords[ind_1, 0] - coords[ind_2, 0]) * (bp[0] - coords[ind_2, 0])\n        + (coords[ind_1, 1] - coords[ind_2, 1]) * (bp[1] - coords[ind_2, 1])\n    ) / (\n        (coords[ind_1, 0] - coords[ind_2, 0]) ** 2\n        + (coords[ind_1, 1] - coords[ind_2, 1]) ** 2\n    )\n\n    return alpha\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#mesh-data-models","title":"Mesh data models","text":""},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.data_models","title":"<code>dfastbe.bank_erosion.mesh.data_models</code>","text":"<p>This module defines data structures and methods for handling mesh data and river segments.</p>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.data_models.Edges","title":"<code>Edges</code>  <code>dataclass</code>","text":"<p>Dataclass to hold edge candidates for left and right edges.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>int</code> <p>Index of the left edge.</p> required <code>left_theta</code> <code>float</code> <p>Angle of the left edge in radians.</p> required <code>right</code> <code>int</code> <p>Index of the right edge.</p> required <code>right_theta</code> <code>float</code> <p>Angle of the right edge in radians.</p> required <code>found</code> <code>bool</code> <p>Flag indicating whether a valid edge pair was found.</p> <code>False</code> Source code in <code>src/dfastbe/bank_erosion/mesh/data_models.py</code> <pre><code>@dataclass\nclass Edges:\n    \"\"\"Dataclass to hold edge candidates for left and right edges.\n\n    Args:\n        left (int):\n            Index of the left edge.\n        left_theta (float):\n            Angle of the left edge in radians.\n        right (int):\n            Index of the right edge.\n        right_theta (float):\n            Angle of the right edge in radians.\n        found (bool):\n            Flag indicating whether a valid edge pair was found.\n    \"\"\"\n\n    left: int\n    left_theta: float\n    right: int\n    right_theta: float\n    found: bool = False\n\n    def update_edges_by_angle(\n        self, edge_index: int, dtheta: float, j, verbose: bool = False\n    ):\n        \"\"\"Update the left and right edges based on the angle difference.\"\"\"\n\n        if dtheta &gt; 0:\n            if dtheta &lt; self.left_theta:\n                self.left = edge_index\n                self.left_theta = dtheta\n            if TWO_PI - dtheta &lt; self.right_theta:\n                self.right = edge_index\n                self.right_theta = TWO_PI - dtheta\n        elif dtheta &lt; 0:\n            dtheta = -dtheta\n            if TWO_PI - dtheta &lt; self.left_theta:\n                self.left = edge_index\n                self.left_theta = TWO_PI - dtheta\n            if dtheta &lt; self.right_theta:\n                self.right = edge_index\n                self.right_theta = dtheta\n        else:\n            # aligned with edge\n            if verbose and j is not None:\n                print(f\"{j}: line is aligned with edge {edge_index}\")\n\n            self.left = edge_index\n            self.right = edge_index\n            self.found = True\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.data_models.Edges.update_edges_by_angle","title":"<code>update_edges_by_angle(edge_index: int, dtheta: float, j, verbose: bool = False)</code>","text":"<p>Update the left and right edges based on the angle difference.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/data_models.py</code> <pre><code>def update_edges_by_angle(\n    self, edge_index: int, dtheta: float, j, verbose: bool = False\n):\n    \"\"\"Update the left and right edges based on the angle difference.\"\"\"\n\n    if dtheta &gt; 0:\n        if dtheta &lt; self.left_theta:\n            self.left = edge_index\n            self.left_theta = dtheta\n        if TWO_PI - dtheta &lt; self.right_theta:\n            self.right = edge_index\n            self.right_theta = TWO_PI - dtheta\n    elif dtheta &lt; 0:\n        dtheta = -dtheta\n        if TWO_PI - dtheta &lt; self.left_theta:\n            self.left = edge_index\n            self.left_theta = TWO_PI - dtheta\n        if dtheta &lt; self.right_theta:\n            self.right = edge_index\n            self.right_theta = dtheta\n    else:\n        # aligned with edge\n        if verbose and j is not None:\n            print(f\"{j}: line is aligned with edge {edge_index}\")\n\n        self.left = edge_index\n        self.right = edge_index\n        self.found = True\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.data_models.MeshData","title":"<code>MeshData</code>  <code>dataclass</code>","text":"<p>Class to hold mesh-related data.</p> <p>Parameters:</p> Name Type Description Default <code>x_face_coords</code> <code>ndarray</code> <p>X-coordinates of the mesh faces.</p> required <code>y_face_coords</code> <code>ndarray</code> <p>Y-coordinates of the mesh faces.</p> required <code>x_edge_coords</code> <code>ndarray</code> <p>X-coordinates of the mesh edges.</p> required <code>y_edge_coords</code> <code>ndarray</code> <p>Y-coordinates of the mesh edges.</p> required <code>face_node</code> <code>ndarray</code> <p>Node connectivity for each face.</p> required <code>n_nodes</code> <code>ndarray</code> <p>Number of nodes in the mesh.</p> required <code>edge_node</code> <code>ndarray</code> <p>Node connectivity for each edge.</p> required <code>edge_face_connectivity</code> <code>ndarray</code> <p>Per edge a list of the indices of the faces on the left and right side of that edge.</p> required <code>face_edge_connectivity</code> <code>ndarray</code> <p>Per face a list of indices of the edges that together form the boundary of that face.</p> required <code>boundary_edge_nrs</code> <code>ndarray</code> <p>List of edge indices that together form the boundary of the whole mesh.</p> required Source code in <code>src/dfastbe/bank_erosion/mesh/data_models.py</code> <pre><code>@dataclass\nclass MeshData:\n    \"\"\"Class to hold mesh-related data.\n\n    args:\n        x_face_coords (np.ndarray):\n            X-coordinates of the mesh faces.\n        y_face_coords (np.ndarray):\n            Y-coordinates of the mesh faces.\n        x_edge_coords (np.ndarray):\n            X-coordinates of the mesh edges.\n        y_edge_coords (np.ndarray):\n            Y-coordinates of the mesh edges.\n        face_node (np.ndarray):\n            Node connectivity for each face.\n        n_nodes (np.ndarray):\n            Number of nodes in the mesh.\n        edge_node (np.ndarray):\n            Node connectivity for each edge.\n        edge_face_connectivity (np.ndarray):\n            Per edge a list of the indices of the faces on the left and right side of that edge.\n        face_edge_connectivity (np.ndarray):\n            Per face a list of indices of the edges that together form the boundary of that face.\n        boundary_edge_nrs (np.ndarray):\n            List of edge indices that together form the boundary of the whole mesh.\n    \"\"\"\n\n    x_face_coords: np.ndarray\n    y_face_coords: np.ndarray\n    x_edge_coords: np.ndarray\n    y_edge_coords: np.ndarray\n    face_node: np.ndarray\n    n_nodes: np.ndarray\n    edge_node: np.ndarray\n    edge_face_connectivity: np.ndarray\n    face_edge_connectivity: np.ndarray\n    boundary_edge_nrs: np.ndarray\n    verbose: bool = False\n\n    def get_face_by_index(self, index: int, as_polygon: bool = False) -&gt; np.ndarray | Polygon:\n        \"\"\"Returns the coordinates of the index-th mesh face as an (N, 2) array.\n\n        Args:\n            index:\n                The face index.\n            as_polygon:\n                whither to return the face as a shapely polygon or not. Default is False\n\n        Returns:\n            np.ndarray:\n                Array of shape (n_nodes, 2) with x, y coordinates.\n        \"\"\"\n        x = self.x_face_coords[index : index + 1, : self.n_nodes[index]]\n        y = self.y_face_coords[index : index + 1, : self.n_nodes[index]]\n        face = np.concatenate((x, y), axis=0).T\n\n        if as_polygon:\n            face = Polygon(face)\n        return face\n\n    def locate_point(\n        self, point: Point | np.ndarray | list | Tuple, face_index: int | np.ndarray\n    ) -&gt; int | List[int]:\n        \"\"\"Locate a point in the mesh faces.\n\n        Args:\n            point:\n                The point to check.\n            face_index:\n                The index of the mesh face.\n\n        Returns:\n            indexes (int|list[int]):\n                index if the face that the point is located in, or a list of indexes if the point is on the edge of\n                multiple faces.\n        \"\"\"\n        if not isinstance(point, Point) and isinstance(\n            point, (list, tuple, np.ndarray)\n        ):\n            point = Point(point)\n        else:\n            raise TypeError(\n                \"point must be a Point object, a list, a tuple, or an np.ndarray of coordinates\"\n            )\n\n        index_list = []\n        for ind in face_index:\n            face = self.get_face_by_index(ind)\n            face_polygon = Polygon(face)\n            if face_polygon.contains(point):\n                return ind\n            else:\n                # create a closed line string from the face coordinates\n                closed_line = LineString(np.vstack([face, face[0]]))\n                if closed_line.contains(point):\n                    index_list.append(ind)\n\n        return index_list\n\n    def find_segment_intersections(\n        self,\n        index: int,\n        segment: RiverSegment,\n    ) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"Calculate the intersection of a line segment with the edges of a mesh face.\n\n        This function determines where a line segment (defined by two points) intersects the edges of a mesh face.\n        It returns the relative distances along the segment and the edges where the intersections occur, as well as\n        flags indicating whether the intersections occur at nodes.\n\n        Args:\n            index (int):\n                Index of the current mesh face. If `index` is negative, the function assumes the segment intersects\n                the boundary edges of the mesh.\n            segment (RiverSegment):\n                A `RiverSegment` object containing the previous and current points of the segment, as well as the\n                minimum relative distance along the segment where the last intersection occurred.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray, np.ndarray]:\n                - b (np.ndarray):\n                    Relative distances along the segment `bpj1-bpj` where the intersections occur.\n                - edges (np.ndarray):\n                    Indices of the edges that are intersected by the segment.\n                - nodes (np.ndarray):\n                    Flags indicating whether the intersections occur at nodes. A value of `-1` indicates no\n                    intersection at a node, while other values correspond to node indices.\n\n        Raises:\n            ValueError:\n                If the input data is invalid or inconsistent.\n\n        Notes:\n            - If `index` is negative, the function assumes the segment intersects the boundary edges of the mesh.\n            - The function uses the `get_slices_core` helper function to calculate the intersections.\n            - Intersections at nodes are flagged in the `nodes` array, with the corresponding node indices.\n\n        \"\"\"\n        if index &lt; 0:\n            edges = self.boundary_edge_nrs\n        else:\n            edges = self.face_edge_connectivity[index, : self.n_nodes[index]]\n        edge_relative_dist, segment_relative_dist, edges = (\n            self.calculate_edge_intersections(edges, segment, True)\n        )\n        is_intersected_at_node = -np.ones(edge_relative_dist.shape, dtype=np.int64)\n        is_intersected_at_node[edge_relative_dist == 0] = self.edge_node[\n            edges[edge_relative_dist == 0], 0\n        ]\n        is_intersected_at_node[edge_relative_dist == 1] = self.edge_node[\n            edges[edge_relative_dist == 1], 1\n        ]\n\n        return segment_relative_dist, edges, is_intersected_at_node\n\n    def calculate_edge_intersections(\n        self,\n        edges: np.ndarray,\n        segment: RiverSegment,\n        limit_relative_distance: bool = True,\n    ) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"Calculate the intersection of a line segment with multiple mesh edges.\n\n        This function determines where a line segment intersects a set of mesh edges.\n        It calculates the relative distances along the segment and the edges where\n        the intersections occur, and returns the indices of the intersected edges.\n\n        Args:\n            edges (np.ndarray):\n                Array containing the indices of the edges to check for intersections.\n            segment (RiverSegment):\n                A `RiverSegment` object containing the previous and current points of the segment, as well as the\n                minimum relative distance along the segment where the last intersection occurred.\n            limit_relative_distance (bool, optional):\n                If True, limits the relative distance along the segment `bpj1-bpj`\n                to a maximum of 1. Defaults to True.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray, np.ndarray]:\n                - a (np.ndarray): Relative distances along the edges where the\n                  intersections occur.\n                - b (np.ndarray): Relative distances along the segment `bpj1-bpj`\n                  where the intersections occur.\n                - edges (np.ndarray): Indices of the edges that are intersected\n                  by the segment.\n\n        Raises:\n            ValueError:\n                If the input data is invalid or inconsistent.\n\n        Notes:\n            - The function uses the `get_slices_ab` helper function to calculate the\n              relative distances `a` and `b` for each edge.\n            - The `bmin` parameter is used to filter out intersections that occur\n              too close to the starting point of the segment.\n            - If `limit_relative_distance` is True, intersections beyond the endpoint of the segment\n              are ignored.\n        \"\"\"\n        from dfastbe.bank_erosion.utils import calculate_segment_edge_intersections\n\n        edge_relative_dist, segment_relative_dist, valid_intersections = (\n            calculate_segment_edge_intersections(\n                self.x_edge_coords[edges, 0],\n                self.y_edge_coords[edges, 0],\n                self.x_edge_coords[edges, 1],\n                self.y_edge_coords[edges, 1],\n                segment.previous_point[0],\n                segment.previous_point[1],\n                segment.current_point[0],\n                segment.current_point[1],\n                segment.min_relative_distance,\n                limit_relative_distance,\n            )\n        )\n        edges = edges[valid_intersections]\n        return edge_relative_dist, segment_relative_dist, edges\n\n    def calculate_edge_angle(self, edge: int, reverse: bool = False) -&gt; float:\n        \"\"\"Calculate the angle of a mesh edge in radians.\n\n        Args:\n            edge (int):\n                The edge index.\n            reverse (bool):\n                If True, computes the angle from end to start.\n\n        Returns:\n            float: The angle of the edge in radians.\n        \"\"\"\n        start, end = (1, 0) if reverse else (0, 1)\n        dx = self.x_edge_coords[edge, end] - self.x_edge_coords[edge, start]\n        dy = self.y_edge_coords[edge, end] - self.y_edge_coords[edge, start]\n\n        return math.atan2(dy, dx)\n\n    def find_edges(self, theta, node, verbose_index: int = None) -&gt; Edges:\n        \"\"\"\n        Helper to find the left and right edges at a node based on the direction theta.\n\n        Args:\n            theta (float):\n                Direction angle of the segment.\n            node (int):\n                The node index.\n            verbose_index (int, optional):\n                Step index for verbose output.\n\n        Returns:\n            Edges:\n                A dataclass containing the left and right edge indices, their angle differences, and a found flag.\n        \"\"\"\n        all_node_edges = np.nonzero((self.edge_node == node).any(axis=1))[0]\n\n        if self.verbose and verbose_index is not None:\n            print(\n                f\"{verbose_index}: the edges connected to node {node} are {all_node_edges}\"\n            )\n\n        edges = Edges(left=-1, left_theta=TWO_PI, right=-1, right_theta=TWO_PI)\n\n        for ie in all_node_edges:\n            reverse = self.edge_node[ie, 0] != node\n            theta_edge = self.calculate_edge_angle(ie, reverse=reverse)\n\n            if self.verbose and verbose_index is not None:\n                print(f\"{verbose_index}: edge {ie} connects {self.edge_node[ie, :]}\")\n                print(f\"{verbose_index}: edge {ie} theta is {theta_edge}\")\n\n            dtheta = theta_edge - theta\n\n            edges.update_edges_by_angle(ie, dtheta, verbose_index)\n            if edges.found:\n                break\n\n        if self.verbose and verbose_index is not None:\n            print(f\"{verbose_index}: the edge to the left is edge {edges.left}\")\n            print(f\"{verbose_index}: the edge to the right is edge {edges.right}\")\n\n        return edges\n\n    def resolve_next_face_from_edges(\n        self, node, edges: Edges, verbose_index: int = None\n    ) -&gt; int:\n        \"\"\"\n        Helper to resolve the next face index when traversing between two edges at a node.\n\n        Args:\n            node (int): The node index.\n            edges (Edges):\n                The edges connecting the node, containing left and right edge indices.\n            verbose_index (int, optional):\n                Step index for verbose output.\n\n        Returns:\n            next_face_index (int):\n                The next face index.\n        \"\"\"\n        left_faces = self.edge_face_connectivity[edges.left, :]\n        right_faces = self.edge_face_connectivity[edges.right, :]\n\n        if left_faces[0] in right_faces and left_faces[1] in right_faces:\n            fn1 = self.face_node[left_faces[0]]\n            fe1 = self.face_edge_connectivity[left_faces[0]]\n\n            if self.verbose and verbose_index is not None:\n                print(\n                    f\"{verbose_index}: those edges are shared by two faces: {left_faces}\"\n                )\n                print(f\"{verbose_index}: face {left_faces[0]} has nodes: {fn1}\")\n                print(f\"{verbose_index}: face {left_faces[0]} has edges: {fe1}\")\n\n            # nodes of the face should be listed in clockwise order\n            # edges[i] is the edge connecting node[i-1] with node[i]\n            # the latter is guaranteed by batch.derive_topology_arrays\n            if fe1[fn1 == node] == edges.right:\n                next_face_index = left_faces[0]\n            else:\n                next_face_index = left_faces[1]\n\n        elif left_faces[0] in right_faces:\n            next_face_index = left_faces[0]\n        elif left_faces[1] in right_faces:\n            next_face_index = left_faces[1]\n        else:\n            raise ValueError(\n                f\"Shouldn't come here .... left edge {edges.left}\"\n                f\" and right edge {edges.right} don't share any face\"\n            )\n        return next_face_index\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.data_models.MeshData.calculate_edge_angle","title":"<code>calculate_edge_angle(edge: int, reverse: bool = False) -&gt; float</code>","text":"<p>Calculate the angle of a mesh edge in radians.</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>int</code> <p>The edge index.</p> required <code>reverse</code> <code>bool</code> <p>If True, computes the angle from end to start.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The angle of the edge in radians.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/data_models.py</code> <pre><code>def calculate_edge_angle(self, edge: int, reverse: bool = False) -&gt; float:\n    \"\"\"Calculate the angle of a mesh edge in radians.\n\n    Args:\n        edge (int):\n            The edge index.\n        reverse (bool):\n            If True, computes the angle from end to start.\n\n    Returns:\n        float: The angle of the edge in radians.\n    \"\"\"\n    start, end = (1, 0) if reverse else (0, 1)\n    dx = self.x_edge_coords[edge, end] - self.x_edge_coords[edge, start]\n    dy = self.y_edge_coords[edge, end] - self.y_edge_coords[edge, start]\n\n    return math.atan2(dy, dx)\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.data_models.MeshData.calculate_edge_intersections","title":"<code>calculate_edge_intersections(edges: np.ndarray, segment: RiverSegment, limit_relative_distance: bool = True) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]</code>","text":"<p>Calculate the intersection of a line segment with multiple mesh edges.</p> <p>This function determines where a line segment intersects a set of mesh edges. It calculates the relative distances along the segment and the edges where the intersections occur, and returns the indices of the intersected edges.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>ndarray</code> <p>Array containing the indices of the edges to check for intersections.</p> required <code>segment</code> <code>RiverSegment</code> <p>A <code>RiverSegment</code> object containing the previous and current points of the segment, as well as the minimum relative distance along the segment where the last intersection occurred.</p> required <code>limit_relative_distance</code> <code>bool</code> <p>If True, limits the relative distance along the segment <code>bpj1-bpj</code> to a maximum of 1. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray, np.ndarray]: - a (np.ndarray): Relative distances along the edges where the   intersections occur. - b (np.ndarray): Relative distances along the segment <code>bpj1-bpj</code>   where the intersections occur. - edges (np.ndarray): Indices of the edges that are intersected   by the segment.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input data is invalid or inconsistent.</p> Notes <ul> <li>The function uses the <code>get_slices_ab</code> helper function to calculate the   relative distances <code>a</code> and <code>b</code> for each edge.</li> <li>The <code>bmin</code> parameter is used to filter out intersections that occur   too close to the starting point of the segment.</li> <li>If <code>limit_relative_distance</code> is True, intersections beyond the endpoint of the segment   are ignored.</li> </ul> Source code in <code>src/dfastbe/bank_erosion/mesh/data_models.py</code> <pre><code>def calculate_edge_intersections(\n    self,\n    edges: np.ndarray,\n    segment: RiverSegment,\n    limit_relative_distance: bool = True,\n) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"Calculate the intersection of a line segment with multiple mesh edges.\n\n    This function determines where a line segment intersects a set of mesh edges.\n    It calculates the relative distances along the segment and the edges where\n    the intersections occur, and returns the indices of the intersected edges.\n\n    Args:\n        edges (np.ndarray):\n            Array containing the indices of the edges to check for intersections.\n        segment (RiverSegment):\n            A `RiverSegment` object containing the previous and current points of the segment, as well as the\n            minimum relative distance along the segment where the last intersection occurred.\n        limit_relative_distance (bool, optional):\n            If True, limits the relative distance along the segment `bpj1-bpj`\n            to a maximum of 1. Defaults to True.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray]:\n            - a (np.ndarray): Relative distances along the edges where the\n              intersections occur.\n            - b (np.ndarray): Relative distances along the segment `bpj1-bpj`\n              where the intersections occur.\n            - edges (np.ndarray): Indices of the edges that are intersected\n              by the segment.\n\n    Raises:\n        ValueError:\n            If the input data is invalid or inconsistent.\n\n    Notes:\n        - The function uses the `get_slices_ab` helper function to calculate the\n          relative distances `a` and `b` for each edge.\n        - The `bmin` parameter is used to filter out intersections that occur\n          too close to the starting point of the segment.\n        - If `limit_relative_distance` is True, intersections beyond the endpoint of the segment\n          are ignored.\n    \"\"\"\n    from dfastbe.bank_erosion.utils import calculate_segment_edge_intersections\n\n    edge_relative_dist, segment_relative_dist, valid_intersections = (\n        calculate_segment_edge_intersections(\n            self.x_edge_coords[edges, 0],\n            self.y_edge_coords[edges, 0],\n            self.x_edge_coords[edges, 1],\n            self.y_edge_coords[edges, 1],\n            segment.previous_point[0],\n            segment.previous_point[1],\n            segment.current_point[0],\n            segment.current_point[1],\n            segment.min_relative_distance,\n            limit_relative_distance,\n        )\n    )\n    edges = edges[valid_intersections]\n    return edge_relative_dist, segment_relative_dist, edges\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.data_models.MeshData.find_edges","title":"<code>find_edges(theta, node, verbose_index: int = None) -&gt; Edges</code>","text":"<p>Helper to find the left and right edges at a node based on the direction theta.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Direction angle of the segment.</p> required <code>node</code> <code>int</code> <p>The node index.</p> required <code>verbose_index</code> <code>int</code> <p>Step index for verbose output.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Edges</code> <code>Edges</code> <p>A dataclass containing the left and right edge indices, their angle differences, and a found flag.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/data_models.py</code> <pre><code>def find_edges(self, theta, node, verbose_index: int = None) -&gt; Edges:\n    \"\"\"\n    Helper to find the left and right edges at a node based on the direction theta.\n\n    Args:\n        theta (float):\n            Direction angle of the segment.\n        node (int):\n            The node index.\n        verbose_index (int, optional):\n            Step index for verbose output.\n\n    Returns:\n        Edges:\n            A dataclass containing the left and right edge indices, their angle differences, and a found flag.\n    \"\"\"\n    all_node_edges = np.nonzero((self.edge_node == node).any(axis=1))[0]\n\n    if self.verbose and verbose_index is not None:\n        print(\n            f\"{verbose_index}: the edges connected to node {node} are {all_node_edges}\"\n        )\n\n    edges = Edges(left=-1, left_theta=TWO_PI, right=-1, right_theta=TWO_PI)\n\n    for ie in all_node_edges:\n        reverse = self.edge_node[ie, 0] != node\n        theta_edge = self.calculate_edge_angle(ie, reverse=reverse)\n\n        if self.verbose and verbose_index is not None:\n            print(f\"{verbose_index}: edge {ie} connects {self.edge_node[ie, :]}\")\n            print(f\"{verbose_index}: edge {ie} theta is {theta_edge}\")\n\n        dtheta = theta_edge - theta\n\n        edges.update_edges_by_angle(ie, dtheta, verbose_index)\n        if edges.found:\n            break\n\n    if self.verbose and verbose_index is not None:\n        print(f\"{verbose_index}: the edge to the left is edge {edges.left}\")\n        print(f\"{verbose_index}: the edge to the right is edge {edges.right}\")\n\n    return edges\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.data_models.MeshData.find_segment_intersections","title":"<code>find_segment_intersections(index: int, segment: RiverSegment) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]</code>","text":"<p>Calculate the intersection of a line segment with the edges of a mesh face.</p> <p>This function determines where a line segment (defined by two points) intersects the edges of a mesh face. It returns the relative distances along the segment and the edges where the intersections occur, as well as flags indicating whether the intersections occur at nodes.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the current mesh face. If <code>index</code> is negative, the function assumes the segment intersects the boundary edges of the mesh.</p> required <code>segment</code> <code>RiverSegment</code> <p>A <code>RiverSegment</code> object containing the previous and current points of the segment, as well as the minimum relative distance along the segment where the last intersection occurred.</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray, np.ndarray]: - b (np.ndarray):     Relative distances along the segment <code>bpj1-bpj</code> where the intersections occur. - edges (np.ndarray):     Indices of the edges that are intersected by the segment. - nodes (np.ndarray):     Flags indicating whether the intersections occur at nodes. A value of <code>-1</code> indicates no     intersection at a node, while other values correspond to node indices.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input data is invalid or inconsistent.</p> Notes <ul> <li>If <code>index</code> is negative, the function assumes the segment intersects the boundary edges of the mesh.</li> <li>The function uses the <code>get_slices_core</code> helper function to calculate the intersections.</li> <li>Intersections at nodes are flagged in the <code>nodes</code> array, with the corresponding node indices.</li> </ul> Source code in <code>src/dfastbe/bank_erosion/mesh/data_models.py</code> <pre><code>def find_segment_intersections(\n    self,\n    index: int,\n    segment: RiverSegment,\n) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"Calculate the intersection of a line segment with the edges of a mesh face.\n\n    This function determines where a line segment (defined by two points) intersects the edges of a mesh face.\n    It returns the relative distances along the segment and the edges where the intersections occur, as well as\n    flags indicating whether the intersections occur at nodes.\n\n    Args:\n        index (int):\n            Index of the current mesh face. If `index` is negative, the function assumes the segment intersects\n            the boundary edges of the mesh.\n        segment (RiverSegment):\n            A `RiverSegment` object containing the previous and current points of the segment, as well as the\n            minimum relative distance along the segment where the last intersection occurred.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray]:\n            - b (np.ndarray):\n                Relative distances along the segment `bpj1-bpj` where the intersections occur.\n            - edges (np.ndarray):\n                Indices of the edges that are intersected by the segment.\n            - nodes (np.ndarray):\n                Flags indicating whether the intersections occur at nodes. A value of `-1` indicates no\n                intersection at a node, while other values correspond to node indices.\n\n    Raises:\n        ValueError:\n            If the input data is invalid or inconsistent.\n\n    Notes:\n        - If `index` is negative, the function assumes the segment intersects the boundary edges of the mesh.\n        - The function uses the `get_slices_core` helper function to calculate the intersections.\n        - Intersections at nodes are flagged in the `nodes` array, with the corresponding node indices.\n\n    \"\"\"\n    if index &lt; 0:\n        edges = self.boundary_edge_nrs\n    else:\n        edges = self.face_edge_connectivity[index, : self.n_nodes[index]]\n    edge_relative_dist, segment_relative_dist, edges = (\n        self.calculate_edge_intersections(edges, segment, True)\n    )\n    is_intersected_at_node = -np.ones(edge_relative_dist.shape, dtype=np.int64)\n    is_intersected_at_node[edge_relative_dist == 0] = self.edge_node[\n        edges[edge_relative_dist == 0], 0\n    ]\n    is_intersected_at_node[edge_relative_dist == 1] = self.edge_node[\n        edges[edge_relative_dist == 1], 1\n    ]\n\n    return segment_relative_dist, edges, is_intersected_at_node\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.data_models.MeshData.get_face_by_index","title":"<code>get_face_by_index(index: int, as_polygon: bool = False) -&gt; np.ndarray | Polygon</code>","text":"<p>Returns the coordinates of the index-th mesh face as an (N, 2) array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The face index.</p> required <code>as_polygon</code> <code>bool</code> <p>whither to return the face as a shapely polygon or not. Default is False</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray | Polygon</code> <p>np.ndarray: Array of shape (n_nodes, 2) with x, y coordinates.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/data_models.py</code> <pre><code>def get_face_by_index(self, index: int, as_polygon: bool = False) -&gt; np.ndarray | Polygon:\n    \"\"\"Returns the coordinates of the index-th mesh face as an (N, 2) array.\n\n    Args:\n        index:\n            The face index.\n        as_polygon:\n            whither to return the face as a shapely polygon or not. Default is False\n\n    Returns:\n        np.ndarray:\n            Array of shape (n_nodes, 2) with x, y coordinates.\n    \"\"\"\n    x = self.x_face_coords[index : index + 1, : self.n_nodes[index]]\n    y = self.y_face_coords[index : index + 1, : self.n_nodes[index]]\n    face = np.concatenate((x, y), axis=0).T\n\n    if as_polygon:\n        face = Polygon(face)\n    return face\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.data_models.MeshData.locate_point","title":"<code>locate_point(point: Point | np.ndarray | list | Tuple, face_index: int | np.ndarray) -&gt; int | List[int]</code>","text":"<p>Locate a point in the mesh faces.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point | ndarray | list | Tuple</code> <p>The point to check.</p> required <code>face_index</code> <code>int | ndarray</code> <p>The index of the mesh face.</p> required <p>Returns:</p> Name Type Description <code>indexes</code> <code>int | list[int]</code> <p>index if the face that the point is located in, or a list of indexes if the point is on the edge of multiple faces.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/data_models.py</code> <pre><code>def locate_point(\n    self, point: Point | np.ndarray | list | Tuple, face_index: int | np.ndarray\n) -&gt; int | List[int]:\n    \"\"\"Locate a point in the mesh faces.\n\n    Args:\n        point:\n            The point to check.\n        face_index:\n            The index of the mesh face.\n\n    Returns:\n        indexes (int|list[int]):\n            index if the face that the point is located in, or a list of indexes if the point is on the edge of\n            multiple faces.\n    \"\"\"\n    if not isinstance(point, Point) and isinstance(\n        point, (list, tuple, np.ndarray)\n    ):\n        point = Point(point)\n    else:\n        raise TypeError(\n            \"point must be a Point object, a list, a tuple, or an np.ndarray of coordinates\"\n        )\n\n    index_list = []\n    for ind in face_index:\n        face = self.get_face_by_index(ind)\n        face_polygon = Polygon(face)\n        if face_polygon.contains(point):\n            return ind\n        else:\n            # create a closed line string from the face coordinates\n            closed_line = LineString(np.vstack([face, face[0]]))\n            if closed_line.contains(point):\n                index_list.append(ind)\n\n    return index_list\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.data_models.MeshData.resolve_next_face_from_edges","title":"<code>resolve_next_face_from_edges(node, edges: Edges, verbose_index: int = None) -&gt; int</code>","text":"<p>Helper to resolve the next face index when traversing between two edges at a node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>int</code> <p>The node index.</p> required <code>edges</code> <code>Edges</code> <p>The edges connecting the node, containing left and right edge indices.</p> required <code>verbose_index</code> <code>int</code> <p>Step index for verbose output.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>next_face_index</code> <code>int</code> <p>The next face index.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/data_models.py</code> <pre><code>def resolve_next_face_from_edges(\n    self, node, edges: Edges, verbose_index: int = None\n) -&gt; int:\n    \"\"\"\n    Helper to resolve the next face index when traversing between two edges at a node.\n\n    Args:\n        node (int): The node index.\n        edges (Edges):\n            The edges connecting the node, containing left and right edge indices.\n        verbose_index (int, optional):\n            Step index for verbose output.\n\n    Returns:\n        next_face_index (int):\n            The next face index.\n    \"\"\"\n    left_faces = self.edge_face_connectivity[edges.left, :]\n    right_faces = self.edge_face_connectivity[edges.right, :]\n\n    if left_faces[0] in right_faces and left_faces[1] in right_faces:\n        fn1 = self.face_node[left_faces[0]]\n        fe1 = self.face_edge_connectivity[left_faces[0]]\n\n        if self.verbose and verbose_index is not None:\n            print(\n                f\"{verbose_index}: those edges are shared by two faces: {left_faces}\"\n            )\n            print(f\"{verbose_index}: face {left_faces[0]} has nodes: {fn1}\")\n            print(f\"{verbose_index}: face {left_faces[0]} has edges: {fe1}\")\n\n        # nodes of the face should be listed in clockwise order\n        # edges[i] is the edge connecting node[i-1] with node[i]\n        # the latter is guaranteed by batch.derive_topology_arrays\n        if fe1[fn1 == node] == edges.right:\n            next_face_index = left_faces[0]\n        else:\n            next_face_index = left_faces[1]\n\n    elif left_faces[0] in right_faces:\n        next_face_index = left_faces[0]\n    elif left_faces[1] in right_faces:\n        next_face_index = left_faces[1]\n    else:\n        raise ValueError(\n            f\"Shouldn't come here .... left edge {edges.left}\"\n            f\" and right edge {edges.right} don't share any face\"\n        )\n    return next_face_index\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.data_models.RiverSegment","title":"<code>RiverSegment</code>  <code>dataclass</code>","text":"<p>Represents a segment of a river line.</p> <p>Parameters:</p> Name Type Description Default <code>min_relative_distance</code> <code>float</code> <p>The relative distance along the previous segment where the last intersection occurred. Used to filter intersections along the current segment.</p> required <code>current_point</code> <code>ndarray</code> <p>A 1D array of shape (2,) containing the x, y coordinates of the current point of the line segment.</p> required <code>previous_point</code> <code>ndarray</code> <p>A 1D array of shape (2,) containing the x, y coordinates of the previous point of the line segment.</p> required Source code in <code>src/dfastbe/bank_erosion/mesh/data_models.py</code> <pre><code>@dataclass\nclass RiverSegment:\n    \"\"\"Represents a segment of a river line.\n\n    Args:\n        min_relative_distance (float):\n            The relative distance along the previous segment where the last intersection occurred. Used to filter\n            intersections along the current segment.\n        current_point (np.ndarray):\n            A 1D array of shape (2,) containing the x, y coordinates of the current point of the line segment.\n        previous_point (np.ndarray):\n            A 1D array of shape (2,) containing the x, y coordinates of the previous point of the line segment.\n    \"\"\"\n\n    index: int\n    min_relative_distance: float\n    current_point: np.ndarray\n    previous_point: np.ndarray\n    distances: np.ndarray = field(default_factory=lambda: np.zeros(0))\n    edges: np.ndarray = field(default_factory=lambda: np.zeros(0, dtype=np.int64))\n    nodes: np.ndarray = field(default_factory=lambda: np.zeros(0, dtype=np.int64))\n\n    def is_length_zero(self) -&gt; bool:\n        \"\"\"Check if the segment has zero length.\"\"\"\n        return np.array_equal(self.current_point, self.previous_point)\n\n    @property\n    def theta(self):\n        \"\"\"Calculate the angle of the segment in radians.\"\"\"\n        theta = math.atan2(\n            self.current_point[1] - self.previous_point[1],\n            self.current_point[0] - self.previous_point[0],\n        )\n        return theta\n\n    def select_first_intersection(self):\n        \"\"\"Select the first crossing from a set of edges and their associated distances.\n\n        line segment crosses the edge list multiple times\n            - moving out of a cell at a corner node\n            - moving into and out of the mesh from outside\n        \"\"\"\n        # get the minimum distance from the distances array\n        min_distance_indices = self.distances == np.amin(self.distances)\n        self.distances = self.distances[min_distance_indices]\n        self.edges = self.edges[min_distance_indices]\n        self.nodes = self.nodes[min_distance_indices]\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.data_models.RiverSegment.theta","title":"<code>theta</code>  <code>property</code>","text":"<p>Calculate the angle of the segment in radians.</p>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.data_models.RiverSegment.is_length_zero","title":"<code>is_length_zero() -&gt; bool</code>","text":"<p>Check if the segment has zero length.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/data_models.py</code> <pre><code>def is_length_zero(self) -&gt; bool:\n    \"\"\"Check if the segment has zero length.\"\"\"\n    return np.array_equal(self.current_point, self.previous_point)\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.data_models.RiverSegment.select_first_intersection","title":"<code>select_first_intersection()</code>","text":"<p>Select the first crossing from a set of edges and their associated distances.</p> <p>line segment crosses the edge list multiple times     - moving out of a cell at a corner node     - moving into and out of the mesh from outside</p> Source code in <code>src/dfastbe/bank_erosion/mesh/data_models.py</code> <pre><code>def select_first_intersection(self):\n    \"\"\"Select the first crossing from a set of edges and their associated distances.\n\n    line segment crosses the edge list multiple times\n        - moving out of a cell at a corner node\n        - moving into and out of the mesh from outside\n    \"\"\"\n    # get the minimum distance from the distances array\n    min_distance_indices = self.distances == np.amin(self.distances)\n    self.distances = self.distances[min_distance_indices]\n    self.edges = self.edges[min_distance_indices]\n    self.nodes = self.nodes[min_distance_indices]\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#mesh-processing","title":"Mesh Processing","text":"<p>For more details, see Bank Erosion Mesh Processor.</p>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.processor","title":"<code>dfastbe.bank_erosion.mesh.processor</code>","text":"<p>module for processing mesh-related operations.</p>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.processor.IntersectionState","title":"<code>IntersectionState</code>  <code>dataclass</code>","text":"Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>@dataclass\nclass IntersectionState:\n    coords = np.ndarray\n    face_indexes = np.ndarray\n    point_index = 0\n    current_face_index: int\n    vertex_index: np.ndarray | int\n\n    def __init__(self, shape: Tuple[int, int] = (100, 2), verbose: bool = False):\n        \"\"\"Initialize the intersection results with given shape.\"\"\"\n        self.coords = np.zeros(shape, dtype=np.float64)\n        self.face_indexes = np.zeros(shape[0], dtype=np.int64)\n        self.point_index = 0\n        self.current_face_index: int = -1\n        self.verbose = verbose\n\n    def update(self, current_bank_point, shape_length: bool = None):\n        \"\"\"Finalize a segment\n\n        Enlarge arrays if needed, set coordinates and index, and increment ind.\n        \"\"\"\n        shape_length = self.point_index + 1 if shape_length is None else shape_length\n\n        if self.point_index == self.coords.shape[0]:\n            # last coordinate reached, so enlarge arrays\n            self.coords = enlarge(self.coords, (shape_length, 2))\n            self.face_indexes = enlarge(self.face_indexes, (shape_length,))\n\n        self.coords[self.point_index] = current_bank_point\n\n        if self.current_face_index == -2:\n            self.face_indexes[self.point_index] = self.vertex_index[0]\n        else:\n            self.face_indexes[self.point_index] = self.current_face_index\n        self.point_index += 1\n\n    def _log_mesh_transition(self, log_status: Status):\n        \"\"\"Helper to print mesh transition information for debugging.\"\"\"\n        index_str = \"outside\" if self.current_face_index == -1 else self.current_face_index\n        if self.current_face_index == -2:\n            index_str = f\"edge between {self.vertex_index}\"\n\n        log_status.print(index_str)\n\n    def _update_main_attributes(self, log_status):\n        if self.verbose:\n            log_status.transition_type = \"node\"\n            self._log_mesh_transition(log_status)\n\n        face_indexes = log_status.face_index\n        if isinstance(face_indexes, (int, np.integer)):\n            self.current_face_index = face_indexes\n        elif hasattr(face_indexes, \"__len__\") and len(face_indexes) == 1:\n            self.current_face_index = face_indexes[0]\n        else:\n            self.current_face_index = -2\n            self.vertex_index = face_indexes\n\n    def update_index_and_log(self, status: Status, edge, faces):\n        \"\"\"\n        Helper to update mesh index and log transitions for intersect_line_mesh.\n        \"\"\"\n        if status.face_index is not None:\n            self._update_main_attributes(status)\n            return\n\n        status.transition_type = \"edge\"\n        status.transition_index = edge\n\n        for i, face in enumerate(faces):\n            if face == self.current_face_index:\n                other_face = faces[1 - i]\n                if self.verbose:\n                    status.face_index = other_face\n                    self._log_mesh_transition(status)\n                self.current_face_index = other_face\n                return\n\n        raise ValueError(\n            f\"Shouldn't come here .... index {self.current_face_index} differs from both faces \"\n            f\"{faces[0]} and {faces[1]} associated with slicing edge {edge}\"\n        )\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.processor.IntersectionState.__init__","title":"<code>__init__(shape: Tuple[int, int] = (100, 2), verbose: bool = False)</code>","text":"<p>Initialize the intersection results with given shape.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>def __init__(self, shape: Tuple[int, int] = (100, 2), verbose: bool = False):\n    \"\"\"Initialize the intersection results with given shape.\"\"\"\n    self.coords = np.zeros(shape, dtype=np.float64)\n    self.face_indexes = np.zeros(shape[0], dtype=np.int64)\n    self.point_index = 0\n    self.current_face_index: int = -1\n    self.verbose = verbose\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.processor.IntersectionState.update","title":"<code>update(current_bank_point, shape_length: bool = None)</code>","text":"<p>Finalize a segment</p> <p>Enlarge arrays if needed, set coordinates and index, and increment ind.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>def update(self, current_bank_point, shape_length: bool = None):\n    \"\"\"Finalize a segment\n\n    Enlarge arrays if needed, set coordinates and index, and increment ind.\n    \"\"\"\n    shape_length = self.point_index + 1 if shape_length is None else shape_length\n\n    if self.point_index == self.coords.shape[0]:\n        # last coordinate reached, so enlarge arrays\n        self.coords = enlarge(self.coords, (shape_length, 2))\n        self.face_indexes = enlarge(self.face_indexes, (shape_length,))\n\n    self.coords[self.point_index] = current_bank_point\n\n    if self.current_face_index == -2:\n        self.face_indexes[self.point_index] = self.vertex_index[0]\n    else:\n        self.face_indexes[self.point_index] = self.current_face_index\n    self.point_index += 1\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.processor.IntersectionState.update_index_and_log","title":"<code>update_index_and_log(status: Status, edge, faces)</code>","text":"<p>Helper to update mesh index and log transitions for intersect_line_mesh.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>def update_index_and_log(self, status: Status, edge, faces):\n    \"\"\"\n    Helper to update mesh index and log transitions for intersect_line_mesh.\n    \"\"\"\n    if status.face_index is not None:\n        self._update_main_attributes(status)\n        return\n\n    status.transition_type = \"edge\"\n    status.transition_index = edge\n\n    for i, face in enumerate(faces):\n        if face == self.current_face_index:\n            other_face = faces[1 - i]\n            if self.verbose:\n                status.face_index = other_face\n                self._log_mesh_transition(status)\n            self.current_face_index = other_face\n            return\n\n    raise ValueError(\n        f\"Shouldn't come here .... index {self.current_face_index} differs from both faces \"\n        f\"{faces[0]} and {faces[1]} associated with slicing edge {edge}\"\n    )\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.processor.MeshProcessor","title":"<code>MeshProcessor</code>","text":"<p>Class to process bank lines and intersect them with a mesh.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>class MeshProcessor:\n    \"\"\"Class to process bank lines and intersect them with a mesh.\"\"\"\n\n    def __init__(self, river_data: ErosionRiverData, mesh_data: MeshData, verbose: bool = False):\n        \"\"\"Constructor for MeshProcessor.\"\"\"\n        self.bank_lines = river_data.bank_lines\n        self.mesh_data = mesh_data\n        self.river_data = river_data\n        self.wrapper = MeshWrapper(mesh_data, verbose=verbose)\n\n    def get_fairway_data(self, river_axis: LineGeometry) -&gt; FairwayData:\n        LogData().log_text(\"chainage_to_fairway\")\n        # intersect fairway and mesh\n        fairway_intersection_coords, fairway_face_indices = self.wrapper.intersect_with_coords(river_axis.as_array())\n\n        if self.river_data.debug:\n            arr = (fairway_intersection_coords[:-1] + fairway_intersection_coords[1:]) / 2\n            line_geom = LineGeometry(arr, crs=river_axis.crs)\n            line_geom.to_file(\n                file_name=f\"{str(self.river_data.output_dir)}/fairway_face_indices.shp\",\n                data={\"iface\": fairway_face_indices},\n            )\n\n        return FairwayData(fairway_face_indices, fairway_intersection_coords)\n\n    def get_bank_data(self) -&gt; BankData:\n        \"\"\"Intersect bank lines with a mesh and return bank data.\n\n        Returns:\n            BankData object containing bank line coordinates, face indices, and other bank-related data.\n        \"\"\"\n        n_bank_lines = len(self.bank_lines)\n\n        bank_line_coords = []\n        bank_face_indices = []\n        for bank_index in range(n_bank_lines):\n            line_coords = np.array(self.bank_lines.geometry[bank_index].coords)\n            LogData().log_text(\"bank_nodes\", data={\"ib\": bank_index + 1, \"n\": len(line_coords)})\n\n            coords_along_bank, face_indices = self.wrapper.intersect_with_coords(line_coords)\n            bank_line_coords.append(coords_along_bank)\n            bank_face_indices.append(face_indices)\n\n        bank_order, data = self._link_lines_to_stations(bank_line_coords, bank_face_indices)\n\n        return BankData.from_column_arrays(\n            data,\n            SingleBank,\n            bank_lines=self.bank_lines,\n            n_bank_lines=n_bank_lines,\n            bank_order=bank_order,\n        )\n\n    def _link_lines_to_stations(self, bank_line_coords, bank_face_indices):\n        # linking bank lines to chainage\n        LogData().log_text(\"chainage_to_banks\")\n        river_center_line = self.river_data.river_center_line.as_array()\n        n_bank_lines = len(self.bank_lines)\n\n        bank_chainage_midpoints = [None] * n_bank_lines\n        is_right_bank = [True] * n_bank_lines\n        for bank_index, coords in enumerate(bank_line_coords):\n            segment_mid_points = LineGeometry((coords[:-1, :] + coords[1:, :]) / 2)\n            chainage_mid_points = segment_mid_points.intersect_with_line(\n                river_center_line\n            )\n\n            # check if the bank line is defined from low chainage to high chainage\n            if chainage_mid_points[0] &gt; chainage_mid_points[-1]:\n                # if not, flip the bank line and all associated data\n                chainage_mid_points = chainage_mid_points[::-1]\n                bank_line_coords[bank_index] = bank_line_coords[bank_index][::-1, :]\n                bank_face_indices[bank_index] = bank_face_indices[bank_index][::-1]\n\n            bank_chainage_midpoints[bank_index] = chainage_mid_points\n\n            # check if the bank line is a left or right bank\n            # when looking from low-to-high chainage\n            is_right_bank[bank_index] = on_right_side(\n                coords, river_center_line[:, :2]\n            )\n            if is_right_bank[bank_index]:\n                LogData().log_text(\"right_side_bank\", data={\"ib\": bank_index + 1})\n            else:\n                LogData().log_text(\"left_side_bank\", data={\"ib\": bank_index + 1})\n\n        bank_order = tuple(\"right\" if val else \"left\" for val in is_right_bank)\n        data = {\n            'is_right_bank': is_right_bank,\n            'bank_line_coords': bank_line_coords,\n            'bank_face_indices': bank_face_indices,\n            'bank_chainage_midpoints': bank_chainage_midpoints\n        }\n        return bank_order, data\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.processor.MeshProcessor.__init__","title":"<code>__init__(river_data: ErosionRiverData, mesh_data: MeshData, verbose: bool = False)</code>","text":"<p>Constructor for MeshProcessor.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>def __init__(self, river_data: ErosionRiverData, mesh_data: MeshData, verbose: bool = False):\n    \"\"\"Constructor for MeshProcessor.\"\"\"\n    self.bank_lines = river_data.bank_lines\n    self.mesh_data = mesh_data\n    self.river_data = river_data\n    self.wrapper = MeshWrapper(mesh_data, verbose=verbose)\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.processor.MeshProcessor.get_bank_data","title":"<code>get_bank_data() -&gt; BankData</code>","text":"<p>Intersect bank lines with a mesh and return bank data.</p> <p>Returns:</p> Type Description <code>BankData</code> <p>BankData object containing bank line coordinates, face indices, and other bank-related data.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>def get_bank_data(self) -&gt; BankData:\n    \"\"\"Intersect bank lines with a mesh and return bank data.\n\n    Returns:\n        BankData object containing bank line coordinates, face indices, and other bank-related data.\n    \"\"\"\n    n_bank_lines = len(self.bank_lines)\n\n    bank_line_coords = []\n    bank_face_indices = []\n    for bank_index in range(n_bank_lines):\n        line_coords = np.array(self.bank_lines.geometry[bank_index].coords)\n        LogData().log_text(\"bank_nodes\", data={\"ib\": bank_index + 1, \"n\": len(line_coords)})\n\n        coords_along_bank, face_indices = self.wrapper.intersect_with_coords(line_coords)\n        bank_line_coords.append(coords_along_bank)\n        bank_face_indices.append(face_indices)\n\n    bank_order, data = self._link_lines_to_stations(bank_line_coords, bank_face_indices)\n\n    return BankData.from_column_arrays(\n        data,\n        SingleBank,\n        bank_lines=self.bank_lines,\n        n_bank_lines=n_bank_lines,\n        bank_order=bank_order,\n    )\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.processor.MeshWrapper","title":"<code>MeshWrapper</code>","text":"<p>A class for processing mesh-related operations.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>class MeshWrapper:\n    \"\"\"A class for processing mesh-related operations.\"\"\"\n\n    def __init__(\n        self, mesh_data: MeshData, d_thresh: float = 0.001, verbose: bool = False\n    ):\n        self.mesh_data = mesh_data\n        self.d_thresh = d_thresh\n        self.verbose = verbose\n\n    def _read_target_object(self, xy_coords):\n        self.given_coords = xy_coords\n        self.intersection_state = IntersectionState(xy_coords.shape, self.verbose)\n\n    def _handle_first_point(self, current_bank_point: np.ndarray):\n        # get the point on the mesh face that is closest to the first bank point\n        dx = self.mesh_data.x_face_coords - current_bank_point[0]\n        dy = self.mesh_data.y_face_coords - current_bank_point[1]\n        closest_cell_ind = np.nonzero(\n            ~(\n                (dx &lt; 0).all(axis=1)\n                | (dx &gt; 0).all(axis=1)\n                | (dy &lt; 0).all(axis=1)\n                | (dy &gt; 0).all(axis=1)\n            )\n        )[0]\n        index, vindex = self._find_starting_face(closest_cell_ind)\n        self.intersection_state.current_face_index = index\n        self.intersection_state.vertex_index = vindex\n        self.intersection_state.update(current_bank_point)\n\n    def _find_starting_face(self, face_indexes: np.ndarray):\n        \"\"\"Find the starting face for a bank line segment.\n\n        This function determines the face index and vertex indices of the mesh\n        that the first point of a bank line segment is associated with.\n\n        Args:\n            face_indexes (np.ndarray): Array of possible cell indices.\n        \"\"\"\n        if len(face_indexes) == 0 and self.verbose:\n            print(\"starting outside mesh\")\n\n        edges_indexes = self.mesh_data.locate_point(self.given_coords[0], face_indexes)\n        if not isinstance(edges_indexes, list):\n            # A single index was returned\n            index = edges_indexes\n            vindex = None\n        else:\n            # A list of indices is expected\n            if edges_indexes:\n                if self.verbose:\n                    print(f\"starting on edge of {edges_indexes}\")\n\n                index = -2 if len(edges_indexes) &gt; 1 else edges_indexes[0]\n                vindex = edges_indexes if len(edges_indexes) &gt; 1 else None\n            else:\n                if self.verbose:\n                    print(\"starting outside mesh\")\n                index = -1\n                vindex = None\n\n        return index, vindex\n\n    def _log_slice_status(self, j, prev_b, bpj):\n        if prev_b &gt; 0:\n            print(f\"{j}: -- no further slices along this segment --\")\n        else:\n            print(f\"{j}: -- no slices along this segment --\")\n\n        if self.intersection_state.current_face_index &gt;= 0:\n            pnt = Point(bpj)\n            polygon_k = self.mesh_data.get_face_by_index(self.intersection_state.current_face_index, as_polygon=True)\n\n            if not polygon_k.contains(pnt):\n                raise ValueError(\n                    f\"{j}: ERROR: point actually not contained within {self.intersection_state.current_face_index}!\"\n                )\n\n    def _process_node_transition(self, segment: RiverSegment, node):\n        \"\"\"Process the transition at a node when a segment ends or continues.\"\"\"\n        finished = False\n\n        if self.verbose:\n            print(\n                f\"{segment.index}: moving via node {node} on edges {segment.edges} at {segment.distances[0]}\"\n            )\n\n        # figure out where we will be heading afterwards ...\n        if segment.distances[0] &lt; 1.0:\n            # segment passes through node and enter non-neighbouring cell ...\n            # direction of current segment from bpj1 to bpj\n            theta = segment.theta\n        else:\n            if (\n                np.isclose(segment.distances[0], 1.0, rtol=RTOL, atol=ATOL)\n                and segment.index == len(self.given_coords) - 1\n            ):\n                # catch case of last segment\n                if self.verbose:\n                    print(f\"{segment.index}: last point ends in a node\")\n\n                self.intersection_state.update(segment.current_point)\n                theta = 0.0\n                finished = True\n            else:\n                # this segment ends in the node, so check next segment ...\n                # direction of next segment from bpj to bp[j+1]\n                theta = math.atan2(\n                    self.given_coords[segment.index + 1][1]\n                    - segment.current_point[1],\n                    self.given_coords[segment.index + 1][0]\n                    - segment.current_point[0],\n                )\n        next_face_index = None\n        if not finished:\n            next_face_index = self.mesh_data.resolve_next_face_by_direction(\n                theta, node, segment.index\n            )\n        return False, next_face_index\n\n    def _slice_by_node_or_edge(\n        self, segment: RiverSegment, node, edge, faces\n    ):\n        finished = False\n        next_face_index = None\n        if node &gt;= 0:\n            # if we slice at a node ...\n            finished, next_face_index = self._process_node_transition(segment, node)\n\n        elif segment.distances[0] == 1:\n            # ending at slice point, so ending on an edge ...\n            if self.verbose:\n                print(\n                    f\"{segment.index}: ending on edge {edge} at {segment.distances[0]}\"\n                )\n            # figure out where we will be heading afterwards ...\n            if segment.index == len(self.given_coords) - 1:\n                # catch case of last segment\n                if self.verbose:\n                    print(f\"{segment.index}: last point ends on an edge\")\n                self.intersection_state.update(segment.current_point)\n                finished = True\n            else:\n                next_point = [self.given_coords[segment.index + 1][0], self.given_coords[segment.index + 1][1]]\n                next_face_index = self.determine_next_face_on_edge(segment, next_point, edge, faces)\n\n        return finished, next_face_index\n\n    def _process_bank_segment(self, segment: RiverSegment):\n\n        while True:\n            if self.intersection_state.current_face_index == -2:\n                index_src = self._resolve_ambiguous_edge_transition(segment, self.intersection_state.vertex_index)\n\n                if len(index_src) == 1:\n                    self.intersection_state.current_face_index = index_src[0]\n                    self.intersection_state.vertex_index = index_src[0:1]\n                else:\n                    self.intersection_state.current_face_index = -2\n\n            elif segment.is_length_zero():\n                # segment has zero length\n                break\n            else:\n                segment.distances, segment.edges, segment.nodes = (\n                    self.mesh_data.find_segment_intersections(\n                        self.intersection_state.current_face_index,\n                        segment,\n                    )\n                )\n\n            if len(segment.edges) == 0:\n                # rest of segment associated with same face\n                shape_length = self.intersection_state.point_index * SHAPE_MULTIPLIER\n                self.intersection_state.update(\n                    segment.current_point, shape_length=shape_length\n                )\n                break\n\n            if len(segment.edges) &gt; 1:\n                segment.select_first_intersection()\n\n            # slice location identified ...   (number of edges should be 1)\n            node = segment.nodes[0]\n            edge = segment.edges[0]\n            faces = self.mesh_data.edge_face_connectivity[edge]\n            segment.min_relative_distance = segment.distances[0]\n\n            finished, face_index = self._slice_by_node_or_edge(\n                segment,\n                node,\n                edge,\n                faces,\n            )\n            if finished:\n                break\n\n            status = Status(**{\n                \"step\": segment.index,\n                \"transition_index\": node,\n                \"face_index\": face_index,\n                \"prev_b\": segment.min_relative_distance,\n            })\n            self.intersection_state.update_index_and_log(status, edge, faces)\n            segment_x = (\n                    segment.previous_point\n                    + segment.min_relative_distance\n                    * (segment.current_point - segment.previous_point)\n            )\n            shape_length = self.intersection_state.point_index * SHAPE_MULTIPLIER\n            self.intersection_state.update(segment_x, shape_length=shape_length)\n            if segment.min_relative_distance == 1:\n                break\n\n    def _resolve_ambiguous_edge_transition(self, segment: RiverSegment, vindex):\n        \"\"\"Resolve ambiguous edge transitions when a line segment is on the edge of multiple mesh faces.\"\"\"\n        b = np.zeros(0)\n        edges = np.zeros(0, dtype=np.int64)\n        nodes = np.zeros(0, dtype=np.int64)\n        index_src = np.zeros(0, dtype=np.int64)\n\n        for i in vindex:\n            b1, edges1, nodes1 = self.mesh_data.find_segment_intersections(i, segment)\n            b = np.concatenate((b, b1), axis=0)\n            edges = np.concatenate((edges, edges1), axis=0)\n            nodes = np.concatenate((nodes, nodes1), axis=0)\n            index_src = np.concatenate((index_src, i + 0 * edges1), axis=0)\n\n        segment.edges, id_edges = np.unique(edges, return_index=True)\n        segment.distances = b[id_edges]\n        segment.nodes = nodes[id_edges]\n        index_src = index_src[id_edges]\n\n        return index_src\n\n    def resolve_next_face_by_direction(\n            self, theta: float, node, verbose_index: int = None\n    ):\n        \"\"\"Helper to resolve the next face index based on the direction theta at a node.\"\"\"\n\n        if self.verbose:\n            print(f\"{verbose_index}: moving in direction theta = {theta}\")\n\n        edges = self.mesh_data.find_edges(theta, node, verbose_index)\n\n        if self.verbose:\n            print(f\"{verbose_index}: the edge to the left is edge {edges.left}\")\n            print(f\"{verbose_index}: the edge to the right is edge {edges.right}\")\n\n        if edges.left == edges.right:\n            if self.verbose:\n                print(f\"{verbose_index}: continue along edge {edges.left}\")\n\n            next_face_index = self.mesh_data.edge_face_connectivity[edges.left, :]\n        else:\n            if self.verbose:\n                print(\n                    f\"{verbose_index}: continue between edges {edges.left}\"\n                    f\" on the left and {edges.right} on the right\"\n                )\n            next_face_index = self.mesh_data.resolve_next_face_from_edges(\n                node, edges, verbose_index\n            )\n        return next_face_index\n\n    def determine_next_face_on_edge(\n        self, segment: RiverSegment, next_point: List[float], edge, faces,\n    ):\n        \"\"\"Determine the next face to continue along an edge based on the segment direction.\"\"\"\n        theta = math.atan2(\n            next_point[1] - segment.current_point[1],\n            next_point[0] - segment.current_point[0],\n            )\n        if self.verbose:\n            print(f\"{segment.index}: moving in direction theta = {theta}\")\n\n        theta_edge = self.mesh_data.calculate_edge_angle(edge)\n        if theta == theta_edge or theta == -theta_edge:\n            if self.verbose:\n                print(f\"{segment.index}: continue along edge {edge}\")\n            next_face_index = faces\n        else:\n            # check whether the (extended) segment slices any edge of faces[0]\n            fe1 = self.mesh_data.face_edge_connectivity[faces[0]]\n            reversed_segment = RiverSegment(\n                index=segment.index,\n                previous_point=segment.current_point,\n                current_point=next_point,\n                min_relative_distance=0,\n            )\n            _, _, edges = self.mesh_data.calculate_edge_intersections(\n                fe1,\n                reversed_segment,\n                False,\n            )\n            # yes, a slice (typically 1, but could be 2 if it slices at a node\n            # but that doesn't matter) ... so, we continue towards faces[0]\n            # if there are no slices for faces[0], we continue towards faces[1]\n            next_face_index = faces[0] if len(edges) &gt; 0 else faces[1]\n        return next_face_index\n\n    def intersect_with_coords(self, given_coords: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Intersects a coords with an unstructured mesh and returns the intersection coordinates and mesh face indices.\n\n        This function determines where a given line (e.g., a bank line) intersects the faces of an unstructured mesh.\n        It calculates the intersection points and identifies the mesh faces corresponding to each segment of the line.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray]:\n                A tuple containing:\n                - `coords` (np.ndarray):\n                    A 2D array of shape (M, 2) containing the x, y coordinates of the intersection points.\n                - `idx` (np.ndarray):\n                    A 1D array of shape (M-1,) containing the indices of the mesh faces corresponding to each segment\n                    of the intersected line.\n\n        Raises:\n            Exception:\n                If the line starts outside the mesh and cannot be associated with any mesh face, or if the line crosses\n                ambiguous regions (e.g., edges shared by multiple faces).\n\n        Notes:\n            - The function uses Shapely geometry operations to determine whether points are inside polygons or on edges.\n            - The function handles cases where the line starts outside the mesh, crosses multiple edges, or ends on a node.\n            - Tiny segments shorter than `d_thresh` are removed from the output.\n        \"\"\"\n        self._read_target_object(given_coords)\n        for point_index, current_bank_point in enumerate(given_coords):\n            if self.verbose:\n                print(\n                    f\"Current location: {current_bank_point[0]}, {current_bank_point[1]}\"\n                )\n            if point_index == 0:\n                self._handle_first_point(current_bank_point)\n            else:\n                segment = RiverSegment(\n                    index=point_index,\n                    min_relative_distance=0,\n                    current_point=current_bank_point,\n                    previous_point=given_coords[point_index - 1],\n                )\n                self._process_bank_segment(segment)\n\n        # clip to actual length (idx refers to segments, so we can ignore the last value)\n        self.intersection_state.coords = self.intersection_state.coords[: self.intersection_state.point_index]\n        self.intersection_state.face_indexes = self.intersection_state.face_indexes[: self.intersection_state.point_index - 1]\n\n        # remove tiny segments\n        d = np.sqrt((np.diff(self.intersection_state.coords, axis=0) ** 2).sum(axis=1))\n        mask = np.concatenate((np.ones((1), dtype=\"bool\"), d &gt; self.d_thresh))\n        self.intersection_state.coords = self.intersection_state.coords[mask, :]\n        self.intersection_state.face_indexes = self.intersection_state.face_indexes[mask[1:]]\n\n        # since index refers to segments, don't return the first one\n        return self.intersection_state.coords, self.intersection_state.face_indexes\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.processor.MeshWrapper.determine_next_face_on_edge","title":"<code>determine_next_face_on_edge(segment: RiverSegment, next_point: List[float], edge, faces)</code>","text":"<p>Determine the next face to continue along an edge based on the segment direction.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>def determine_next_face_on_edge(\n    self, segment: RiverSegment, next_point: List[float], edge, faces,\n):\n    \"\"\"Determine the next face to continue along an edge based on the segment direction.\"\"\"\n    theta = math.atan2(\n        next_point[1] - segment.current_point[1],\n        next_point[0] - segment.current_point[0],\n        )\n    if self.verbose:\n        print(f\"{segment.index}: moving in direction theta = {theta}\")\n\n    theta_edge = self.mesh_data.calculate_edge_angle(edge)\n    if theta == theta_edge or theta == -theta_edge:\n        if self.verbose:\n            print(f\"{segment.index}: continue along edge {edge}\")\n        next_face_index = faces\n    else:\n        # check whether the (extended) segment slices any edge of faces[0]\n        fe1 = self.mesh_data.face_edge_connectivity[faces[0]]\n        reversed_segment = RiverSegment(\n            index=segment.index,\n            previous_point=segment.current_point,\n            current_point=next_point,\n            min_relative_distance=0,\n        )\n        _, _, edges = self.mesh_data.calculate_edge_intersections(\n            fe1,\n            reversed_segment,\n            False,\n        )\n        # yes, a slice (typically 1, but could be 2 if it slices at a node\n        # but that doesn't matter) ... so, we continue towards faces[0]\n        # if there are no slices for faces[0], we continue towards faces[1]\n        next_face_index = faces[0] if len(edges) &gt; 0 else faces[1]\n    return next_face_index\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.processor.MeshWrapper.intersect_with_coords","title":"<code>intersect_with_coords(given_coords: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]</code>","text":"<p>Intersects a coords with an unstructured mesh and returns the intersection coordinates and mesh face indices.</p> <p>This function determines where a given line (e.g., a bank line) intersects the faces of an unstructured mesh. It calculates the intersection points and identifies the mesh faces corresponding to each segment of the line.</p> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray]: A tuple containing: - <code>coords</code> (np.ndarray):     A 2D array of shape (M, 2) containing the x, y coordinates of the intersection points. - <code>idx</code> (np.ndarray):     A 1D array of shape (M-1,) containing the indices of the mesh faces corresponding to each segment     of the intersected line.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the line starts outside the mesh and cannot be associated with any mesh face, or if the line crosses ambiguous regions (e.g., edges shared by multiple faces).</p> Notes <ul> <li>The function uses Shapely geometry operations to determine whether points are inside polygons or on edges.</li> <li>The function handles cases where the line starts outside the mesh, crosses multiple edges, or ends on a node.</li> <li>Tiny segments shorter than <code>d_thresh</code> are removed from the output.</li> </ul> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>def intersect_with_coords(self, given_coords: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Intersects a coords with an unstructured mesh and returns the intersection coordinates and mesh face indices.\n\n    This function determines where a given line (e.g., a bank line) intersects the faces of an unstructured mesh.\n    It calculates the intersection points and identifies the mesh faces corresponding to each segment of the line.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]:\n            A tuple containing:\n            - `coords` (np.ndarray):\n                A 2D array of shape (M, 2) containing the x, y coordinates of the intersection points.\n            - `idx` (np.ndarray):\n                A 1D array of shape (M-1,) containing the indices of the mesh faces corresponding to each segment\n                of the intersected line.\n\n    Raises:\n        Exception:\n            If the line starts outside the mesh and cannot be associated with any mesh face, or if the line crosses\n            ambiguous regions (e.g., edges shared by multiple faces).\n\n    Notes:\n        - The function uses Shapely geometry operations to determine whether points are inside polygons or on edges.\n        - The function handles cases where the line starts outside the mesh, crosses multiple edges, or ends on a node.\n        - Tiny segments shorter than `d_thresh` are removed from the output.\n    \"\"\"\n    self._read_target_object(given_coords)\n    for point_index, current_bank_point in enumerate(given_coords):\n        if self.verbose:\n            print(\n                f\"Current location: {current_bank_point[0]}, {current_bank_point[1]}\"\n            )\n        if point_index == 0:\n            self._handle_first_point(current_bank_point)\n        else:\n            segment = RiverSegment(\n                index=point_index,\n                min_relative_distance=0,\n                current_point=current_bank_point,\n                previous_point=given_coords[point_index - 1],\n            )\n            self._process_bank_segment(segment)\n\n    # clip to actual length (idx refers to segments, so we can ignore the last value)\n    self.intersection_state.coords = self.intersection_state.coords[: self.intersection_state.point_index]\n    self.intersection_state.face_indexes = self.intersection_state.face_indexes[: self.intersection_state.point_index - 1]\n\n    # remove tiny segments\n    d = np.sqrt((np.diff(self.intersection_state.coords, axis=0) ** 2).sum(axis=1))\n    mask = np.concatenate((np.ones((1), dtype=\"bool\"), d &gt; self.d_thresh))\n    self.intersection_state.coords = self.intersection_state.coords[mask, :]\n    self.intersection_state.face_indexes = self.intersection_state.face_indexes[mask[1:]]\n\n    # since index refers to segments, don't return the first one\n    return self.intersection_state.coords, self.intersection_state.face_indexes\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.mesh.processor.MeshWrapper.resolve_next_face_by_direction","title":"<code>resolve_next_face_by_direction(theta: float, node, verbose_index: int = None)</code>","text":"<p>Helper to resolve the next face index based on the direction theta at a node.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>def resolve_next_face_by_direction(\n        self, theta: float, node, verbose_index: int = None\n):\n    \"\"\"Helper to resolve the next face index based on the direction theta at a node.\"\"\"\n\n    if self.verbose:\n        print(f\"{verbose_index}: moving in direction theta = {theta}\")\n\n    edges = self.mesh_data.find_edges(theta, node, verbose_index)\n\n    if self.verbose:\n        print(f\"{verbose_index}: the edge to the left is edge {edges.left}\")\n        print(f\"{verbose_index}: the edge to the right is edge {edges.right}\")\n\n    if edges.left == edges.right:\n        if self.verbose:\n            print(f\"{verbose_index}: continue along edge {edges.left}\")\n\n        next_face_index = self.mesh_data.edge_face_connectivity[edges.left, :]\n    else:\n        if self.verbose:\n            print(\n                f\"{verbose_index}: continue between edges {edges.left}\"\n                f\" on the left and {edges.right} on the right\"\n            )\n        next_face_index = self.mesh_data.resolve_next_face_from_edges(\n            node, edges, verbose_index\n        )\n    return next_face_index\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#debugging-utilities","title":"Debugging Utilities","text":"<p>For more details, see Bank Erosion Debugger.</p>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.debugger","title":"<code>dfastbe.bank_erosion.debugger</code>","text":"<p>Bank Erosion Debugger.</p>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.debugger.Debugger","title":"<code>Debugger</code>","text":"<p>Class to handle debugging and output of bank erosion calculations.</p> Source code in <code>src/dfastbe/bank_erosion/debugger.py</code> <pre><code>class Debugger:\n    \"\"\"Class to handle debugging and output of bank erosion calculations.\"\"\"\n\n    def __init__(self, crs: str, output_dir: str):\n        \"\"\"Debugger constructor.\"\"\"\n        self.crs = crs\n        self.output_dir = output_dir\n\n    def last_discharge_level(\n        self,\n        bank_index: int,\n        single_bank: SingleBank,\n        fairway_data: FairwayData,\n        erosion_inputs: SingleErosion,\n        single_parameters: SingleParameters,\n        single_calculation: SingleCalculation,\n    ):\n        \"\"\"Write the last discharge level to a shapefile and CSV file.\"\"\"\n        bank_coords_mind = single_bank.get_mid_points()\n        params = {\n            \"chainage\": single_bank.bank_chainage_midpoints,\n            \"x\": bank_coords_mind[:, 0],\n            \"y\": bank_coords_mind[:, 1],\n            \"iface_fw\": single_bank.fairway_face_indices,\n            \"iface_bank\": single_bank.bank_face_indices,\n            \"bank_height\": single_bank.height,\n            \"segment_length\": single_bank.segment_length,\n            \"zw0\": fairway_data.fairway_initial_water_levels[bank_index],\n            \"ship_velocity\": single_parameters.ship_velocity,\n            \"ship_type\": single_parameters.ship_type,\n            \"draught\": single_parameters.ship_draught,\n            \"mu_slp\": single_parameters.mu_slope,\n            \"bank_fairway_dist\": single_bank.fairway_distances,\n            \"fairway_wave_reduction_distance\": erosion_inputs.wave_fairway_distance_0,\n            \"fairway_wave_disappear_distance\": erosion_inputs.wave_fairway_distance_1,\n            \"water_depth_fairway\": single_calculation.water_depth,\n            \"dike_height\": erosion_inputs.bank_protection_level,\n            \"erosion_distance\": single_calculation.erosion_distance_eq,\n            \"erosion_volume\": single_calculation.erosion_volume_eq,\n        }\n\n        path = f\"{str(self.output_dir)}/debug.EQ.B{bank_index + 1}\"\n        bank_coords_geo = single_bank.get_mid_points(as_geo_series=True, crs=self.crs)\n        self._write_data(bank_coords_geo, params, path)\n\n    def middle_levels(\n        self,\n        bank_ind: int,\n        q_level: int,\n        single_bank: SingleBank,\n        fairway_data: FairwayData,\n        erosion_inputs: SingleErosion,\n        single_parameters: SingleParameters,\n        single_calculation: SingleCalculation,\n    ):\n        \"\"\"Write the middle levels to a shapefile and CSV file.\"\"\"\n        bank_coords_mind = single_bank.get_mid_points()\n        params = {\n            \"chainage\": single_bank.bank_chainage_midpoints,\n            \"x\": bank_coords_mind[:, 0],\n            \"y\": bank_coords_mind[:, 1],\n            \"iface_fw\": single_bank.fairway_face_indices,\n            \"iface_bank\": single_bank.bank_face_indices,\n            \"velocity\": single_calculation.bank_velocity,\n            \"bank_height\": single_bank.height,\n            \"segment_length\": single_bank.segment_length,\n            \"zw\": single_calculation.water_level,\n            \"zw0\": fairway_data.fairway_initial_water_levels[bank_ind],\n            \"tauc\": erosion_inputs.tauc,\n            \"num_ship\": single_parameters.num_ship,\n            \"ship_velocity\": single_parameters.ship_velocity,\n            \"num_waves_per_ship\": single_parameters.num_waves_per_ship,\n            \"ship_type\": single_parameters.ship_type,\n            \"draught\": single_parameters.ship_draught,\n            \"mu_slp\": single_parameters.mu_slope,\n            \"mu_reed\": single_parameters.mu_reed,\n            \"dist_fw\": single_bank.fairway_distances,\n            \"fairway_wave_reduction_distance\": erosion_inputs.wave_fairway_distance_0,\n            \"fairway_wave_disappear_distance\": erosion_inputs.wave_fairway_distance_1,\n            \"water_depth_fairway\": single_calculation.water_depth,\n            \"chez\": single_calculation.chezy,\n            \"dike_height\": erosion_inputs.bank_protection_level,\n            \"erosion_distance\": single_calculation.erosion_distance_tot,\n            \"erosion_volume\": single_calculation.erosion_volume_tot,\n            \"erosion_distance_shipping\": single_calculation.erosion_distance_shipping,\n            \"erosion_distance_flow\": single_calculation.erosion_distance_flow,\n        }\n        path = f\"{str(self.output_dir)}/debug.Q{q_level + 1}.B{bank_ind + 1}\"\n        bank_coords_geo = single_bank.get_mid_points(as_geo_series=True, crs=self.crs)\n        self._write_data(bank_coords_geo, params, path)\n\n    @staticmethod\n    def _write_data(coords: GeoSeries, data: Dict[str, np.ndarray], path: str):\n        \"\"\"Write the data to a shapefile and CSV file.\"\"\"\n        csv_path = f\"{path}.csv\"\n        shp_path = f\"{path}.shp\"\n        _write_shp(coords, data, shp_path)\n        _write_csv(data, csv_path)\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.debugger.Debugger.__init__","title":"<code>__init__(crs: str, output_dir: str)</code>","text":"<p>Debugger constructor.</p> Source code in <code>src/dfastbe/bank_erosion/debugger.py</code> <pre><code>def __init__(self, crs: str, output_dir: str):\n    \"\"\"Debugger constructor.\"\"\"\n    self.crs = crs\n    self.output_dir = output_dir\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.debugger.Debugger.last_discharge_level","title":"<code>last_discharge_level(bank_index: int, single_bank: SingleBank, fairway_data: FairwayData, erosion_inputs: SingleErosion, single_parameters: SingleParameters, single_calculation: SingleCalculation)</code>","text":"<p>Write the last discharge level to a shapefile and CSV file.</p> Source code in <code>src/dfastbe/bank_erosion/debugger.py</code> <pre><code>def last_discharge_level(\n    self,\n    bank_index: int,\n    single_bank: SingleBank,\n    fairway_data: FairwayData,\n    erosion_inputs: SingleErosion,\n    single_parameters: SingleParameters,\n    single_calculation: SingleCalculation,\n):\n    \"\"\"Write the last discharge level to a shapefile and CSV file.\"\"\"\n    bank_coords_mind = single_bank.get_mid_points()\n    params = {\n        \"chainage\": single_bank.bank_chainage_midpoints,\n        \"x\": bank_coords_mind[:, 0],\n        \"y\": bank_coords_mind[:, 1],\n        \"iface_fw\": single_bank.fairway_face_indices,\n        \"iface_bank\": single_bank.bank_face_indices,\n        \"bank_height\": single_bank.height,\n        \"segment_length\": single_bank.segment_length,\n        \"zw0\": fairway_data.fairway_initial_water_levels[bank_index],\n        \"ship_velocity\": single_parameters.ship_velocity,\n        \"ship_type\": single_parameters.ship_type,\n        \"draught\": single_parameters.ship_draught,\n        \"mu_slp\": single_parameters.mu_slope,\n        \"bank_fairway_dist\": single_bank.fairway_distances,\n        \"fairway_wave_reduction_distance\": erosion_inputs.wave_fairway_distance_0,\n        \"fairway_wave_disappear_distance\": erosion_inputs.wave_fairway_distance_1,\n        \"water_depth_fairway\": single_calculation.water_depth,\n        \"dike_height\": erosion_inputs.bank_protection_level,\n        \"erosion_distance\": single_calculation.erosion_distance_eq,\n        \"erosion_volume\": single_calculation.erosion_volume_eq,\n    }\n\n    path = f\"{str(self.output_dir)}/debug.EQ.B{bank_index + 1}\"\n    bank_coords_geo = single_bank.get_mid_points(as_geo_series=True, crs=self.crs)\n    self._write_data(bank_coords_geo, params, path)\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.debugger.Debugger.middle_levels","title":"<code>middle_levels(bank_ind: int, q_level: int, single_bank: SingleBank, fairway_data: FairwayData, erosion_inputs: SingleErosion, single_parameters: SingleParameters, single_calculation: SingleCalculation)</code>","text":"<p>Write the middle levels to a shapefile and CSV file.</p> Source code in <code>src/dfastbe/bank_erosion/debugger.py</code> <pre><code>def middle_levels(\n    self,\n    bank_ind: int,\n    q_level: int,\n    single_bank: SingleBank,\n    fairway_data: FairwayData,\n    erosion_inputs: SingleErosion,\n    single_parameters: SingleParameters,\n    single_calculation: SingleCalculation,\n):\n    \"\"\"Write the middle levels to a shapefile and CSV file.\"\"\"\n    bank_coords_mind = single_bank.get_mid_points()\n    params = {\n        \"chainage\": single_bank.bank_chainage_midpoints,\n        \"x\": bank_coords_mind[:, 0],\n        \"y\": bank_coords_mind[:, 1],\n        \"iface_fw\": single_bank.fairway_face_indices,\n        \"iface_bank\": single_bank.bank_face_indices,\n        \"velocity\": single_calculation.bank_velocity,\n        \"bank_height\": single_bank.height,\n        \"segment_length\": single_bank.segment_length,\n        \"zw\": single_calculation.water_level,\n        \"zw0\": fairway_data.fairway_initial_water_levels[bank_ind],\n        \"tauc\": erosion_inputs.tauc,\n        \"num_ship\": single_parameters.num_ship,\n        \"ship_velocity\": single_parameters.ship_velocity,\n        \"num_waves_per_ship\": single_parameters.num_waves_per_ship,\n        \"ship_type\": single_parameters.ship_type,\n        \"draught\": single_parameters.ship_draught,\n        \"mu_slp\": single_parameters.mu_slope,\n        \"mu_reed\": single_parameters.mu_reed,\n        \"dist_fw\": single_bank.fairway_distances,\n        \"fairway_wave_reduction_distance\": erosion_inputs.wave_fairway_distance_0,\n        \"fairway_wave_disappear_distance\": erosion_inputs.wave_fairway_distance_1,\n        \"water_depth_fairway\": single_calculation.water_depth,\n        \"chez\": single_calculation.chezy,\n        \"dike_height\": erosion_inputs.bank_protection_level,\n        \"erosion_distance\": single_calculation.erosion_distance_tot,\n        \"erosion_volume\": single_calculation.erosion_volume_tot,\n        \"erosion_distance_shipping\": single_calculation.erosion_distance_shipping,\n        \"erosion_distance_flow\": single_calculation.erosion_distance_flow,\n    }\n    path = f\"{str(self.output_dir)}/debug.Q{q_level + 1}.B{bank_ind + 1}\"\n    bank_coords_geo = single_bank.get_mid_points(as_geo_series=True, crs=self.crs)\n    self._write_data(bank_coords_geo, params, path)\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#data-models","title":"Data Models","text":"<p>The Bank Erosion module uses several data models to represent inputs, calculation parameters, and results:</p>"},{"location":"api/bank_erosion/bank_erosion.html#calculation-data-models","title":"Calculation Data Models","text":"<p>For more details, see Bank Erosion Calculation Data Models.</p>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation","title":"<code>dfastbe.bank_erosion.data_models.calculation</code>","text":"<p>Erosion-related data structures.</p>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.BankData","title":"<code>BankData</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseBank[SingleBank]</code></p> <p>Class to hold bank-related data.</p> <p>Parameters:</p> Name Type Description Default <code>is_right_bank</code> <code>List[bool]</code> <p>List indicating if the bank is right or not.</p> required <code>bank_chainage_midpoints</code> <code>List[ndarray]</code> <p>River chainage for the midpoints of each segment of the bank line</p> required <code>bank_line_coords</code> <code>List[ndarray]</code> <p>Coordinates of the bank lines.</p> required <code>bank_face_indices</code> <code>List[ndarray]</code> <p>Indices of the faces associated with the banks.</p> required <code>bank_lines</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing the bank lines.</p> <code>GeoDataFrame()</code> <code>n_bank_lines</code> <code>int</code> <p>Number of bank lines.</p> <code>0</code> <code>bank_line_size</code> <code>List[ndarray]</code> <p>Size of each individual bank line.</p> required <code>fairway_distances</code> <code>List[ndarray]</code> <p>The distance of each bank line point to the closest fairway point.</p> required <code>fairway_face_indices</code> <code>List[ndarray]</code> <p>The face index of the closest fairway point for each bank line point.</p> required Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>@dataclass\nclass BankData(BaseBank[SingleBank]):\n    \"\"\"Class to hold bank-related data.\n\n    args:\n        is_right_bank (List[bool]):\n            List indicating if the bank is right or not.\n        bank_chainage_midpoints (List[np.ndarray]):\n            River chainage for the midpoints of each segment of the bank line\n        bank_line_coords (List[np.ndarray]):\n            Coordinates of the bank lines.\n        bank_face_indices (List[np.ndarray]):\n            Indices of the faces associated with the banks.\n        bank_lines (GeoDataFrame):\n            GeoDataFrame containing the bank lines.\n        n_bank_lines (int):\n            Number of bank lines.\n        bank_line_size (List[np.ndarray]):\n            Size of each individual bank line.\n        fairway_distances (List[np.ndarray]):\n            The distance of each bank line point to the closest fairway point.\n        fairway_face_indices (List[np.ndarray]):\n            The face index of the closest fairway point for each bank line point.\n    \"\"\"\n    bank_lines: GeoDataFrame = field(default_factory=GeoDataFrame)\n    n_bank_lines: int = 0\n\n    @classmethod\n    def from_column_arrays(\n        cls,\n        data: dict,\n        bank_cls: Type[\"SingleBank\"],\n        bank_lines: GeoDataFrame,\n        n_bank_lines: int,\n        bank_order: Tuple[str, str] = (\"left\", \"right\")\n    ) -&gt; \"BankData\":\n        # Only include fields that belong to the bank-specific data\n        base_fields = {k: v for k, v in data.items() if k != \"id\"}\n        base = BaseBank.from_column_arrays(\n            {\"id\": data.get(\"id\"), **base_fields}, bank_cls, bank_order=bank_order\n        )\n\n        return cls(\n            id=base.id,\n            left=base.left,\n            right=base.right,\n            bank_lines=bank_lines,\n            n_bank_lines=n_bank_lines,\n        )\n\n    @property\n    def bank_line_coords(self) -&gt; List[np.ndarray]:\n        \"\"\"Get the coordinates of the bank lines.\"\"\"\n        return [self.left.bank_line_coords, self.right.bank_line_coords]\n\n    @property\n    def is_right_bank(self) -&gt; List[bool]:\n        \"\"\"Get the bank direction.\"\"\"\n        return [self.left.is_right_bank, self.right.is_right_bank]\n\n    @property\n    def bank_chainage_midpoints(self) -&gt; List[np.ndarray]:\n        \"\"\"Get the chainage midpoints of the bank lines.\"\"\"\n        return [self.left.bank_chainage_midpoints, self.right.bank_chainage_midpoints]\n\n    @property\n    def num_stations_per_bank(self) -&gt; List[int]:\n        \"\"\"Get the number of stations per bank.\"\"\"\n        return [self.left.length, self.right.length]\n\n    @property\n    def height(self) -&gt; List[np.ndarray]:\n        \"\"\"Get the bank height.\"\"\"\n        return [self.left.height, self.right.height]\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.BankData.bank_chainage_midpoints","title":"<code>bank_chainage_midpoints: List[np.ndarray]</code>  <code>property</code>","text":"<p>Get the chainage midpoints of the bank lines.</p>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.BankData.bank_line_coords","title":"<code>bank_line_coords: List[np.ndarray]</code>  <code>property</code>","text":"<p>Get the coordinates of the bank lines.</p>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.BankData.height","title":"<code>height: List[np.ndarray]</code>  <code>property</code>","text":"<p>Get the bank height.</p>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.BankData.is_right_bank","title":"<code>is_right_bank: List[bool]</code>  <code>property</code>","text":"<p>Get the bank direction.</p>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.BankData.num_stations_per_bank","title":"<code>num_stations_per_bank: List[int]</code>  <code>property</code>","text":"<p>Get the number of stations per bank.</p>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.BaseBank","title":"<code>BaseBank</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[GenericType]</code></p> Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>@dataclass\nclass BaseBank(Generic[GenericType]):\n    left: GenericType\n    right: GenericType\n    id: Optional[int] = field(default=None)\n\n    def get_bank(self, bank_index: int) -&gt; GenericType:\n        if bank_index == 0:\n            return self.left\n        elif bank_index == 1:\n            return self.right\n        else:\n            raise ValueError(\"bank_index must be 0 (left) or 1 (right)\")\n\n    @classmethod\n    def from_column_arrays(\n        cls: Type[\"BaseBank[GenericType]\"],\n        data: Dict[str, Any],\n        bank_cls: Type[GenericType],\n        bank_order: Tuple[str, str] = (\"left\", \"right\")\n    ) -&gt; \"BaseBank[GenericType]\":\n        if set(bank_order) != {\"left\", \"right\"}:\n            raise ValueError(\"bank_order must be a permutation of ('left', 'right')\")\n\n        id_val = data.get(\"id\")\n\n        # Extract the first and second array for each parameter (excluding id)\n        first_args = {}\n        second_args = {}\n        for key, value in data.items():\n            if key == \"id\":\n                continue\n            if not isinstance(value, list) or len(value) != 2:\n                raise ValueError(f\"Expected 2-column array for key '{key}', got shape {value.shape}\")\n\n            split = dict(zip(bank_order, value))\n            first_args[key] = split[\"left\"]\n            second_args[key] = split[\"right\"]\n\n        left = bank_cls(**first_args)\n        right = bank_cls(**second_args)\n\n        return cls(id=id_val, left=left, right=right)\n\n    def __iter__(self) -&gt; Iterator[GenericType]:\n        \"\"\"Iterate over the banks.\"\"\"\n        return iter([self.left, self.right])\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.BaseBank.__iter__","title":"<code>__iter__() -&gt; Iterator[GenericType]</code>","text":"<p>Iterate over the banks.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>def __iter__(self) -&gt; Iterator[GenericType]:\n    \"\"\"Iterate over the banks.\"\"\"\n    return iter([self.left, self.right])\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.DischargeLevels","title":"<code>DischargeLevels</code>","text":"Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>class DischargeLevels:\n\n    def __init__(self, levels: List[SingleDischargeLevel]):\n        self.levels = levels\n\n    def __getitem__(self, index: int) -&gt; SingleDischargeLevel:\n        return self.levels[index]\n\n    def __len__(self) -&gt; int:\n        return len(self.levels)\n\n    def append(self, level_calc: SingleDischargeLevel):\n        self.levels.append(level_calc)\n\n    def get_max_hfw_level(self) -&gt; float:\n        return max(level.hfw_max for level in self.levels)\n\n    def total_erosion_volume(self) -&gt; float:\n        return sum(\n            np.sum(level.left.erosion_volume_tot) + np.sum(level.right.erosion_volume_tot)\n            for level in self.levels\n        )\n\n    def __iter__(self):\n        return iter(self.levels)\n\n    def accumulate(self, attribute_name: str, bank_side: Union[str, List[str]] = None) -&gt; List[np.ndarray]:\n        if bank_side is None:\n            bank_side = [\"left\", \"right\"]\n        elif isinstance(bank_side, str):\n            bank_side = [bank_side]\n\n        if not all(side in [\"left\", \"right\"] for side in bank_side):\n            raise ValueError(\"bank_side must be 'left', 'right', or a list of these.\")\n\n        total = [\n            self._accumulate_attribute_side(attribute_name, side) for side in bank_side\n        ]\n        return total\n\n    def _accumulate_attribute_side(self, attribute_name: str, bank_side: str) -&gt; np.ndarray:\n        for i, level in enumerate(self.levels):\n            bank = getattr(level, bank_side)\n            attr = getattr(bank, attribute_name, None)\n            if attr is None:\n                raise AttributeError(f\"{attribute_name} not found in {bank_side} bank of level with id={level.id}\")\n            if i == 0:\n                total = attr\n            else:\n                total += attr\n        return total\n\n    def _get_attr_both_sides_level(self, attribute_name: str, level) -&gt; List[np.ndarray]:\n        \"\"\"Get the attributes of the levels for both left and right bank.\"\"\"\n        sides = [getattr(self.levels[level], side) for side in [\"left\", \"right\"]]\n        attr = [getattr(side, attribute_name, None) for side in sides]\n        return attr\n\n    def get_attr_level(self, attribute_name: str) -&gt; List[List[np.ndarray]]:\n        \"\"\"Get the attributes of the levels for both left and right bank.\"\"\"\n        return [self._get_attr_both_sides_level(attribute_name, level) for level in range(len(self.levels))]\n\n    def get_water_level_data(self) -&gt; WaterLevelData:\n        return WaterLevelData(\n            hfw_max=self.levels[-1].hfw_max,\n            water_level=self.get_attr_level(\"water_level\"),\n            ship_wave_max=self.get_attr_level(\"ship_wave_max\"),\n            ship_wave_min=self.get_attr_level(\"ship_wave_min\"),\n            velocity=self.get_attr_level(\"bank_velocity\"),\n            chezy=self.get_attr_level(\"chezy\"),\n            vol_per_discharge=self.get_attr_level(\"volume_per_discharge\"),\n        )\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.DischargeLevels.get_attr_level","title":"<code>get_attr_level(attribute_name: str) -&gt; List[List[np.ndarray]]</code>","text":"<p>Get the attributes of the levels for both left and right bank.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>def get_attr_level(self, attribute_name: str) -&gt; List[List[np.ndarray]]:\n    \"\"\"Get the attributes of the levels for both left and right bank.\"\"\"\n    return [self._get_attr_both_sides_level(attribute_name, level) for level in range(len(self.levels))]\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.ErosionInputs","title":"<code>ErosionInputs</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseBank[SingleErosion]</code></p> <p>Class to hold erosion inputs.</p> <p>Parameters:</p> Name Type Description Default <code>shipping_data</code> <code>Dict[str, ndarray]</code> <p>Data on all the vessels that travel through the river.</p> <code>dict()</code> <code>wave_fairway_distance_0</code> <code>List[ndarray]</code> <p>Threshold fairway distance 0 for wave attenuation.</p> required <code>wave_fairway_distance_1</code> <code>List[ndarray]</code> <p>Threshold fairway distance 1 for wave attenuation.</p> required <code>bank_protection_level</code> <code>List[ndarray]</code> <p>Bank protection level.</p> required <code>tauc</code> <code>List[ndarray]</code> <p>Critical bank shear stress values.</p> required <code>bank_type</code> <code>List[ndarray]</code> <p>Integer representation of the bank type. Represents an index into the taucls_str array.</p> <code>(lambda: array([]))()</code> <code>taucls</code> <code>ndarray</code> <p>Critical bank shear stress values for different bank types.</p> required <code>taucls_str</code> <code>Tuple[str]</code> <p>String representation for different bank types.</p> required Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>@dataclass\nclass ErosionInputs(BaseBank[SingleErosion]):\n    \"\"\"Class to hold erosion inputs.\n\n    args:\n        shipping_data (Dict[str, np.ndarray]):\n            Data on all the vessels that travel through the river.\n        wave_fairway_distance_0 (List[np.ndarray]):\n            Threshold fairway distance 0 for wave attenuation.\n        wave_fairway_distance_1 (List[np.ndarray]):\n            Threshold fairway distance 1 for wave attenuation.\n        bank_protection_level (List[np.ndarray]):\n            Bank protection level.\n        tauc (List[np.ndarray]):\n            Critical bank shear stress values.\n        bank_type (List[np.ndarray]):\n            Integer representation of the bank type. Represents an index into the taucls_str array.\n        taucls (np.ndarray):\n            Critical bank shear stress values for different bank types.\n        taucls_str (Tuple[str]):\n            String representation for different bank types.\n    \"\"\"\n    shipping_data: Dict[str, List[np.ndarray]] = field(default_factory=dict)\n    bank_type: np.ndarray = field(default_factory=lambda: np.array([]))\n    taucls: ClassVar[np.ndarray] = np.array([1e20, 95, 3.0, 0.95, 0.15])\n    taucls_str: ClassVar[Tuple[str]] = (\n        \"protected\",\n        \"vegetation\",\n        \"good clay\",\n        \"moderate/bad clay\",\n        \"sand\",\n    )\n\n    @classmethod\n    def from_column_arrays(\n        cls, data: dict, bank_cls: Type[\"SingleErosion\"], shipping_data: Dict[str, List[np.ndarray]],\n        bank_type: np.ndarray, bank_order: Tuple[str, str] = (\"left\", \"right\")\n    ) -&gt; \"ErosionInputs\":\n        # Only include fields that belong to the bank-specific data\n        base_fields = {k: v for k, v in data.items() if k != \"id\"}\n        base = BaseBank.from_column_arrays(\n            {\"id\": data.get(\"id\"), **base_fields}, bank_cls, bank_order=bank_order\n        )\n\n        return cls(\n            id=base.id,\n            left=base.left,\n            right=base.right,\n            shipping_data=shipping_data,\n            bank_type=bank_type,\n        )\n\n    @property\n    def bank_protection_level(self) -&gt; List[np.ndarray]:\n        \"\"\"Get the bank protection level.\"\"\"\n        return [self.left.bank_protection_level, self.right.bank_protection_level]\n\n    @property\n    def tauc(self) -&gt; List[np.ndarray]:\n        \"\"\"Get the critical bank shear stress values.\"\"\"\n        return [self.left.tauc, self.right.tauc]\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.ErosionInputs.bank_protection_level","title":"<code>bank_protection_level: List[np.ndarray]</code>  <code>property</code>","text":"<p>Get the bank protection level.</p>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.ErosionInputs.tauc","title":"<code>tauc: List[np.ndarray]</code>  <code>property</code>","text":"<p>Get the critical bank shear stress values.</p>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.ErosionResults","title":"<code>ErosionResults</code>  <code>dataclass</code>","text":"<p>Class to hold erosion results.</p> <p>Parameters:</p> Name Type Description Default <code>eq_erosion_dist</code> <code>List[ndarray]</code> <p>Erosion distance at equilibrium for each bank line.</p> required <code>total_erosion_dist</code> <code>List[ndarray]</code> <p>Total erosion distance for each bank line.</p> required <code>flow_erosion_dist</code> <code>List[ndarray]</code> <p>Total erosion distance caused by flow for each bank line.</p> required <code>ship_erosion_dist</code> <code>List[ndarray]</code> <p>Total erosion distance caused by ship waves for each bank line.</p> required <code>eq_eroded_vol</code> <code>List[ndarray]</code> <p>Eroded volume at equilibrium for each bank line.</p> required <code>total_eroded_vol</code> <code>List[ndarray]</code> <p>Total eroded volume for each bank line.</p> required <code>erosion_time</code> <code>int</code> <p>Time over which erosion is calculated.</p> required <code>avg_erosion_rate</code> <code>ndarray</code> <p>Average erosion rate data.</p> <code>(lambda: empty(0))()</code> <code>eq_eroded_vol_per_km</code> <code>ndarray</code> <p>Equilibrium eroded volume calculated per kilometer bin.</p> <code>(lambda: empty(0))()</code> <code>total_eroded_vol_per_km</code> <code>ndarray</code> <p>Total eroded volume calculated per kilometer bin.</p> <code>(lambda: empty(0))()</code> <p>Examples:</p> <ul> <li> <p>You can create an instance of the ErosionResults class as follows: <pre><code>&gt;&gt;&gt; from dfastbe.bank_erosion.data_models.calculation import ErosionResults\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; erosion_results = ErosionResults(\n...     eq_erosion_dist=[np.array([0.1, 0.2])],\n...     total_erosion_dist=[np.array([0.3, 0.4])],\n...     flow_erosion_dist=[np.array([0.5, 0.6])],\n...     ship_erosion_dist=[np.array([0.7, 0.8])],\n...     eq_eroded_vol=[np.array([1.1, 1.2])],\n...     total_eroded_vol=[np.array([1.3, 1.4])],\n...     erosion_time=10,\n...     avg_erosion_rate=np.array([0.1, 0.2]),\n...     eq_eroded_vol_per_km=np.array([0.3, 0.4]),\n...     total_eroded_vol_per_km=np.array([0.5, 0.6]),\n... )\n&gt;&gt;&gt; print(erosion_results)\nErosionResults(eq_erosion_dist=[array([0.1, 0.2])], total_erosion_dist=[array([0.3, 0.4])], flow_erosion_dist=[array([0.5, 0.6])], ship_erosion_dist=[array([0.7, 0.8])], eq_eroded_vol=[array([1.1, 1.2])], total_eroded_vol=[array([1.3, 1.4])], erosion_time=10, avg_erosion_rate=array([0.1, 0.2]), eq_eroded_vol_per_km=array([0.3, 0.4]), total_eroded_vol_per_km=array([0.5, 0.6]))\n</code></pre></p> </li> <li> <p>The <code>avg_erosion_rate</code>, <code>eq_eroded_vol_per_km</code>, and <code>total_eroded_vol_per_km</code> attributes are optional and can be set to empty arrays if not needed.</p> </li> </ul> <pre><code>&gt;&gt;&gt; from dfastbe.bank_erosion.data_models.calculation import ErosionResults\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; erosion_results = ErosionResults(\n...     eq_erosion_dist=[np.array([0.1, 0.2])],\n...     total_erosion_dist=[np.array([0.3, 0.4])],\n...     flow_erosion_dist=[np.array([0.5, 0.6])],\n...     ship_erosion_dist=[np.array([0.7, 0.8])],\n...     eq_eroded_vol=[np.array([1.1, 1.2])],\n...     total_eroded_vol=[np.array([1.3, 1.4])],\n...     erosion_time=10,\n... )\n&gt;&gt;&gt; print(erosion_results)\nErosionResults(eq_erosion_dist=[array([0.1, 0.2])], total_erosion_dist=[array([0.3, 0.4])], flow_erosion_dist=[array([0.5, 0.6])], ship_erosion_dist=[array([0.7, 0.8])], eq_eroded_vol=[array([1.1, 1.2])], total_eroded_vol=[array([1.3, 1.4])], erosion_time=10, avg_erosion_rate=array([], dtype=float64), eq_eroded_vol_per_km=array([], dtype=float64), total_eroded_vol_per_km=array([], dtype=float64))\n</code></pre> Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>@dataclass\nclass ErosionResults:\n    \"\"\"Class to hold erosion results.\n\n    args:\n        eq_erosion_dist (List[np.ndarray]):\n            Erosion distance at equilibrium for each bank line.\n        total_erosion_dist (List[np.ndarray]):\n            Total erosion distance for each bank line.\n        flow_erosion_dist (List[np.ndarray]):\n            Total erosion distance caused by flow for each bank line.\n        ship_erosion_dist (List[np.ndarray]):\n            Total erosion distance caused by ship waves for each bank line.\n        eq_eroded_vol (List[np.ndarray]):\n            Eroded volume at equilibrium for each bank line.\n        total_eroded_vol (List[np.ndarray]):\n            Total eroded volume for each bank line.\n        erosion_time (int):\n            Time over which erosion is calculated.\n        avg_erosion_rate (np.ndarray):\n            Average erosion rate data.\n        eq_eroded_vol_per_km (np.ndarray):\n            Equilibrium eroded volume calculated per kilometer bin.\n        total_eroded_vol_per_km (np.ndarray):\n            Total eroded volume calculated per kilometer bin.\n\n    Examples:\n        - You can create an instance of the ErosionResults class as follows:\n        ```python\n        &gt;&gt;&gt; from dfastbe.bank_erosion.data_models.calculation import ErosionResults\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; erosion_results = ErosionResults(\n        ...     eq_erosion_dist=[np.array([0.1, 0.2])],\n        ...     total_erosion_dist=[np.array([0.3, 0.4])],\n        ...     flow_erosion_dist=[np.array([0.5, 0.6])],\n        ...     ship_erosion_dist=[np.array([0.7, 0.8])],\n        ...     eq_eroded_vol=[np.array([1.1, 1.2])],\n        ...     total_eroded_vol=[np.array([1.3, 1.4])],\n        ...     erosion_time=10,\n        ...     avg_erosion_rate=np.array([0.1, 0.2]),\n        ...     eq_eroded_vol_per_km=np.array([0.3, 0.4]),\n        ...     total_eroded_vol_per_km=np.array([0.5, 0.6]),\n        ... )\n        &gt;&gt;&gt; print(erosion_results)\n        ErosionResults(eq_erosion_dist=[array([0.1, 0.2])], total_erosion_dist=[array([0.3, 0.4])], flow_erosion_dist=[array([0.5, 0.6])], ship_erosion_dist=[array([0.7, 0.8])], eq_eroded_vol=[array([1.1, 1.2])], total_eroded_vol=[array([1.3, 1.4])], erosion_time=10, avg_erosion_rate=array([0.1, 0.2]), eq_eroded_vol_per_km=array([0.3, 0.4]), total_eroded_vol_per_km=array([0.5, 0.6]))\n\n        ```\n\n        - The `avg_erosion_rate`, `eq_eroded_vol_per_km`, and `total_eroded_vol_per_km` attributes are optional and\n        can be set to empty arrays if not needed.\n\n        ```python\n        &gt;&gt;&gt; from dfastbe.bank_erosion.data_models.calculation import ErosionResults\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; erosion_results = ErosionResults(\n        ...     eq_erosion_dist=[np.array([0.1, 0.2])],\n        ...     total_erosion_dist=[np.array([0.3, 0.4])],\n        ...     flow_erosion_dist=[np.array([0.5, 0.6])],\n        ...     ship_erosion_dist=[np.array([0.7, 0.8])],\n        ...     eq_eroded_vol=[np.array([1.1, 1.2])],\n        ...     total_eroded_vol=[np.array([1.3, 1.4])],\n        ...     erosion_time=10,\n        ... )\n        &gt;&gt;&gt; print(erosion_results)\n        ErosionResults(eq_erosion_dist=[array([0.1, 0.2])], total_erosion_dist=[array([0.3, 0.4])], flow_erosion_dist=[array([0.5, 0.6])], ship_erosion_dist=[array([0.7, 0.8])], eq_eroded_vol=[array([1.1, 1.2])], total_eroded_vol=[array([1.3, 1.4])], erosion_time=10, avg_erosion_rate=array([], dtype=float64), eq_eroded_vol_per_km=array([], dtype=float64), total_eroded_vol_per_km=array([], dtype=float64))\n\n        ```\n    \"\"\"\n\n    eq_erosion_dist: List[np.ndarray]\n    total_erosion_dist: List[np.ndarray]\n    flow_erosion_dist: List[np.ndarray]\n    ship_erosion_dist: List[np.ndarray]\n    eq_eroded_vol: List[np.ndarray]\n    total_eroded_vol: List[np.ndarray]\n    erosion_time: int\n    avg_erosion_rate: np.ndarray = field(default_factory=lambda : np.empty(0))\n    eq_eroded_vol_per_km: np.ndarray = field(default_factory=lambda : np.empty(0))\n    total_eroded_vol_per_km: np.ndarray = field(default_factory=lambda : np.empty(0))\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.FairwayData","title":"<code>FairwayData</code>  <code>dataclass</code>","text":"<p>Class to hold fairway-related data.</p> <p>Parameters:</p> Name Type Description Default <code>fairway_face_indices</code> <code>ndarray</code> <p>Mesh face indices matching to the fairway points.</p> required <code>intersection_coords</code> <code>ndarray</code> <p>The x, y coordinates of the intersection points of the fairway with the simulation mesh.</p> required <code>fairway_initial_water_levels</code> <code>List[ndarray]</code> <p>Reference water level at the fairway</p> <code>list()</code> Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>@dataclass\nclass FairwayData:\n    \"\"\"Class to hold fairway-related data.\n\n    args:\n        fairway_face_indices (np.ndarray):\n            Mesh face indices matching to the fairway points.\n        intersection_coords (np.ndarray):\n            The x, y coordinates of the intersection points of the fairway with the simulation mesh.\n        fairway_initial_water_levels (List[np.ndarray]):\n            Reference water level at the fairway\n    \"\"\"\n    fairway_face_indices: np.ndarray\n    intersection_coords: np.ndarray\n    fairway_initial_water_levels: List[np.ndarray] = field(default_factory=list)\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.SingleBank","title":"<code>SingleBank</code>  <code>dataclass</code>","text":"Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>@dataclass\nclass SingleBank:\n    is_right_bank: bool\n    bank_line_coords: np.ndarray\n    bank_face_indices: np.ndarray\n    bank_line_size: np.ndarray = field(default_factory=lambda: np.array([]))\n    fairway_distances: np.ndarray = field(default_factory=lambda: np.array([]))\n    fairway_face_indices: np.ndarray = field(default_factory=lambda: np.array([]))\n    bank_chainage_midpoints: np.ndarray = field(default_factory=lambda: np.array([]))\n\n    segment_length: np.ndarray = field(init=False)\n    dx: np.ndarray = field(init=False)\n    dy: np.ndarray = field(init=False)\n    length: int = field(init=False)\n\n    # bank height is calculated at the first discharge level only.\n    height: Optional[np.ndarray] = field(default=lambda : np.array([]))\n\n    def __post_init__(self):\n        \"\"\"Post-initialization to ensure bank_line_coords is a list of numpy arrays.\"\"\"\n        self.segment_length = self._segment_length()\n        self.dx = self._dx()\n        self.dy = self._dy()\n        self.length = len(self.bank_chainage_midpoints)\n\n    def _segment_length(self) -&gt; np.ndarray:\n        \"\"\"Calculate the length of each segment in the bank line.\n\n        Returns:\n            List[np.ndarray]: Length of each segment in the bank line.\n        \"\"\"\n        return np.linalg.norm(np.diff(self.bank_line_coords, axis=0), axis=1)\n\n    def _dx(self) -&gt; np.ndarray:\n        \"\"\"Calculate the distance between each bank line point.\n\n        Returns:\n            List[np.ndarray]: Distance to the closest fairway point for each bank line point.\n        \"\"\"\n        return np.diff(self.bank_line_coords[:, 0])\n\n    def _dy(self) -&gt; np.ndarray:\n        \"\"\"Calculate the distance between each bank line point.\n\n        Returns:\n            List[np.ndarray]: Distance to the closest fairway point for each bank line point.\n        \"\"\"\n        return np.diff(self.bank_line_coords[:, 1])\n\n    def get_mid_points(self, as_geo_series: bool = False, crs: str = None) -&gt; Union[GeoSeries, np.ndarray]:\n        \"\"\"Band line midpoints.\n\n        Args:\n            as_geo_series (bool):\n                bool indicating if the output should be a GeoSeries or not.\n            crs (str):\n                coordinate reference system.\n        Returns:\n            the midpoints of the bank line coordinates as a GeoSeries or numpy array.\n        \"\"\"\n        bank_coords = self.bank_line_coords\n        bank_coords_mind = (bank_coords[:-1] + bank_coords[1:]) / 2\n\n        if as_geo_series:\n            bank_coords_mind = [Point(xy) for xy in bank_coords_mind]\n            bank_coords_mind = GeoSeries(bank_coords_mind, crs=crs)\n        return bank_coords_mind\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.SingleBank.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization to ensure bank_line_coords is a list of numpy arrays.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Post-initialization to ensure bank_line_coords is a list of numpy arrays.\"\"\"\n    self.segment_length = self._segment_length()\n    self.dx = self._dx()\n    self.dy = self._dy()\n    self.length = len(self.bank_chainage_midpoints)\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.SingleBank.get_mid_points","title":"<code>get_mid_points(as_geo_series: bool = False, crs: str = None) -&gt; Union[GeoSeries, np.ndarray]</code>","text":"<p>Band line midpoints.</p> <p>Parameters:</p> Name Type Description Default <code>as_geo_series</code> <code>bool</code> <p>bool indicating if the output should be a GeoSeries or not.</p> <code>False</code> <code>crs</code> <code>str</code> <p>coordinate reference system.</p> <code>None</code> <p>Returns:     the midpoints of the bank line coordinates as a GeoSeries or numpy array.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>def get_mid_points(self, as_geo_series: bool = False, crs: str = None) -&gt; Union[GeoSeries, np.ndarray]:\n    \"\"\"Band line midpoints.\n\n    Args:\n        as_geo_series (bool):\n            bool indicating if the output should be a GeoSeries or not.\n        crs (str):\n            coordinate reference system.\n    Returns:\n        the midpoints of the bank line coordinates as a GeoSeries or numpy array.\n    \"\"\"\n    bank_coords = self.bank_line_coords\n    bank_coords_mind = (bank_coords[:-1] + bank_coords[1:]) / 2\n\n    if as_geo_series:\n        bank_coords_mind = [Point(xy) for xy in bank_coords_mind]\n        bank_coords_mind = GeoSeries(bank_coords_mind, crs=crs)\n    return bank_coords_mind\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.calculation.WaterLevelData","title":"<code>WaterLevelData</code>  <code>dataclass</code>","text":"<p>Class to hold water level data.</p> <p>Parameters:</p> Name Type Description Default <code>hfw_max</code> <code>float</code> <p>Maximum water depth along the fairway.</p> required <code>water_level</code> <code>List[List[ndarray]]</code> <p>Water level data.</p> required <code>ship_wave_max</code> <code>List[List[ndarray]]</code> <p>Maximum bank height subject to ship waves [m]</p> required <code>ship_wave_min</code> <code>List[List[ndarray]]</code> <p>Minimum bank height subject to ship waves [m]</p> required <code>velocity</code> <code>List[List[ndarray]]</code> <p>Flow velocity magnitude along the bank [m/s]</p> required <code>bank_height</code> <code>List[ndarray]</code> <p>Bank height data.</p> required <code>chezy</code> <code>List[List[ndarray]]</code> <p>Chezy coefficient data.</p> required <code>vol_per_discharge</code> <code>List[List[ndarray]]</code> <p>Eroded volume per discharge level for each bank line.</p> required Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>@dataclass\nclass WaterLevelData:\n    \"\"\"Class to hold water level data.\n\n    args:\n        hfw_max (float): Maximum water depth along the fairway.\n        water_level (List[List[np.ndarray]]): Water level data.\n        ship_wave_max (List[List[np.ndarray]]): Maximum bank height subject to ship waves [m]\n        ship_wave_min (List[List[np.ndarray]]): Minimum bank height subject to ship waves [m]\n        velocity (List[List[np.ndarray]]): Flow velocity magnitude along the bank [m/s]\n        bank_height (List[np.ndarray]): Bank height data.\n        chezy (List[List[np.ndarray]]): Chezy coefficient data.\n        vol_per_discharge (List[List[np.ndarray]]):\n            Eroded volume per discharge level for each bank line.\n    \"\"\"\n    hfw_max: float\n    water_level: List[List[np.ndarray]]\n    ship_wave_max: List[List[np.ndarray]]\n    ship_wave_min: List[List[np.ndarray]]\n    velocity: List[List[np.ndarray]]\n    chezy: List[List[np.ndarray]]\n    vol_per_discharge: List[List[np.ndarray]]\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#input-data-models","title":"Input Data Models","text":"<p>For more details, see Bank Erosion Input Data Models.</p>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.inputs","title":"<code>dfastbe.bank_erosion.data_models.inputs</code>","text":""},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.inputs.BankLinesResultsError","title":"<code>BankLinesResultsError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for BankLine results errors.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>class BankLinesResultsError(Exception):\n    \"\"\"Custom exception for BankLine results errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.inputs.ErosionRiverData","title":"<code>ErosionRiverData</code>","text":"<p>               Bases: <code>BaseRiverData</code></p> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>class ErosionRiverData(BaseRiverData):\n\n    def __init__(self, config_file: ConfigFile):\n        super().__init__(config_file)\n        self.bank_dir = self._get_bank_line_dir()\n        self.output_dir = config_file.get_output_dir(\"erosion\")\n        self.debug = config_file.debug\n        # set plotting flags\n        self.plot_flags = config_file.get_plotting_flags(config_file.root_dir)\n        # get filter settings for bank levels and flow velocities along banks\n        self.zb_dx = config_file.get_float(\n            \"Erosion\", \"BedFilterDist\", 0.0, positive=True\n        )\n        self.vel_dx = config_file.get_float(\n            \"Erosion\", \"VelFilterDist\", 0.0, positive=True\n        )\n        LogData().log_text(\"get_levels\")\n        self.num_discharge_levels = config_file.get_int(\"Erosion\", \"NLevel\")\n        self.output_intervals = config_file.get_float(\"Erosion\", \"OutputInterval\", 1.0)\n        self.bank_lines = config_file.read_bank_lines(str(self.bank_dir))\n        self.river_axis = self._read_river_axis()\n        self.erosion_time = config_file.get_int(\"Erosion\", \"TErosion\", positive=True)\n\n    def simulation_data(self) -&gt; ErosionSimulationData:\n        \"\"\"Simulation Data.\"\"\"\n        ref_level = self.config_file.get_int(\"Erosion\", \"RefLevel\") - 1\n        # read simulation data (get_sim_data)\n        sim_file = self.config_file.get_sim_file(\"Erosion\", str(ref_level + 1))\n        LogData().log_text(\"-\")\n        LogData().log_text(\"read_simdata\", data={\"file\": sim_file})\n        LogData().log_text(\"-\")\n        simulation_data = ErosionSimulationData.read(sim_file)\n\n        return simulation_data\n\n    def _get_bank_output_dir(self) -&gt; Path:\n        bank_output_dir = self.config_file.get_str(\"General\", \"BankDir\")\n        LogData().log_text(\"bank_dir_out\", data={\"dir\": bank_output_dir})\n        if os.path.exists(bank_output_dir):\n            LogData().log_text(\"overwrite_dir\", data={\"dir\": bank_output_dir})\n        else:\n            os.makedirs(bank_output_dir)\n\n        return Path(bank_output_dir)\n\n    def _get_bank_line_dir(self) -&gt; Path:\n        bank_dir = self.config_file.get_str(\"General\", \"BankDir\")\n        LogData().log_text(\"bank_dir_in\", data={\"dir\": bank_dir})\n        bank_dir = Path(bank_dir)\n        if not bank_dir.exists():\n            LogData().log_text(\"missing_dir\", data={\"dir\": bank_dir})\n            raise BankLinesResultsError(\n                f\"Required bank line directory:{bank_dir} does not exist. please use the banklines command to run the \"\n                \"bankline detection tool first it.\"\n            )\n        else:\n            return bank_dir\n\n    def _read_river_axis(self) -&gt; LineString:\n        \"\"\"Get the river axis from the analysis settings.\"\"\"\n        river_axis_file = self.config_file.get_str(\"Erosion\", \"RiverAxis\")\n        LogData().log_text(\"read_river_axis\", data={\"file\": river_axis_file})\n        river_axis = XYCModel.read(river_axis_file)\n        return river_axis\n\n    def process_river_axis_by_center_line(self) -&gt; LineGeometry:\n        \"\"\"Process the river axis by the center line.\n\n        Intersect the river center line with the river axis to map the stations from the first to the latter\n        then clip the river axis by the first and last station of the centerline.\n        \"\"\"\n        river_axis = LineGeometry(self.river_axis, crs=self.config_file.crs)\n        river_axis_numpy = river_axis.as_array()\n        # optional sorting --&gt; see 04_Waal_D3D example\n        # check: sum all distances and determine maximum distance ...\n        # if maximum &gt; alpha * sum then perform sort\n        # Waal OK: 0.0082 ratio max/sum, Waal NotOK: 0.13 - Waal: 2500 points,\n        # so even when OK still some 21 times more than 1/2500 = 0.0004\n        dist2 = (np.diff(river_axis_numpy, axis=0) ** 2).sum(axis=1)\n        alpha = dist2.max() / dist2.sum()\n        if alpha &gt; 0.03:\n            print(\"The river axis needs sorting!!\")\n\n        # map km to axis points, further using axis\n        LogData().log_text(\"chainage_to_axis\")\n        river_center_line_arr = self.river_center_line.as_array()\n        river_axis_km = river_axis.intersect_with_line(river_center_line_arr)\n\n        # clip river axis to reach of interest (get the closest point to the first and last station)\n        i1 = np.argmin(\n            ((river_center_line_arr[0, :2] - river_axis_numpy) ** 2).sum(axis=1)\n        )\n        i2 = np.argmin(\n            ((river_center_line_arr[-1, :2] - river_axis_numpy) ** 2).sum(axis=1)\n        )\n        if i1 &lt; i2:\n            river_axis_km = river_axis_km[i1 : i2 + 1]\n            river_axis_numpy = river_axis_numpy[i1 : i2 + 1]\n        else:\n            # reverse river axis\n            river_axis_km = river_axis_km[i2 : i1 + 1][::-1]\n            river_axis_numpy = river_axis_numpy[i2 : i1 + 1][::-1]\n\n        river_axis = LineGeometry(river_axis_numpy, crs=self.config_file.crs)\n        river_axis.add_data(data={\"stations\": river_axis_km})\n        return river_axis\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.inputs.ErosionRiverData.process_river_axis_by_center_line","title":"<code>process_river_axis_by_center_line() -&gt; LineGeometry</code>","text":"<p>Process the river axis by the center line.</p> <p>Intersect the river center line with the river axis to map the stations from the first to the latter then clip the river axis by the first and last station of the centerline.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>def process_river_axis_by_center_line(self) -&gt; LineGeometry:\n    \"\"\"Process the river axis by the center line.\n\n    Intersect the river center line with the river axis to map the stations from the first to the latter\n    then clip the river axis by the first and last station of the centerline.\n    \"\"\"\n    river_axis = LineGeometry(self.river_axis, crs=self.config_file.crs)\n    river_axis_numpy = river_axis.as_array()\n    # optional sorting --&gt; see 04_Waal_D3D example\n    # check: sum all distances and determine maximum distance ...\n    # if maximum &gt; alpha * sum then perform sort\n    # Waal OK: 0.0082 ratio max/sum, Waal NotOK: 0.13 - Waal: 2500 points,\n    # so even when OK still some 21 times more than 1/2500 = 0.0004\n    dist2 = (np.diff(river_axis_numpy, axis=0) ** 2).sum(axis=1)\n    alpha = dist2.max() / dist2.sum()\n    if alpha &gt; 0.03:\n        print(\"The river axis needs sorting!!\")\n\n    # map km to axis points, further using axis\n    LogData().log_text(\"chainage_to_axis\")\n    river_center_line_arr = self.river_center_line.as_array()\n    river_axis_km = river_axis.intersect_with_line(river_center_line_arr)\n\n    # clip river axis to reach of interest (get the closest point to the first and last station)\n    i1 = np.argmin(\n        ((river_center_line_arr[0, :2] - river_axis_numpy) ** 2).sum(axis=1)\n    )\n    i2 = np.argmin(\n        ((river_center_line_arr[-1, :2] - river_axis_numpy) ** 2).sum(axis=1)\n    )\n    if i1 &lt; i2:\n        river_axis_km = river_axis_km[i1 : i2 + 1]\n        river_axis_numpy = river_axis_numpy[i1 : i2 + 1]\n    else:\n        # reverse river axis\n        river_axis_km = river_axis_km[i2 : i1 + 1][::-1]\n        river_axis_numpy = river_axis_numpy[i2 : i1 + 1][::-1]\n\n    river_axis = LineGeometry(river_axis_numpy, crs=self.config_file.crs)\n    river_axis.add_data(data={\"stations\": river_axis_km})\n    return river_axis\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.inputs.ErosionRiverData.simulation_data","title":"<code>simulation_data() -&gt; ErosionSimulationData</code>","text":"<p>Simulation Data.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>def simulation_data(self) -&gt; ErosionSimulationData:\n    \"\"\"Simulation Data.\"\"\"\n    ref_level = self.config_file.get_int(\"Erosion\", \"RefLevel\") - 1\n    # read simulation data (get_sim_data)\n    sim_file = self.config_file.get_sim_file(\"Erosion\", str(ref_level + 1))\n    LogData().log_text(\"-\")\n    LogData().log_text(\"read_simdata\", data={\"file\": sim_file})\n    LogData().log_text(\"-\")\n    simulation_data = ErosionSimulationData.read(sim_file)\n\n    return simulation_data\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.inputs.ErosionSimulationData","title":"<code>ErosionSimulationData</code>","text":"<p>               Bases: <code>BaseSimulationData</code></p> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>class ErosionSimulationData(BaseSimulationData):\n\n    def compute_mesh_topology(self, verbose: bool = False) -&gt; MeshData:\n        \"\"\"Derive secondary topology arrays from the face-node connectivity of the mesh.\n\n        This function computes the edge-node, edge-face, and face-edge connectivity arrays,\n        as well as the boundary edges of the mesh, based on the face-node connectivity provided\n        in the simulation data.\n\n        Returns:\n            MeshData: a dataclass containing the following attributes:\n                - `x_face_coords`: x-coordinates of face nodes\n                - `y_face_coords`: y-coordinates of face nodes\n                - `x_edge_coords`: x-coordinates of edge nodes\n                - `y_edge_coords`: y-coordinates of edge nodes\n                - `face_node`: the node indices for each of the mesh faces.\n                - `n_nodes`: number of nodes per face\n                - `edge_node`: the node indices for each of the mesh edges.\n                - `edge_face_connectivity`: the face indices for each of the mesh edge\n                - `face_edge_connectivity`: the edge indices for each of the mesh face\n                - `boundary_edge_nrs`: indices of boundary edges\n\n        Raises:\n            KeyError:\n                If required keys (e.g., `face_node`, `nnodes`, `x_node`, `y_node`) are missing from the `sim` object.\n\n        Notes:\n            - The function identifies unique edges by sorting and comparing node indices.\n            - Boundary edges are identified as edges that belong to only one face.\n            - The function assumes that the mesh is well-formed, with consistent face-node connectivity.\n        \"\"\"\n\n        # get a sorted list of edge node connections (shared edges occur twice)\n        # face_nr contains the face index to which the edge belongs\n        n_faces = self.face_node.shape[0]\n        n_edges = sum(self.n_nodes)\n        edge_node = np.zeros((n_edges, 2), dtype=int)\n        face_nr = np.zeros((n_edges,), dtype=int)\n        i = 0\n        for face_i in range(n_faces):\n            num_edges = self.n_nodes[face_i]  # note: nEdges = nNodes\n            for edge_i in range(num_edges):\n                if edge_i == 0:\n                    edge_node[i, 1] = self.face_node[face_i, num_edges - 1]\n                else:\n                    edge_node[i, 1] = self.face_node[face_i, edge_i - 1]\n                edge_node[i, 0] = self.face_node[face_i, edge_i]\n                face_nr[i] = face_i\n                i = i + 1\n        edge_node.sort(axis=1)\n        i2 = np.argsort(edge_node[:, 1], kind=\"stable\")\n        i1 = np.argsort(edge_node[i2, 0], kind=\"stable\")\n        i12 = i2[i1]\n        edge_node = edge_node[i12, :]\n        face_nr = face_nr[i12]\n\n        # detect which edges are equal to the previous edge, and get a list of all unique edges\n        numpy_true = np.array([True])\n        equal_to_previous = np.concatenate(\n            (~numpy_true, (np.diff(edge_node, axis=0) == 0).all(axis=1))\n        )\n        unique_edge = ~equal_to_previous\n        n_unique_edges = np.sum(unique_edge)\n        # reduce the edge node connections to only the unique edges\n        edge_node = edge_node[unique_edge, :]\n\n        # number the edges\n        edge_nr = np.zeros(n_edges, dtype=int)\n        edge_nr[unique_edge] = np.arange(n_unique_edges, dtype=int)\n        edge_nr[equal_to_previous] = edge_nr[\n            np.concatenate((equal_to_previous[1:], equal_to_previous[:1]))\n        ]\n\n        # if two consecutive edges are unique, the first one occurs only once and represents a boundary edge\n        is_boundary_edge = unique_edge &amp; np.concatenate((unique_edge[1:], numpy_true))\n        boundary_edge_nrs = edge_nr[is_boundary_edge]\n\n        # go back to the original face order\n        edge_nr_in_face_order = np.zeros(n_edges, dtype=int)\n        edge_nr_in_face_order[i12] = edge_nr\n        # create the face edge connectivity array\n        face_edge_connectivity = np.zeros(self.face_node.shape, dtype=int)\n\n        i = 0\n        for face_i in range(n_faces):\n            num_edges = self.n_nodes[face_i]  # note: num_edges = n_nodes\n            for edge_i in range(num_edges):\n                face_edge_connectivity[face_i, edge_i] = edge_nr_in_face_order[i]\n                i = i + 1\n\n        # determine the edge face connectivity\n        edge_face = -np.ones((n_unique_edges, 2), dtype=int)\n        edge_face[edge_nr[unique_edge], 0] = face_nr[unique_edge]\n        edge_face[edge_nr[equal_to_previous], 1] = face_nr[equal_to_previous]\n\n        x_face_coords = self.apply_masked_indexing(self.x_node, self.face_node)\n        y_face_coords = self.apply_masked_indexing(self.y_node, self.face_node)\n        x_edge_coords = self.x_node[edge_node]\n        y_edge_coords = self.y_node[edge_node]\n\n        return MeshData(\n            x_face_coords=x_face_coords,\n            y_face_coords=y_face_coords,\n            x_edge_coords=x_edge_coords,\n            y_edge_coords=y_edge_coords,\n            face_node=self.face_node,\n            n_nodes=self.n_nodes,\n            edge_node=edge_node,\n            edge_face_connectivity=edge_face,\n            face_edge_connectivity=face_edge_connectivity,\n            boundary_edge_nrs=boundary_edge_nrs,\n            verbose=verbose,\n        )\n\n    @staticmethod\n    def apply_masked_indexing(\n        x0: np.array, idx: np.ma.masked_array\n    ) -&gt; np.ma.masked_array:\n        \"\"\"\n        Index one array by another transferring the mask.\n\n        Args:\n            x0 : np.ndarray\n                A linear array.\n            idx : np.ma.masked_array\n                An index array with possibly masked indices.\n\n        returns:\n            x1: np.ma.masked_array\n                An array with same shape as idx, with mask.\n        \"\"\"\n        idx_safe = idx.copy()\n        idx_safe.data[np.ma.getmask(idx)] = 0\n        x1 = np.ma.masked_where(np.ma.getmask(idx), x0[idx_safe])\n        return x1\n\n    def calculate_bank_velocity(self, single_bank: \"SingleBank\", vel_dx) -&gt; np.ndarray:\n        from dfastbe.bank_erosion.utils import moving_avg\n\n        bank_face_indices = single_bank.bank_face_indices\n        vel_bank = (\n            np.abs(\n                self.velocity_x_face[bank_face_indices] * single_bank.dx\n                + self.velocity_y_face[bank_face_indices] * single_bank.dy\n            )\n            / single_bank.segment_length\n        )\n\n        if vel_dx &gt; 0.0:\n            vel_bank = moving_avg(single_bank.bank_chainage_midpoints, vel_bank, vel_dx)\n\n        return vel_bank\n\n    def calculate_bank_height(self, single_bank: SingleBank, zb_dx):\n        # bank height = maximum bed elevation per cell\n        from dfastbe.bank_erosion.utils import moving_avg\n\n        bank_index = single_bank.bank_face_indices\n        if self.bed_elevation_location == \"node\":\n            zb_nodes = self.bed_elevation_values\n            zb_all = self.apply_masked_indexing(zb_nodes, self.face_node[bank_index, :])\n            zb_bank = zb_all.max(axis=1)\n            if zb_dx &gt; 0.0:\n                zb_bank = moving_avg(\n                    single_bank.bank_chainage_midpoints,\n                    zb_bank,\n                    zb_dx,\n                )\n        else:\n            # don't know ... need to check neighbouring cells ...\n            zb_bank = None\n\n        return zb_bank\n\n    def get_fairway_data(self, fairway_face_indices):\n        # get fairway face indices\n        # fairway_face_indices = fairway_face_indices\n\n        # get water depth along the fair-way\n        water_depth_fairway = self.water_depth_face[fairway_face_indices]\n        water_level = self.water_level_face[fairway_face_indices]\n        chez_face = self.chezy_face[fairway_face_indices]\n        chezy = 0 * chez_face + chez_face.mean()\n\n        data = {\n            \"water_depth\": water_depth_fairway,\n            \"water_level\": water_level,\n            \"chezy\": chezy,\n        }\n        return data\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.inputs.ErosionSimulationData.apply_masked_indexing","title":"<code>apply_masked_indexing(x0: np.array, idx: np.ma.masked_array) -&gt; np.ma.masked_array</code>  <code>staticmethod</code>","text":"<p>Index one array by another transferring the mask.</p> <p>Parameters:</p> Name Type Description Default <code>x0 </code> <p>np.ndarray A linear array.</p> required <code>idx </code> <p>np.ma.masked_array An index array with possibly masked indices.</p> required <p>Returns:</p> Name Type Description <code>x1</code> <code>masked_array</code> <p>np.ma.masked_array An array with same shape as idx, with mask.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>@staticmethod\ndef apply_masked_indexing(\n    x0: np.array, idx: np.ma.masked_array\n) -&gt; np.ma.masked_array:\n    \"\"\"\n    Index one array by another transferring the mask.\n\n    Args:\n        x0 : np.ndarray\n            A linear array.\n        idx : np.ma.masked_array\n            An index array with possibly masked indices.\n\n    returns:\n        x1: np.ma.masked_array\n            An array with same shape as idx, with mask.\n    \"\"\"\n    idx_safe = idx.copy()\n    idx_safe.data[np.ma.getmask(idx)] = 0\n    x1 = np.ma.masked_where(np.ma.getmask(idx), x0[idx_safe])\n    return x1\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.inputs.ErosionSimulationData.compute_mesh_topology","title":"<code>compute_mesh_topology(verbose: bool = False) -&gt; MeshData</code>","text":"<p>Derive secondary topology arrays from the face-node connectivity of the mesh.</p> <p>This function computes the edge-node, edge-face, and face-edge connectivity arrays, as well as the boundary edges of the mesh, based on the face-node connectivity provided in the simulation data.</p> <p>Returns:</p> Name Type Description <code>MeshData</code> <code>MeshData</code> <p>a dataclass containing the following attributes: - <code>x_face_coords</code>: x-coordinates of face nodes - <code>y_face_coords</code>: y-coordinates of face nodes - <code>x_edge_coords</code>: x-coordinates of edge nodes - <code>y_edge_coords</code>: y-coordinates of edge nodes - <code>face_node</code>: the node indices for each of the mesh faces. - <code>n_nodes</code>: number of nodes per face - <code>edge_node</code>: the node indices for each of the mesh edges. - <code>edge_face_connectivity</code>: the face indices for each of the mesh edge - <code>face_edge_connectivity</code>: the edge indices for each of the mesh face - <code>boundary_edge_nrs</code>: indices of boundary edges</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If required keys (e.g., <code>face_node</code>, <code>nnodes</code>, <code>x_node</code>, <code>y_node</code>) are missing from the <code>sim</code> object.</p> Notes <ul> <li>The function identifies unique edges by sorting and comparing node indices.</li> <li>Boundary edges are identified as edges that belong to only one face.</li> <li>The function assumes that the mesh is well-formed, with consistent face-node connectivity.</li> </ul> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>def compute_mesh_topology(self, verbose: bool = False) -&gt; MeshData:\n    \"\"\"Derive secondary topology arrays from the face-node connectivity of the mesh.\n\n    This function computes the edge-node, edge-face, and face-edge connectivity arrays,\n    as well as the boundary edges of the mesh, based on the face-node connectivity provided\n    in the simulation data.\n\n    Returns:\n        MeshData: a dataclass containing the following attributes:\n            - `x_face_coords`: x-coordinates of face nodes\n            - `y_face_coords`: y-coordinates of face nodes\n            - `x_edge_coords`: x-coordinates of edge nodes\n            - `y_edge_coords`: y-coordinates of edge nodes\n            - `face_node`: the node indices for each of the mesh faces.\n            - `n_nodes`: number of nodes per face\n            - `edge_node`: the node indices for each of the mesh edges.\n            - `edge_face_connectivity`: the face indices for each of the mesh edge\n            - `face_edge_connectivity`: the edge indices for each of the mesh face\n            - `boundary_edge_nrs`: indices of boundary edges\n\n    Raises:\n        KeyError:\n            If required keys (e.g., `face_node`, `nnodes`, `x_node`, `y_node`) are missing from the `sim` object.\n\n    Notes:\n        - The function identifies unique edges by sorting and comparing node indices.\n        - Boundary edges are identified as edges that belong to only one face.\n        - The function assumes that the mesh is well-formed, with consistent face-node connectivity.\n    \"\"\"\n\n    # get a sorted list of edge node connections (shared edges occur twice)\n    # face_nr contains the face index to which the edge belongs\n    n_faces = self.face_node.shape[0]\n    n_edges = sum(self.n_nodes)\n    edge_node = np.zeros((n_edges, 2), dtype=int)\n    face_nr = np.zeros((n_edges,), dtype=int)\n    i = 0\n    for face_i in range(n_faces):\n        num_edges = self.n_nodes[face_i]  # note: nEdges = nNodes\n        for edge_i in range(num_edges):\n            if edge_i == 0:\n                edge_node[i, 1] = self.face_node[face_i, num_edges - 1]\n            else:\n                edge_node[i, 1] = self.face_node[face_i, edge_i - 1]\n            edge_node[i, 0] = self.face_node[face_i, edge_i]\n            face_nr[i] = face_i\n            i = i + 1\n    edge_node.sort(axis=1)\n    i2 = np.argsort(edge_node[:, 1], kind=\"stable\")\n    i1 = np.argsort(edge_node[i2, 0], kind=\"stable\")\n    i12 = i2[i1]\n    edge_node = edge_node[i12, :]\n    face_nr = face_nr[i12]\n\n    # detect which edges are equal to the previous edge, and get a list of all unique edges\n    numpy_true = np.array([True])\n    equal_to_previous = np.concatenate(\n        (~numpy_true, (np.diff(edge_node, axis=0) == 0).all(axis=1))\n    )\n    unique_edge = ~equal_to_previous\n    n_unique_edges = np.sum(unique_edge)\n    # reduce the edge node connections to only the unique edges\n    edge_node = edge_node[unique_edge, :]\n\n    # number the edges\n    edge_nr = np.zeros(n_edges, dtype=int)\n    edge_nr[unique_edge] = np.arange(n_unique_edges, dtype=int)\n    edge_nr[equal_to_previous] = edge_nr[\n        np.concatenate((equal_to_previous[1:], equal_to_previous[:1]))\n    ]\n\n    # if two consecutive edges are unique, the first one occurs only once and represents a boundary edge\n    is_boundary_edge = unique_edge &amp; np.concatenate((unique_edge[1:], numpy_true))\n    boundary_edge_nrs = edge_nr[is_boundary_edge]\n\n    # go back to the original face order\n    edge_nr_in_face_order = np.zeros(n_edges, dtype=int)\n    edge_nr_in_face_order[i12] = edge_nr\n    # create the face edge connectivity array\n    face_edge_connectivity = np.zeros(self.face_node.shape, dtype=int)\n\n    i = 0\n    for face_i in range(n_faces):\n        num_edges = self.n_nodes[face_i]  # note: num_edges = n_nodes\n        for edge_i in range(num_edges):\n            face_edge_connectivity[face_i, edge_i] = edge_nr_in_face_order[i]\n            i = i + 1\n\n    # determine the edge face connectivity\n    edge_face = -np.ones((n_unique_edges, 2), dtype=int)\n    edge_face[edge_nr[unique_edge], 0] = face_nr[unique_edge]\n    edge_face[edge_nr[equal_to_previous], 1] = face_nr[equal_to_previous]\n\n    x_face_coords = self.apply_masked_indexing(self.x_node, self.face_node)\n    y_face_coords = self.apply_masked_indexing(self.y_node, self.face_node)\n    x_edge_coords = self.x_node[edge_node]\n    y_edge_coords = self.y_node[edge_node]\n\n    return MeshData(\n        x_face_coords=x_face_coords,\n        y_face_coords=y_face_coords,\n        x_edge_coords=x_edge_coords,\n        y_edge_coords=y_edge_coords,\n        face_node=self.face_node,\n        n_nodes=self.n_nodes,\n        edge_node=edge_node,\n        edge_face_connectivity=edge_face,\n        face_edge_connectivity=face_edge_connectivity,\n        boundary_edge_nrs=boundary_edge_nrs,\n        verbose=verbose,\n    )\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.inputs.ShipsParameters","title":"<code>ShipsParameters</code>  <code>dataclass</code>","text":"<p>Data for ships going through the fairway for bank erosion simulation.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>ConfigFile</code> <p>Configuration file containing parameters.</p> required <code>velocity</code> <code>List[ndarray]</code> <p>Ship velocities for each bank.</p> required <code>number</code> <code>List[ndarray]</code> <p>Number of ships for each bank.</p> required <code>num_waves</code> <code>List[ndarray]</code> <p>Number of waves per ship for each bank.</p> required <code>draught</code> <code>List[ndarray]</code> <p>Draught of ships for each bank.</p> required <code>type</code> <code>List[ndarray]</code> <p>Type of ships for each bank.</p> required <code>slope</code> <code>List[ndarray]</code> <p>Slope values for each bank.</p> required <code>reed</code> <code>List[ndarray]</code> <p>Reed values for each bank.</p> required Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>@dataclass\nclass ShipsParameters:\n    \"\"\"Data for ships going through the fairway for bank erosion simulation.\n\n    Args:\n        config_file (ConfigFile):\n            Configuration file containing parameters.\n        velocity (List[np.ndarray]):\n            Ship velocities for each bank.\n        number (List[np.ndarray]):\n            Number of ships for each bank.\n        num_waves (List[np.ndarray]):\n            Number of waves per ship for each bank.\n        draught (List[np.ndarray]):\n            Draught of ships for each bank.\n        type (List[np.ndarray]):\n            Type of ships for each bank.\n        slope (List[np.ndarray]):\n            Slope values for each bank.\n        reed (List[np.ndarray]):\n            Reed values for each bank.\n    \"\"\"\n\n    config_file: ConfigFile\n    velocity: List[np.ndarray]\n    number: List[np.ndarray]\n    num_waves: List[np.ndarray]\n    draught: List[np.ndarray]\n    type: List[np.ndarray]\n    slope: List[np.ndarray]\n    reed: List[np.ndarray]\n\n    REED_DAMPING_COEFFICIENT = 8.5e-4\n    REED_DAMPING_EXPONENT = 0.8\n\n    @classmethod\n    def get_ship_data(\n        cls, num_stations_per_bank: List[int], config_file: ConfigFile\n    ) -&gt; \"ShipsParameters\":\n        \"\"\"Get ship parameters from the configuration file.\n\n        Args:\n            num_stations_per_bank (List[int]):\n                The number of stations per bank.\n            config_file (ConfigFile):\n                Configuration file containing parameters.\n\n        Returns:\n            ShipsParameters: An instance of ShipsParameters with parameters read from the config file.\n        \"\"\"\n\n        param_defs = cls._get_initial_parameter_definitions()\n        param_resolved = cls._get_parameters(\n            config_file, num_stations_per_bank, param_defs\n        )\n\n        param_dict = {\n            \"velocity\": param_resolved[\"vship\"],\n            \"number\": param_resolved[\"nship\"],\n            \"num_waves\": param_resolved[\"nwave\"],\n            \"draught\": param_resolved[\"draught\"],\n            \"type\": param_resolved[\"shiptype\"],\n            \"slope\": param_resolved[\"slope\"],\n            \"reed\": param_resolved[\"reed\"],\n        }\n\n        return cls(config_file, **param_dict)\n\n    @staticmethod\n    def _get_parameters(\n        config_file: ConfigFile,\n        num_stations_per_bank: List[int],\n        param_defs: List[Parameters],\n        level_i_str: str = \"\",\n    ) -&gt; Dict[str, np.ndarray]:\n        \"\"\"Resolve a list of Parameters with values from the configuration file.\"\"\"\n        param_resolved = {}\n\n        for param in param_defs:\n            param_resolved[f\"{param.name.lower()}\"] = config_file.get_parameter(\n                \"Erosion\",\n                f\"{param.name}{level_i_str}\",\n                num_stations_per_bank,\n                default=param.default,\n                valid=param.valid,\n                onefile=param.onefile,\n                positive=param.positive,\n                ext=param.ext,\n            )\n        return param_resolved\n\n    @classmethod\n    def _get_initial_parameter_definitions(cls) -&gt; List[Parameters]:\n        \"\"\"Get parameter definitions for discharge parameters.\n\n        Returns:\n            List[namedtuple]: List of parameter definitions.\n        \"\"\"\n        return [\n            Parameters(\"VShip\", None, None, True, True, None),\n            Parameters(\"NShip\", None, None, True, True, None),\n            Parameters(\"NWave\", 5, None, True, True, None),\n            Parameters(\"Draught\", None, None, True, True, None),\n            Parameters(\"ShipType\", None, [1, 2, 3], True, None, None),\n            Parameters(\"Slope\", 20, None, None, True, \"slp\"),\n            Parameters(\"Reed\", 0, None, None, True, \"rdd\"),\n        ]\n\n    def _get_discharge_parameter_definitions(self) -&gt; List[Parameters]:\n        \"\"\"Get parameter definitions for discharge parameters.\n\n        Returns:\n            List[namedtuple]: List of parameter definitions.\n        \"\"\"\n        return [\n            Parameters(\"VShip\", self.velocity, None, None, None, None),\n            Parameters(\"NShip\", self.number, None, None, None, None),\n            Parameters(\"NWave\", self.num_waves, None, None, None, None),\n            Parameters(\"Draught\", self.draught, None, None, None, None),\n            Parameters(\"ShipType\", self.type, [1, 2, 3], True, None, None),\n            Parameters(\"Slope\", self.slope, None, None, True, \"slp\"),\n            Parameters(\"Reed\", self.reed, None, None, True, \"rdd\"),\n        ]\n\n    @staticmethod\n    def _calculate_ship_derived_parameters(\n        slope_values: List[np.ndarray], reed_values: List[np.ndarray]\n    ) -&gt; Tuple[List[np.ndarray], List[np.ndarray]]:\n        \"\"\"Calculate derived parameters from slope and reed values.\n\n        Args:\n            slope_values (List[np.ndarray]): Slope values for each bank.\n            reed_values (List[np.ndarray]): Reed values for each bank.\n\n        Returns:\n            Tuple[List[np.ndarray], List[np.ndarray]]: Calculated mu_slope and mu_reed values.\n        \"\"\"\n        mu_slope = []\n        mu_reed = []\n\n        for ps, pr in zip(slope_values, reed_values):\n            # Calculate mu_slope (inverse of slope for non-zero values)\n            mus = ps.copy()\n            mus[mus &gt; 0] = 1.0 / mus[mus &gt; 0]\n            mu_slope.append(mus)\n\n            # Calculate mu_reed (empirical damping coefficient)\n            mu_reed.append(\n                ShipsParameters.REED_DAMPING_COEFFICIENT\n                * pr**ShipsParameters.REED_DAMPING_EXPONENT\n            )\n\n        return mu_slope, mu_reed\n\n    def read_discharge_parameters(\n        self,\n        level_i: int,\n        num_stations_per_bank: List[int],\n    ) -&gt; SingleLevelParameters:\n        \"\"\"Read Discharge level parameters.\n\n        Read all discharge-specific input arrays for level_i.\n\n        Args:\n            level_i (int):\n                The index of the discharge level.\n            num_stations_per_bank (List[int]):\n                The number of stations per bank.\n\n        Returns:\n            SingleLevelParameters: The discharge level parameters.\n        \"\"\"\n        param_defs = self._get_discharge_parameter_definitions()\n        param_resolved = self._get_parameters(\n            self.config_file, num_stations_per_bank, param_defs, f\"{level_i + 1}\"\n        )\n\n        mu_slope, mu_reed = self._calculate_ship_derived_parameters(\n            param_resolved[\"slope\"], param_resolved[\"reed\"]\n        )\n\n        return SingleLevelParameters.from_column_arrays(\n            {\n                \"id\": level_i,\n                \"ship_velocity\": param_resolved[\"vship\"],\n                \"num_ship\": param_resolved[\"nship\"],\n                \"num_waves_per_ship\": param_resolved[\"nwave\"],\n                \"ship_draught\": param_resolved[\"draught\"],\n                \"ship_type\": param_resolved[\"shiptype\"],\n                \"par_slope\": param_resolved[\"slope\"],\n                \"par_reed\": param_resolved[\"reed\"],\n                \"mu_slope\": mu_slope,\n                \"mu_reed\": mu_reed,\n            },\n            SingleParameters,\n        )\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.inputs.ShipsParameters.get_ship_data","title":"<code>get_ship_data(num_stations_per_bank: List[int], config_file: ConfigFile) -&gt; ShipsParameters</code>  <code>classmethod</code>","text":"<p>Get ship parameters from the configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>num_stations_per_bank</code> <code>List[int]</code> <p>The number of stations per bank.</p> required <code>config_file</code> <code>ConfigFile</code> <p>Configuration file containing parameters.</p> required <p>Returns:</p> Name Type Description <code>ShipsParameters</code> <code>ShipsParameters</code> <p>An instance of ShipsParameters with parameters read from the config file.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>@classmethod\ndef get_ship_data(\n    cls, num_stations_per_bank: List[int], config_file: ConfigFile\n) -&gt; \"ShipsParameters\":\n    \"\"\"Get ship parameters from the configuration file.\n\n    Args:\n        num_stations_per_bank (List[int]):\n            The number of stations per bank.\n        config_file (ConfigFile):\n            Configuration file containing parameters.\n\n    Returns:\n        ShipsParameters: An instance of ShipsParameters with parameters read from the config file.\n    \"\"\"\n\n    param_defs = cls._get_initial_parameter_definitions()\n    param_resolved = cls._get_parameters(\n        config_file, num_stations_per_bank, param_defs\n    )\n\n    param_dict = {\n        \"velocity\": param_resolved[\"vship\"],\n        \"number\": param_resolved[\"nship\"],\n        \"num_waves\": param_resolved[\"nwave\"],\n        \"draught\": param_resolved[\"draught\"],\n        \"type\": param_resolved[\"shiptype\"],\n        \"slope\": param_resolved[\"slope\"],\n        \"reed\": param_resolved[\"reed\"],\n    }\n\n    return cls(config_file, **param_dict)\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#dfastbe.bank_erosion.data_models.inputs.ShipsParameters.read_discharge_parameters","title":"<code>read_discharge_parameters(level_i: int, num_stations_per_bank: List[int]) -&gt; SingleLevelParameters</code>","text":"<p>Read Discharge level parameters.</p> <p>Read all discharge-specific input arrays for level_i.</p> <p>Parameters:</p> Name Type Description Default <code>level_i</code> <code>int</code> <p>The index of the discharge level.</p> required <code>num_stations_per_bank</code> <code>List[int]</code> <p>The number of stations per bank.</p> required <p>Returns:</p> Name Type Description <code>SingleLevelParameters</code> <code>SingleLevelParameters</code> <p>The discharge level parameters.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>def read_discharge_parameters(\n    self,\n    level_i: int,\n    num_stations_per_bank: List[int],\n) -&gt; SingleLevelParameters:\n    \"\"\"Read Discharge level parameters.\n\n    Read all discharge-specific input arrays for level_i.\n\n    Args:\n        level_i (int):\n            The index of the discharge level.\n        num_stations_per_bank (List[int]):\n            The number of stations per bank.\n\n    Returns:\n        SingleLevelParameters: The discharge level parameters.\n    \"\"\"\n    param_defs = self._get_discharge_parameter_definitions()\n    param_resolved = self._get_parameters(\n        self.config_file, num_stations_per_bank, param_defs, f\"{level_i + 1}\"\n    )\n\n    mu_slope, mu_reed = self._calculate_ship_derived_parameters(\n        param_resolved[\"slope\"], param_resolved[\"reed\"]\n    )\n\n    return SingleLevelParameters.from_column_arrays(\n        {\n            \"id\": level_i,\n            \"ship_velocity\": param_resolved[\"vship\"],\n            \"num_ship\": param_resolved[\"nship\"],\n            \"num_waves_per_ship\": param_resolved[\"nwave\"],\n            \"ship_draught\": param_resolved[\"draught\"],\n            \"ship_type\": param_resolved[\"shiptype\"],\n            \"par_slope\": param_resolved[\"slope\"],\n            \"par_reed\": param_resolved[\"reed\"],\n            \"mu_slope\": mu_slope,\n            \"mu_reed\": mu_reed,\n        },\n        SingleParameters,\n    )\n</code></pre>"},{"location":"api/bank_erosion/bank_erosion.html#workflow","title":"Workflow","text":"<p>The typical workflow for bank erosion calculation is:</p> <ol> <li>Initialize the Erosion object with a configuration file</li> <li>Call the <code>run</code> method to start the erosion calculation process</li> <li>The <code>run</code> method orchestrates the entire process:</li> <li>Processes the river axis</li> <li>Gets fairway data</li> <li>Calculates bank-fairway distance</li> <li>Prepares initial conditions</li> <li>Processes discharge levels</li> <li>Computes erosion per level</li> <li>Post-processes results</li> <li>Writes output files</li> <li>Generates plots</li> </ol>"},{"location":"api/bank_erosion/bank_erosion.html#usage-example","title":"Usage Example","text":"<pre><code>from dfastbe.io.config import ConfigFile\nfrom dfastbe.bank_erosion.bank_erosion import Erosion\n\n# Load configuration file\nconfig_file = ConfigFile.read(\"config.cfg\")\n\n# Initialize Erosion object\nerosion = Erosion(config_file)\n\n# Run erosion calculation\nerosion.run()\n</code></pre> <p>For more details on the specific methods and classes, refer to the API reference below.</p>"},{"location":"api/bank_erosion/debugger.html","title":"Bank Erosion Debugger","text":"<p>The Bank Erosion Debugger module provides utilities for debugging and outputting bank erosion calculations in the D-FAST Bank Erosion software.</p>"},{"location":"api/bank_erosion/debugger.html#overview","title":"Overview","text":"<p>The Bank Erosion Debugger module contains a class and utility functions for writing debug information about bank erosion calculations to shapefiles and CSV files. This information can be used to analyze and troubleshoot bank erosion calculations.</p>"},{"location":"api/bank_erosion/debugger.html#components","title":"Components","text":"<p>The Bank Erosion Debugger module consists of the following components:</p>"},{"location":"api/bank_erosion/debugger.html#debugger-class","title":"Debugger Class","text":"<p>The Debugger class provides methods for writing debug information about bank erosion calculations, such as:</p> <ul> <li>last_discharge_level: Writes debug information about the last discharge level to a shapefile and CSV file</li> <li>middle_levels: Writes debug information about the middle discharge levels to a shapefile and CSV file</li> <li>_write_data: Writes data to a shapefile and CSV file</li> </ul>"},{"location":"api/bank_erosion/debugger.html#dfastbe.bank_erosion.debugger","title":"<code>dfastbe.bank_erosion.debugger</code>","text":"<p>Bank Erosion Debugger.</p>"},{"location":"api/bank_erosion/debugger.html#dfastbe.bank_erosion.debugger.Debugger","title":"<code>Debugger</code>","text":"<p>Class to handle debugging and output of bank erosion calculations.</p> Source code in <code>src/dfastbe/bank_erosion/debugger.py</code> <pre><code>class Debugger:\n    \"\"\"Class to handle debugging and output of bank erosion calculations.\"\"\"\n\n    def __init__(self, crs: str, output_dir: str):\n        \"\"\"Debugger constructor.\"\"\"\n        self.crs = crs\n        self.output_dir = output_dir\n\n    def last_discharge_level(\n        self,\n        bank_index: int,\n        single_bank: SingleBank,\n        fairway_data: FairwayData,\n        erosion_inputs: SingleErosion,\n        single_parameters: SingleParameters,\n        single_calculation: SingleCalculation,\n    ):\n        \"\"\"Write the last discharge level to a shapefile and CSV file.\"\"\"\n        bank_coords_mind = single_bank.get_mid_points()\n        params = {\n            \"chainage\": single_bank.bank_chainage_midpoints,\n            \"x\": bank_coords_mind[:, 0],\n            \"y\": bank_coords_mind[:, 1],\n            \"iface_fw\": single_bank.fairway_face_indices,\n            \"iface_bank\": single_bank.bank_face_indices,\n            \"bank_height\": single_bank.height,\n            \"segment_length\": single_bank.segment_length,\n            \"zw0\": fairway_data.fairway_initial_water_levels[bank_index],\n            \"ship_velocity\": single_parameters.ship_velocity,\n            \"ship_type\": single_parameters.ship_type,\n            \"draught\": single_parameters.ship_draught,\n            \"mu_slp\": single_parameters.mu_slope,\n            \"bank_fairway_dist\": single_bank.fairway_distances,\n            \"fairway_wave_reduction_distance\": erosion_inputs.wave_fairway_distance_0,\n            \"fairway_wave_disappear_distance\": erosion_inputs.wave_fairway_distance_1,\n            \"water_depth_fairway\": single_calculation.water_depth,\n            \"dike_height\": erosion_inputs.bank_protection_level,\n            \"erosion_distance\": single_calculation.erosion_distance_eq,\n            \"erosion_volume\": single_calculation.erosion_volume_eq,\n        }\n\n        path = f\"{str(self.output_dir)}/debug.EQ.B{bank_index + 1}\"\n        bank_coords_geo = single_bank.get_mid_points(as_geo_series=True, crs=self.crs)\n        self._write_data(bank_coords_geo, params, path)\n\n    def middle_levels(\n        self,\n        bank_ind: int,\n        q_level: int,\n        single_bank: SingleBank,\n        fairway_data: FairwayData,\n        erosion_inputs: SingleErosion,\n        single_parameters: SingleParameters,\n        single_calculation: SingleCalculation,\n    ):\n        \"\"\"Write the middle levels to a shapefile and CSV file.\"\"\"\n        bank_coords_mind = single_bank.get_mid_points()\n        params = {\n            \"chainage\": single_bank.bank_chainage_midpoints,\n            \"x\": bank_coords_mind[:, 0],\n            \"y\": bank_coords_mind[:, 1],\n            \"iface_fw\": single_bank.fairway_face_indices,\n            \"iface_bank\": single_bank.bank_face_indices,\n            \"velocity\": single_calculation.bank_velocity,\n            \"bank_height\": single_bank.height,\n            \"segment_length\": single_bank.segment_length,\n            \"zw\": single_calculation.water_level,\n            \"zw0\": fairway_data.fairway_initial_water_levels[bank_ind],\n            \"tauc\": erosion_inputs.tauc,\n            \"num_ship\": single_parameters.num_ship,\n            \"ship_velocity\": single_parameters.ship_velocity,\n            \"num_waves_per_ship\": single_parameters.num_waves_per_ship,\n            \"ship_type\": single_parameters.ship_type,\n            \"draught\": single_parameters.ship_draught,\n            \"mu_slp\": single_parameters.mu_slope,\n            \"mu_reed\": single_parameters.mu_reed,\n            \"dist_fw\": single_bank.fairway_distances,\n            \"fairway_wave_reduction_distance\": erosion_inputs.wave_fairway_distance_0,\n            \"fairway_wave_disappear_distance\": erosion_inputs.wave_fairway_distance_1,\n            \"water_depth_fairway\": single_calculation.water_depth,\n            \"chez\": single_calculation.chezy,\n            \"dike_height\": erosion_inputs.bank_protection_level,\n            \"erosion_distance\": single_calculation.erosion_distance_tot,\n            \"erosion_volume\": single_calculation.erosion_volume_tot,\n            \"erosion_distance_shipping\": single_calculation.erosion_distance_shipping,\n            \"erosion_distance_flow\": single_calculation.erosion_distance_flow,\n        }\n        path = f\"{str(self.output_dir)}/debug.Q{q_level + 1}.B{bank_ind + 1}\"\n        bank_coords_geo = single_bank.get_mid_points(as_geo_series=True, crs=self.crs)\n        self._write_data(bank_coords_geo, params, path)\n\n    @staticmethod\n    def _write_data(coords: GeoSeries, data: Dict[str, np.ndarray], path: str):\n        \"\"\"Write the data to a shapefile and CSV file.\"\"\"\n        csv_path = f\"{path}.csv\"\n        shp_path = f\"{path}.shp\"\n        _write_shp(coords, data, shp_path)\n        _write_csv(data, csv_path)\n</code></pre>"},{"location":"api/bank_erosion/debugger.html#dfastbe.bank_erosion.debugger.Debugger.__init__","title":"<code>__init__(crs: str, output_dir: str)</code>","text":"<p>Debugger constructor.</p> Source code in <code>src/dfastbe/bank_erosion/debugger.py</code> <pre><code>def __init__(self, crs: str, output_dir: str):\n    \"\"\"Debugger constructor.\"\"\"\n    self.crs = crs\n    self.output_dir = output_dir\n</code></pre>"},{"location":"api/bank_erosion/debugger.html#dfastbe.bank_erosion.debugger.Debugger.last_discharge_level","title":"<code>last_discharge_level(bank_index: int, single_bank: SingleBank, fairway_data: FairwayData, erosion_inputs: SingleErosion, single_parameters: SingleParameters, single_calculation: SingleCalculation)</code>","text":"<p>Write the last discharge level to a shapefile and CSV file.</p> Source code in <code>src/dfastbe/bank_erosion/debugger.py</code> <pre><code>def last_discharge_level(\n    self,\n    bank_index: int,\n    single_bank: SingleBank,\n    fairway_data: FairwayData,\n    erosion_inputs: SingleErosion,\n    single_parameters: SingleParameters,\n    single_calculation: SingleCalculation,\n):\n    \"\"\"Write the last discharge level to a shapefile and CSV file.\"\"\"\n    bank_coords_mind = single_bank.get_mid_points()\n    params = {\n        \"chainage\": single_bank.bank_chainage_midpoints,\n        \"x\": bank_coords_mind[:, 0],\n        \"y\": bank_coords_mind[:, 1],\n        \"iface_fw\": single_bank.fairway_face_indices,\n        \"iface_bank\": single_bank.bank_face_indices,\n        \"bank_height\": single_bank.height,\n        \"segment_length\": single_bank.segment_length,\n        \"zw0\": fairway_data.fairway_initial_water_levels[bank_index],\n        \"ship_velocity\": single_parameters.ship_velocity,\n        \"ship_type\": single_parameters.ship_type,\n        \"draught\": single_parameters.ship_draught,\n        \"mu_slp\": single_parameters.mu_slope,\n        \"bank_fairway_dist\": single_bank.fairway_distances,\n        \"fairway_wave_reduction_distance\": erosion_inputs.wave_fairway_distance_0,\n        \"fairway_wave_disappear_distance\": erosion_inputs.wave_fairway_distance_1,\n        \"water_depth_fairway\": single_calculation.water_depth,\n        \"dike_height\": erosion_inputs.bank_protection_level,\n        \"erosion_distance\": single_calculation.erosion_distance_eq,\n        \"erosion_volume\": single_calculation.erosion_volume_eq,\n    }\n\n    path = f\"{str(self.output_dir)}/debug.EQ.B{bank_index + 1}\"\n    bank_coords_geo = single_bank.get_mid_points(as_geo_series=True, crs=self.crs)\n    self._write_data(bank_coords_geo, params, path)\n</code></pre>"},{"location":"api/bank_erosion/debugger.html#dfastbe.bank_erosion.debugger.Debugger.middle_levels","title":"<code>middle_levels(bank_ind: int, q_level: int, single_bank: SingleBank, fairway_data: FairwayData, erosion_inputs: SingleErosion, single_parameters: SingleParameters, single_calculation: SingleCalculation)</code>","text":"<p>Write the middle levels to a shapefile and CSV file.</p> Source code in <code>src/dfastbe/bank_erosion/debugger.py</code> <pre><code>def middle_levels(\n    self,\n    bank_ind: int,\n    q_level: int,\n    single_bank: SingleBank,\n    fairway_data: FairwayData,\n    erosion_inputs: SingleErosion,\n    single_parameters: SingleParameters,\n    single_calculation: SingleCalculation,\n):\n    \"\"\"Write the middle levels to a shapefile and CSV file.\"\"\"\n    bank_coords_mind = single_bank.get_mid_points()\n    params = {\n        \"chainage\": single_bank.bank_chainage_midpoints,\n        \"x\": bank_coords_mind[:, 0],\n        \"y\": bank_coords_mind[:, 1],\n        \"iface_fw\": single_bank.fairway_face_indices,\n        \"iface_bank\": single_bank.bank_face_indices,\n        \"velocity\": single_calculation.bank_velocity,\n        \"bank_height\": single_bank.height,\n        \"segment_length\": single_bank.segment_length,\n        \"zw\": single_calculation.water_level,\n        \"zw0\": fairway_data.fairway_initial_water_levels[bank_ind],\n        \"tauc\": erosion_inputs.tauc,\n        \"num_ship\": single_parameters.num_ship,\n        \"ship_velocity\": single_parameters.ship_velocity,\n        \"num_waves_per_ship\": single_parameters.num_waves_per_ship,\n        \"ship_type\": single_parameters.ship_type,\n        \"draught\": single_parameters.ship_draught,\n        \"mu_slp\": single_parameters.mu_slope,\n        \"mu_reed\": single_parameters.mu_reed,\n        \"dist_fw\": single_bank.fairway_distances,\n        \"fairway_wave_reduction_distance\": erosion_inputs.wave_fairway_distance_0,\n        \"fairway_wave_disappear_distance\": erosion_inputs.wave_fairway_distance_1,\n        \"water_depth_fairway\": single_calculation.water_depth,\n        \"chez\": single_calculation.chezy,\n        \"dike_height\": erosion_inputs.bank_protection_level,\n        \"erosion_distance\": single_calculation.erosion_distance_tot,\n        \"erosion_volume\": single_calculation.erosion_volume_tot,\n        \"erosion_distance_shipping\": single_calculation.erosion_distance_shipping,\n        \"erosion_distance_flow\": single_calculation.erosion_distance_flow,\n    }\n    path = f\"{str(self.output_dir)}/debug.Q{q_level + 1}.B{bank_ind + 1}\"\n    bank_coords_geo = single_bank.get_mid_points(as_geo_series=True, crs=self.crs)\n    self._write_data(bank_coords_geo, params, path)\n</code></pre>"},{"location":"api/bank_erosion/debugger.html#utility-functions","title":"Utility Functions","text":"<p>The Bank Erosion Debugger module includes utility functions for writing data to files:</p> <ul> <li>_write_shp: Writes data to a shapefile</li> <li>_write_csv: Writes data to a CSV file</li> </ul>"},{"location":"api/bank_erosion/debugger.html#usage-example","title":"Usage Example","text":"<pre><code>from dfastbe.bank_erosion.debugger import Debugger\nfrom dfastbe.io.config import ConfigFile\nfrom dfastbe.bank_erosion.bank_erosion import Erosion\n\n\n# Load configuration file\nconfig_file = ConfigFile.read(\"config.cfg\")\n\n# Initialize Erosion object\nerosion = Erosion(config_file)\n\n# Access debugger\ndebugger = erosion.debugger\n\n# Write debug information for the last discharge level\ndebugger.last_discharge_level(\n    bank_index=0,\n    single_bank=bank_data.left,\n    fairway_data=fairway_data,\n    erosion_inputs=erosion_inputs.left,\n    single_parameters=level_parameters.left,\n    single_calculation=single_calculation,\n    bank_height=bank_height\n)\n</code></pre> <p>For more details on the specific classes and functions, refer to the API reference below.</p>"},{"location":"api/bank_erosion/erosion_calculation.html","title":"Erosion Calculation Process","text":"<p>This document explains the bank erosion calculation process in the D-FAST Bank Erosion software, focusing on the <code>compute_erosion_per_level</code> method in the <code>Erosion</code> class.</p>"},{"location":"api/bank_erosion/erosion_calculation.html#overview","title":"Overview","text":"<p>The <code>compute_erosion_per_level</code> method is a core component of the bank erosion calculation process. It calculates the bank erosion for a specific discharge level, processing both the left and right banks of the river. The method computes various parameters such as bank velocity, water depth, and erosion distances, and returns a <code>SingleDischargeLevel</code> object containing the results for both banks.</p>"},{"location":"api/bank_erosion/erosion_calculation.html#data-model","title":"Data Model","text":"<p>Before diving into the calculation process, it's important to understand the data model used in the bank erosion calculations:</p> <pre><code>classDiagram\n    class DischargeLevels {\n        +List~SingleDischargeLevel~ levels\n        +__getitem__(int)\n        +__iter__()\n        +append(SingleDischargeLevel)\n        +get_max_hfw_level()\n        +total_erosion_volume()\n    }\n\n    class SingleDischargeLevel {\n        +SingleCalculation left\n        +SingleCalculation right\n        +float hfw_max\n    }\n\n    class SingleCalculation {\n        +array bank_velocity\n        +array water_level\n        +array chezy\n        +array erosion_distance_tot\n        +array erosion_volume_tot\n        +array erosion_distance_shipping\n        +array erosion_distance_flow\n        +array erosion_distance_eq\n        +array erosion_volume_eq\n        +array volume_per_discharge\n    }\n\n    class SingleLevelParameters {\n        +SingleParameters left\n        +SingleParameters right\n    }\n\n    class SingleParameters {\n        +float discharge\n        +float probability\n        +dict ship_parameters\n    }\n\n    DischargeLevels o-- SingleDischargeLevel : contains\n    SingleDischargeLevel *-- SingleCalculation : has left/right\n    SingleLevelParameters *-- SingleParameters : has left/right</code></pre> <p>The <code>DischargeLevels</code> class contains a list of <code>SingleDischargeLevel</code> objects, each representing the erosion calculation results for a specific discharge level. Each <code>SingleDischargeLevel</code> has left and right attributes of type <code>SingleCalculation</code>, which store the calculation results for the left and right banks, respectively.</p>"},{"location":"api/bank_erosion/erosion_calculation.html#calculation-process","title":"Calculation Process","text":"<p>The <code>compute_erosion_per_level</code> method follows these steps:</p> <pre><code>flowchart TD\n    A[Initialize variables] --&gt; B[Loop through each bank]\n    B --&gt; C[Calculate bank velocity]\n    C --&gt; D{Is first level?}\n    D -- Yes --&gt; E[Calculate bank height]\n    D -- No --&gt; F[Get fairway data]\n    E --&gt; F\n    F --&gt; F1[Extract water level, chezy, and water depth]\n    F1 --&gt; G{Is last level?}\n    G -- Yes --&gt; H[Calculate equilibrium erosion]\n    G -- No --&gt; I[Calculate bank erosion dynamics]\n    H --&gt; I\n    I --&gt; J[Accumulate eroded volumes per km]\n    J --&gt; K[Add calculation to results]\n    K --&gt; L{More banks?}\n    L -- Yes --&gt; B\n    L -- No --&gt; M[Create SingleDischargeLevel object]\n    M --&gt; N[Return results]</code></pre>"},{"location":"api/bank_erosion/erosion_calculation.html#detailed-steps","title":"Detailed Steps","text":"<ol> <li>Initialize variables:</li> <li>Create an array to store eroded volumes per kilometer</li> <li>Initialize the maximum water depth to 0</li> <li> <p>Create an empty list to store calculation results for each bank</p> </li> <li> <p>Loop through each bank (left and right):</p> </li> <li> <p>Create a new <code>SingleCalculation</code> object to store results</p> </li> <li> <p>Calculate bank velocity:</p> </li> <li> <p>Compute the velocity along the bank using the simulation data</p> </li> <li> <p>Calculate bank height (only for the first level):</p> </li> <li> <p>Determine the maximum bed elevation per cell along the bank</p> </li> <li> <p>Get fairway data:</p> </li> <li>Get fairway face indices from the bank</li> <li>Retrieve fairway data (water level, chezy, water depth) in a single call</li> <li>Extract and assign the values to the SingleCalculation object</li> <li> <p>Update the maximum water depth if necessary</p> </li> <li> <p>Calculate equilibrium erosion (only for the last level):</p> </li> <li>Compute the equilibrium erosion distance and volume using the <code>ErosionCalculator</code></li> <li> <p>Store the results in the <code>SingleCalculation</code> object</p> </li> <li> <p>Calculate bank erosion dynamics:</p> </li> <li>Compute the bank erosion during the current discharge level using the <code>ErosionCalculator</code></li> <li> <p>This includes calculating erosion due to both flow and shipping</p> </li> <li> <p>Accumulate eroded volumes per kilometer:</p> </li> <li>Aggregate the eroded volumes by kilometer bins</li> <li>Store the results in the <code>SingleCalculation</code> object</li> <li> <p>Add the volumes to the total eroded volumes array</p> </li> <li> <p>Output debug information (if debug mode is enabled):</p> </li> <li> <p>Write detailed information about the calculations to files</p> </li> <li> <p>Create a SingleDischargeLevel object:</p> <ul> <li>Combine the calculation results for both banks into a single object</li> <li>Include the maximum water depth in the fairway</li> </ul> </li> <li> <p>Return results:</p> <ul> <li>Return the <code>SingleDischargeLevel</code> object and the eroded volumes array</li> </ul> </li> </ol>"},{"location":"api/bank_erosion/erosion_calculation.html#sequence-diagram","title":"Sequence Diagram","text":"<p>The following sequence diagram illustrates the interaction between different components during the execution of the <code>compute_erosion_per_level</code> method:</p> <pre><code>sequenceDiagram\n    participant Erosion\n    participant BankData\n    participant SimulationData\n    participant ErosionCalculator\n    participant SingleCalculation\n    participant SingleDischargeLevel\n\n    Erosion-&gt;&gt;Erosion: compute_erosion_per_level(level_i, ...)\n    loop for each bank (left and right)\n        Erosion-&gt;&gt;SingleCalculation: create new calculation object\n        Erosion-&gt;&gt;SimulationData: calculate_bank_velocity(bank_i, vel_dx)\n        SimulationData--&gt;&gt;Erosion: bank_velocity\n        Erosion-&gt;&gt;SingleCalculation: set bank_velocity\n\n        alt is first level\n            Erosion-&gt;&gt;SimulationData: calculate_bank_height(bank_i, zb_dx)\n            SimulationData--&gt;&gt;Erosion: bank_height\n        end\n\n        Erosion-&gt;&gt;SimulationData: get_fairway_data(fairway_face_indices)\n        SimulationData--&gt;&gt;Erosion: data (containing water_level, chezy, water_depth)\n        Erosion-&gt;&gt;SingleCalculation: set water_level, chezy, water_depth from data\n\n        alt is last level\n            Erosion-&gt;&gt;ErosionCalculator: comp_erosion_eq(...)\n            ErosionCalculator--&gt;&gt;Erosion: erosion_distance_eq, erosion_volume_eq\n            Erosion-&gt;&gt;SingleCalculation: set erosion_distance_eq, erosion_volume_eq\n        end\n\n        Erosion-&gt;&gt;ErosionCalculator: compute_bank_erosion_dynamics(...)\n        ErosionCalculator--&gt;&gt;Erosion: updated SingleCalculation\n\n        Erosion-&gt;&gt;Erosion: get_km_eroded_volume(...)\n        Erosion-&gt;&gt;SingleCalculation: set volume_per_discharge\n        Erosion-&gt;&gt;Erosion: append to par_list\n\n        alt debug mode enabled\n            Erosion-&gt;&gt;Erosion: _debug_output(...)\n        end\n    end\n\n    Erosion-&gt;&gt;SingleDischargeLevel: create with left=par_list[0], right=par_list[1]\n    Erosion--&gt;&gt;Erosion: return level_calculation, dvol_bank</code></pre>"},{"location":"api/bank_erosion/erosion_calculation.html#data-flow","title":"Data Flow","text":"<p>The data flow in the <code>compute_erosion_per_level</code> method can be visualized as follows:</p> <pre><code>flowchart LR\n    subgraph Inputs\n        A[bank_data]\n        B[simulation_data]\n        C[fairway_data]\n        D[single_parameters]\n        E[erosion_inputs]\n        F[km_bin]\n    end\n\n    subgraph Processing\n        G[Calculate bank velocity]\n        H[Calculate bank height]\n        I1[Get fairway data]\n        I2[Extract water level, chezy, water depth]\n        J[Calculate equilibrium erosion]\n        K[Calculate bank erosion dynamics]\n        L[Accumulate eroded volumes]\n    end\n\n    subgraph Outputs\n        M[SingleDischargeLevel]\n        N[dvol_bank]\n    end\n\n    A --&gt; G\n    B --&gt; G\n    B --&gt; H\n    B --&gt; I1\n    A --&gt; I1\n    I1 --&gt; I2\n\n    C --&gt; J\n    D --&gt; J\n    E --&gt; J\n    A --&gt; J\n    I2 --&gt; J\n\n    G --&gt; K\n    H --&gt; K\n    I2 --&gt; K\n    C --&gt; K\n    D --&gt; K\n    E --&gt; K\n\n    K --&gt; L\n    F --&gt; L\n    A --&gt; L\n\n    L --&gt; M\n    L --&gt; N\n    J --&gt; M</code></pre>"},{"location":"api/bank_erosion/erosion_calculation.html#key-calculations","title":"Key Calculations","text":"<p>The <code>compute_erosion_per_level</code> method relies on two key calculations performed by the <code>ErosionCalculator</code>:</p> <ol> <li>Equilibrium Erosion Calculation (for the last discharge level):</li> <li>Calculates the equilibrium bank erosion distance and volume</li> <li>Takes into account bank height, water level, and ship-induced wave height</li> <li> <p>Returns the maximum potential erosion distance and volume</p> </li> <li> <p>Bank Erosion Dynamics Calculation (for all discharge levels):</p> </li> <li>Calculates the bank erosion during a specific discharge level</li> <li>Computes erosion due to both flow and shipping</li> <li>Takes into account bank velocity, water level, and ship parameters</li> <li>Returns the erosion distance and volume for the current level</li> </ol>"},{"location":"api/bank_erosion/erosion_calculation.html#physical-processes-and-mathematical-models","title":"Physical Processes and Mathematical Models","text":"<p>The erosion calculation process is based on physical processes and mathematical models that describe the interaction between water flow, ship waves, and bank material. This section explains the key formulas and calculations used in the <code>ErosionCalculator</code> class.</p>"},{"location":"api/bank_erosion/erosion_calculation.html#ship-induced-wave-height-calculation","title":"Ship-Induced Wave Height Calculation","text":"<p>The height of waves generated by passing ships is a key factor in bank erosion. The wave height at the bank is calculated using the following formula:</p> <pre><code>graph TD\n    A[Calculate ship coefficient a1 based on ship type] --&gt; B[Calculate Froude number]\n    B --&gt; C[Limit Froude number to 0.8]\n    C --&gt; D[Calculate wave attenuation factor A]\n    D --&gt; E[Calculate wave height h0]</code></pre> <ol> <li>Ship coefficient (a1) depends on ship type:</li> <li>Multiple barge convoy: <code>a1 = 0.5</code></li> <li>RHK ship / motor ship: <code>a1 = 0.28 * ship_draught^1.25</code></li> <li> <p>Towboat: <code>a1 = 1</code></p> </li> <li> <p>Froude number is calculated as:    <pre><code>froude = ship_velocity / \u221a(h * g)\n</code></pre>    where:</p> </li> <li><code>ship_velocity</code> is the velocity of the ship [m/s]</li> <li><code>h</code> is the water depth at the fairway [m]</li> <li><code>g</code> is the gravitational acceleration [m/s\u00b2]</li> </ol> <p>The Froude number is limited to 0.8 to prevent unrealistic wave heights.</p> <ol> <li>Wave attenuation factor (A) accounts for the reduction in wave height with distance from the fairway:    <pre><code>A = 0.5 * (1 + cos((bank_fairway_dist - fairway_wave_disappear_distance) / (fairway_wave_reduction_distance - fairway_wave_disappear_distance) * \u03c0))\n</code></pre>    with the following conditions:</li> <li>If <code>bank_fairway_dist &lt; fairway_wave_disappear_distance</code>, then <code>A = 1</code></li> <li> <p>If <code>bank_fairway_dist &gt; fairway_wave_reduction_distance</code>, then <code>A = 0</code></p> </li> <li> <p>Wave height (h0) is calculated as:    <pre><code>h0 = a1 * h * (bank_fairway_dist / h)^(-1/3) * froude^4 * A\n</code></pre></p> </li> </ol>"},{"location":"api/bank_erosion/erosion_calculation.html#equilibrium-erosion-calculation","title":"Equilibrium Erosion Calculation","text":"<p>The equilibrium erosion represents the maximum potential erosion that could occur over a very long time period. It is calculated as follows:</p> <pre><code>graph TD\n    A[Calculate ship-induced wave height h0] --&gt; B[Determine upper bound of erosion zone zup]\n    B --&gt; C[Determine lower bound of erosion zone zdo]\n    C --&gt; D[Calculate height of erosion zone ht]\n    D --&gt; E[Calculate height above erosion zone hs]\n    E --&gt; F[Calculate equilibrium erosion distance]\n    F --&gt; G[Calculate equilibrium erosion volume]</code></pre> <ol> <li> <p>Upper bound of erosion zone (zup):    <pre><code>zup = min(bank_height, water_level_fairway_ref + 2 * h0)\n</code></pre></p> </li> <li> <p>Lower bound of erosion zone (zdo):    <pre><code>zdo = max(water_level_fairway_ref - 2 * h0, bank_protection_level)\n</code></pre></p> </li> <li> <p>Height of erosion zone (ht):    <pre><code>ht = max(zup - zdo, 0)\n</code></pre></p> </li> <li> <p>Height above erosion zone (hs):    <pre><code>hs = max(bank_height - water_level_fairway_ref + 2 * h0, 0)\n</code></pre></p> </li> <li> <p>Equilibrium erosion distance (eq_erosion_distance):    <pre><code>eq_erosion_distance = ht / mu_slope\n</code></pre>    where <code>mu_slope</code> is the bank slope [-]</p> </li> <li> <p>Equilibrium erosion volume (eq_erosion_volume):    <pre><code>eq_erosion_volume = (0.5 * ht + hs) * eq_erosion_distance * segment_length\n</code></pre></p> </li> </ol>"},{"location":"api/bank_erosion/erosion_calculation.html#bank-erosion-dynamics-calculation","title":"Bank Erosion Dynamics Calculation","text":"<p>The bank erosion dynamics calculation determines the erosion that occurs during a specific discharge level, taking into account both flow-induced and ship-induced erosion.</p>"},{"location":"api/bank_erosion/erosion_calculation.html#flow-induced-erosion","title":"Flow-Induced Erosion","text":"<p>Flow-induced erosion occurs when the flow velocity exceeds the critical velocity for the bank material:</p> <pre><code>graph TD\n    A[Calculate erosion coefficient] --&gt; B[Calculate critical velocity]\n    B --&gt; C[Calculate velocity ratio]\n    C --&gt; D[Calculate flow-induced erosion distance]\n    D --&gt; E[Calculate flow-induced erosion volume]</code></pre> <ol> <li> <p>Erosion coefficient (erosion_coef):    <pre><code>erosion_coef = 0.2 * \u221a(tauc) * 10^-6\n</code></pre>    where <code>tauc</code> is the critical shear stress [N/m\u00b2]</p> </li> <li> <p>Critical velocity (critical_velocity):    <pre><code>critical_velocity = \u221a(tauc / (water_density * chezy\u00b2 / g))\n</code></pre>    where:</p> </li> <li><code>water_density</code> is the density of water [kg/m\u00b3]</li> <li><code>chezy</code> is the Chezy coefficient [m^0.5/s]</li> <li> <p><code>g</code> is the gravitational acceleration [m/s\u00b2]</p> </li> <li> <p>Velocity ratio (crit_ratio):    <pre><code>crit_ratio = (vel / critical_velocity)\u00b2\n</code></pre>    if <code>vel &gt; critical_velocity</code> and <code>water_level &gt; bank_protection_level</code></p> </li> <li> <p>Flow-induced erosion distance (erosion_distance_flow):    <pre><code>erosion_distance_flow = erosion_coef * (crit_ratio - 1) * time_erosion * sec_year\n</code></pre>    where:</p> </li> <li><code>time_erosion</code> is the erosion period [yr]</li> <li> <p><code>sec_year</code> is the number of seconds in a year (3600 * 24 * 365)</p> </li> <li> <p>Flow-induced erosion volume (dv_flow):    <pre><code>dv_flow = erosion_distance_flow * segment_length * h_line_flow\n</code></pre>    where <code>h_line_flow</code> is the height of the bank subject to flow erosion</p> </li> </ol>"},{"location":"api/bank_erosion/erosion_calculation.html#ship-induced-erosion","title":"Ship-Induced Erosion","text":"<p>Ship-induced erosion occurs due to waves generated by passing ships:</p> <pre><code>graph TD\n    A[Calculate ship wave period] --&gt; B[Calculate total wave exposure time]\n    B --&gt; C[Calculate strength coefficient]\n    C --&gt; D[Calculate ship-induced erosion distance]\n    D --&gt; E[Calculate ship-induced erosion volume]</code></pre> <ol> <li> <p>Ship wave period (ship_wave_period):    <pre><code>ship_wave_period = 0.51 * ship_velocity / g\n</code></pre></p> </li> <li> <p>Total wave exposure time (ts):    <pre><code>ts = ship_wave_period * num_ship * num_waves_per_ship\n</code></pre>    where:</p> </li> <li><code>num_ship</code> is the number of ships</li> <li> <p><code>num_waves_per_ship</code> is the number of waves per ship</p> </li> <li> <p>Strength coefficient (cE):    <pre><code>cE = 1.85 * 10^-4 / tauc\n</code></pre></p> </li> <li> <p>Ship-induced erosion distance (erosion_distance_shipping):    <pre><code>erosion_distance_shipping = cE * wave_height\u00b2 * ts * time_erosion\n</code></pre>    if <code>ship_wave_min &lt; water_level_fairway_ref &lt; ship_wave_max</code></p> </li> <li> <p>Ship-induced erosion volume (dv_ship):    <pre><code>dv_ship = erosion_distance_shipping * segment_length * h_line_ship\n</code></pre>    where <code>h_line_ship</code> is the height of the bank subject to ship-induced erosion</p> </li> </ol>"},{"location":"api/bank_erosion/erosion_calculation.html#total-erosion","title":"Total Erosion","text":"<p>The total erosion is the sum of flow-induced and ship-induced erosion:</p> <ol> <li> <p>Total erosion distance (erosion_distance):    <pre><code>erosion_distance = erosion_distance_shipping + erosion_distance_flow\n</code></pre></p> </li> <li> <p>Total erosion volume (erosion_volume):    <pre><code>erosion_volume = dv_ship + dv_flow\n</code></pre></p> </li> </ol>"},{"location":"api/bank_erosion/erosion_calculation.html#usage-example","title":"Usage Example","text":"<p>The <code>compute_erosion_per_level</code> method is called within the <code>_process_discharge_levels</code> method of the <code>Erosion</code> class, which processes all discharge levels:</p> <pre><code>def _process_discharge_levels(self, ...):\n    # ...\n    for level_i in range(num_levels):\n        # ...\n        level_calculation, dvol_bank = self.compute_erosion_per_level(\n            level_i,\n            bank_data,\n            simulation_data,\n            fairway_data,\n            single_parameters,\n            erosion_inputs,\n            km_bin,\n            num_km,\n            bank_height,\n        )\n        discharge_levels.append(level_calculation)\n        # ...\n</code></pre> <p>The results are then used to calculate the total erosion volume and other parameters for the entire river.</p>"},{"location":"api/bank_erosion/erosion_calculator.html","title":"Bank Erosion Calculator","text":"<p>The Bank Erosion Calculator module provides functionality for calculating bank erosion in the D-FAST Bank Erosion software.</p>"},{"location":"api/bank_erosion/erosion_calculator.html#overview","title":"Overview","text":"<p>The Bank Erosion Calculator module contains a class that encapsulates the core erosion calculation algorithms. It is responsible for computing equilibrium bank erosion, bank erosion dynamics during specific discharge levels, and wave heights at banks due to passing ships.</p>"},{"location":"api/bank_erosion/erosion_calculator.html#components","title":"Components","text":"<p>The Bank Erosion Calculator module consists of the following components:</p>"},{"location":"api/bank_erosion/erosion_calculator.html#erosioncalculator-class","title":"ErosionCalculator Class","text":"<p>The ErosionCalculator class provides methods for calculating bank erosion, such as:</p> <ul> <li>comp_erosion_eq: Computes the equilibrium bank erosion distance and volume</li> <li>compute_bank_erosion_dynamics: Computes the bank erosion during a specific discharge level</li> <li>comp_hw_ship_at_bank: Computes wave heights at bank due to passing ships</li> </ul>"},{"location":"api/bank_erosion/erosion_calculator.html#dfastbe.bank_erosion.erosion_calculator","title":"<code>dfastbe.bank_erosion.erosion_calculator</code>","text":"<p>Bank erosion calculator module.</p>"},{"location":"api/bank_erosion/erosion_calculator.html#dfastbe.bank_erosion.erosion_calculator.ErosionCalculator","title":"<code>ErosionCalculator</code>","text":"<p>Class for calculating bank erosion.</p> Source code in <code>src/dfastbe/bank_erosion/erosion_calculator.py</code> <pre><code>class ErosionCalculator:\n    \"\"\"Class for calculating bank erosion.\"\"\"\n\n    @staticmethod\n    def comp_erosion_eq(\n        bank_height: np.ndarray,\n        segment_length: np.ndarray,\n        water_level_fairway_ref: np.ndarray,\n        discharge_level_pars: SingleParameters,\n        bank_fairway_dist: np.ndarray,\n        water_depth_fairway: np.ndarray,\n        erosion_inputs: SingleErosion,\n    ) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Compute the equilibrium bank erosion.\n\n        Args:\n            bank_height : np.ndarray\n                Array containing bank height [m]\n            segment_length : np.ndarray\n                Array containing length of the segment [m]\n            water_level_fairway_ref : np.ndarray\n                Array containing water level at fairway [m]\n            discharge_level_pars (SingleParameters):\n                Discharge level parameters object containing the following attributes.\n                    ship_velocity : np.ndarray\n                        Array containing ship velocity [m/s]\n                    ship_type : np.ndarray\n                        Array containing ship type [-]\n                    ship_draught : np.ndarray\n                        Array containing ship draught [m]\n                    mu_slope : np.ndarray\n                        Array containing slope [-]\n            bank_fairway_dist : np.ndarray\n                Array containing distance from bank to fairway [m]\n            water_depth_fairway : np.ndarray\n                Array containing water depth at the fairway [m]\n            erosion_inputs (ErosionInputs):\n                ErosionInputs object.\n\n        Returns:\n            dn_eq : np.ndarray\n                 Equilibrium bank erosion distance [m]\n            dv_eq : np.ndarray\n                 Equilibrium bank erosion volume [m]\n        \"\"\"\n        # ship induced wave height at the beginning of the foreshore\n        h0 = ErosionCalculator.comp_hw_ship_at_bank(\n            bank_fairway_dist,\n            erosion_inputs.wave_fairway_distance_0,\n            erosion_inputs.wave_fairway_distance_1,\n            water_depth_fairway,\n            discharge_level_pars.ship_type,\n            discharge_level_pars.ship_draught,\n            discharge_level_pars.ship_velocity,\n        )\n        h0 = np.maximum(h0, EPS)\n\n        zup = np.minimum(bank_height, water_level_fairway_ref + 2 * h0)\n        zdo = np.maximum(\n            water_level_fairway_ref - 2 * h0, erosion_inputs.bank_protection_level\n        )\n        ht = np.maximum(zup - zdo, 0)\n        hs = np.maximum(bank_height - water_level_fairway_ref + 2 * h0, 0)\n        eq_erosion_distance = ht / discharge_level_pars.mu_slope\n        eq_erosion_volume = (0.5 * ht + hs) * eq_erosion_distance * segment_length\n\n        return eq_erosion_distance, eq_erosion_volume\n\n    @staticmethod\n    def compute_bank_erosion_dynamics(\n        single_calculation: SingleCalculation,\n        bank_height: np.ndarray,\n        segment_length: np.ndarray,\n        bank_fairway_dist: np.ndarray,\n        water_level_fairway_ref: np.ndarray,\n        discharge_level_pars: SingleParameters,\n        time_erosion: float,\n        erosion_inputs: SingleErosion,\n    ) -&gt; SingleCalculation:\n        \"\"\"\n        Compute the bank erosion during a specific discharge level.\n\n        Args:\n            single_calculation (SingleCalculation):\n                velocity : np.ndarray\n                    Array containing flow velocity magnitude [m/s]\n                water_level_fairway : np.ndarray\n                    Array containing water levels at fairway [m]\n                chezy : np.ndarray\n                    Array containing Chezy values [m0.5/s]\n            bank_height : np.ndarray\n                Array containing bank height\n            segment_length : np.ndarray\n                Array containing length of line segment [m]\n            water_level_fairway_ref : np.ndarray\n                Array containing reference water levels at fairway [m]\n            tauc : np.ndarray\n                Array containing critical shear stress [N/m2]\n            discharge_level_pars: SingleLevelParameters,\n                num_ship : np.ndarray\n                    Array containing number of ships [-]\n                ship_velocity : np.ndarray\n                    Array containing ship velocity [m/s]\n                num_waves_per_ship : np.ndarray\n                    Array containing number of waves per ship [-]\n                ship_type : np.ndarray\n                    Array containing ship type [-]\n                ship_draught : np.ndarray\n                    Array containing ship draught [m]\n            time_erosion : float\n                Erosion period [yr]\n            bank_fairway_dist : np.ndarray\n                Array containing distance from bank to fairway [m]\n            fairway_wave_reduction_distance : np.ndarray\n                Array containing distance from fairway at which wave reduction starts [m]\n            fairway_wave_disappear_distance : np.ndarray\n                Array containing distance from fairway at which all waves are gone [m]\n            water_depth_fairway : np.ndarray\n                Array containing water depth at fairway [m]\n            dike_height : np.ndarray\n                Array containing bank protection height [m]\n            water_density : float\n                Water density [kg/m3]\n\n        Returns:\n            parameters (CalculationParameters):\n                erosion_distance : np.ndarray\n                    Total bank erosion distance [m]\n                erosion_volume : np.ndarray\n                    Total bank erosion volume [m]\n                erosion_distance_shipping : np.ndarray\n                    Bank erosion distance due to shipping [m]\n                erosion_distance_flow : np.ndarray\n                    Bank erosion distance due to current [m]\n                ship_wave_max : np.ndarray\n                    Maximum bank level subject to ship waves [m]\n                ship_wave_min : np.ndarray\n                    Minimum bank level subject to ship waves [m]\n        \"\"\"\n        sec_year = 3600 * 24 * 365\n\n        # period of ship waves [s]\n        ship_wave_period = 0.51 * discharge_level_pars.ship_velocity / g\n        ts = (\n                ship_wave_period\n                * discharge_level_pars.num_ship\n                * discharge_level_pars.num_waves_per_ship\n        )\n        vel = single_calculation.bank_velocity\n\n        # the ship induced wave height at the beginning of the foreshore\n        wave_height = ErosionCalculator.comp_hw_ship_at_bank(\n            bank_fairway_dist,\n            erosion_inputs.wave_fairway_distance_0,\n            erosion_inputs.wave_fairway_distance_1,\n            single_calculation.water_depth,\n            discharge_level_pars.ship_type,\n            discharge_level_pars.ship_draught,\n            discharge_level_pars.ship_velocity,\n        )\n        wave_height = np.maximum(wave_height, EPS)\n\n        # compute erosion parameters for each line part\n        # erosion coefficient\n        erosion_coef = 0.2 * np.sqrt(erosion_inputs.tauc) * 1e-6\n\n        # critical velocity\n        critical_velocity = np.sqrt(\n            erosion_inputs.tauc / WATER_DENSITY * single_calculation.chezy ** 2 / g\n        )\n\n        # strength\n        cE = 1.85e-4 / erosion_inputs.tauc\n\n        # total wave damping coefficient\n        # mu_tot = (mu_slope / H0) + mu_reed\n        # water level along bank line\n        ho_line_ship = np.minimum(\n            single_calculation.water_level - erosion_inputs.bank_protection_level, 2 * wave_height\n        )\n        ho_line_flow = np.minimum(\n            single_calculation.water_level - erosion_inputs.bank_protection_level,\n            single_calculation.water_depth,\n            )\n        h_line_ship = np.maximum(bank_height - single_calculation.water_level + ho_line_ship, 0)\n        h_line_flow = np.maximum(bank_height - single_calculation.water_level + ho_line_flow, 0)\n\n        # compute displacement due to flow\n        crit_ratio = np.ones(critical_velocity.shape)\n        mask = (vel &gt; critical_velocity) &amp; (\n                single_calculation.water_level &gt; erosion_inputs.bank_protection_level\n        )\n        crit_ratio[mask] = (vel[mask] / critical_velocity[mask]) ** 2\n        erosion_distance_flow = erosion_coef * (crit_ratio - 1) * time_erosion * sec_year\n\n        # compute displacement due to ship waves\n        ship_wave_max = single_calculation.water_level + 0.5 * wave_height\n        ship_wave_min = single_calculation.water_level - 2 * wave_height\n        mask = (ship_wave_min &lt; water_level_fairway_ref) &amp; (\n                water_level_fairway_ref &lt; ship_wave_max\n        )\n        # limit mu -&gt; 0\n\n        erosion_distance_shipping = cE * wave_height**2 * ts * time_erosion\n        erosion_distance_shipping[~mask] = 0\n\n        # compute erosion volume\n        mask = (h_line_ship &gt; 0) &amp; (\n                single_calculation.water_level &gt; erosion_inputs.bank_protection_level\n        )\n        dv_ship = erosion_distance_shipping * segment_length * h_line_ship\n        dv_ship[~mask] = 0.0\n        erosion_distance_shipping[~mask] = 0.0\n\n        mask = (h_line_flow &gt; 0) &amp; (\n                single_calculation.water_level &gt; erosion_inputs.bank_protection_level\n        )\n        dv_flow = erosion_distance_flow * segment_length * h_line_flow\n        dv_flow[~mask] = 0.0\n        erosion_distance_flow[~mask] = 0.0\n\n        erosion_distance = erosion_distance_shipping + erosion_distance_flow\n        erosion_volume = dv_ship + dv_flow\n        single_calculation.erosion_volume_tot = erosion_volume\n        single_calculation.erosion_distance_tot = erosion_distance\n        single_calculation.erosion_distance_shipping = erosion_distance_shipping\n        single_calculation.erosion_distance_flow = erosion_distance_flow\n        single_calculation.ship_wave_max = ship_wave_max\n        single_calculation.ship_wave_min = ship_wave_min\n        return single_calculation\n\n    @staticmethod\n    def comp_hw_ship_at_bank(\n        bank_fairway_dist: np.ndarray,\n        fairway_wave_reduction_distance: np.ndarray,\n        fairway_wave_disappear_distance: np.ndarray,\n        water_depth_fairway: np.ndarray,\n        ship_type: np.ndarray,\n        ship_draught: np.ndarray,\n        ship_velocity: np.ndarray,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Compute wave heights at bank due to passing ships.\n\n        Arguments\n        ---------\n        bank_fairway_dist : np.ndarray\n            Array containing distance from bank to fairway [m]\n        fairway_wave_reduction_distance : np.ndarray\n            Array containing distance from fairway at which wave reduction starts [m]\n        fairway_wave_disappear_distance : np.ndarray\n            Array containing distance from fairway at which all waves are gone [m]\n        water_depth_fairway : np.ndarray\n            Array containing the water depth at the fairway [m]\n        ship_type : np.ndarray\n            Array containing the ship type [-]\n        ship_draught : np.ndarray\n            Array containing draught of the ships [m]\n        ship_velocity : np.ndarray\n            Array containing velocity of the ships [m/s]\n        g : float\n            Gravitational acceleration [m/s2]\n\n        Returns\n        -------\n        h0 : np.ndarray\n            Array containing wave height at the bank [m]\n        \"\"\"\n        h = np.copy(water_depth_fairway)\n\n        a1 = np.zeros(len(bank_fairway_dist))\n        # multiple barge convoy set\n        a1[ship_type == 1] = 0.5\n        # RHK ship / motor ship\n        a1[ship_type == 2] = 0.28 * ship_draught[ship_type == 2] ** 1.25\n        # towboat\n        a1[ship_type == 3] = 1\n\n        froude = ship_velocity / np.sqrt(h * g)\n        froude_limit = 0.8\n        high_froude = froude &gt; froude_limit\n        h[high_froude] = ((ship_velocity[high_froude] / froude_limit) ** 2) / g\n        froude[high_froude] = froude_limit\n\n        A = 0.5 * (\n                1\n                + np.cos(\n            (bank_fairway_dist - fairway_wave_disappear_distance)\n            / (fairway_wave_reduction_distance - fairway_wave_disappear_distance)\n            * np.pi\n        )\n        )\n        A[bank_fairway_dist &lt; fairway_wave_disappear_distance] = 1\n        A[bank_fairway_dist &gt; fairway_wave_reduction_distance] = 0\n\n        h0 = a1 * h * (bank_fairway_dist / h) ** (-1 / 3) * froude**4 * A\n        return h0\n</code></pre>"},{"location":"api/bank_erosion/erosion_calculator.html#dfastbe.bank_erosion.erosion_calculator.ErosionCalculator.comp_erosion_eq","title":"<code>comp_erosion_eq(bank_height: np.ndarray, segment_length: np.ndarray, water_level_fairway_ref: np.ndarray, discharge_level_pars: SingleParameters, bank_fairway_dist: np.ndarray, water_depth_fairway: np.ndarray, erosion_inputs: SingleErosion) -&gt; Tuple[np.ndarray, np.ndarray]</code>  <code>staticmethod</code>","text":"<p>Compute the equilibrium bank erosion.</p> <p>Parameters:</p> Name Type Description Default <code>bank_height </code> <p>np.ndarray Array containing bank height [m]</p> required <code>segment_length </code> <p>np.ndarray Array containing length of the segment [m]</p> required <code>water_level_fairway_ref </code> <p>np.ndarray Array containing water level at fairway [m]</p> required <code>discharge_level_pars</code> <code>SingleParameters</code> <p>Discharge level parameters object containing the following attributes.     ship_velocity : np.ndarray         Array containing ship velocity [m/s]     ship_type : np.ndarray         Array containing ship type [-]     ship_draught : np.ndarray         Array containing ship draught [m]     mu_slope : np.ndarray         Array containing slope [-]</p> required <code>bank_fairway_dist </code> <p>np.ndarray Array containing distance from bank to fairway [m]</p> required <code>water_depth_fairway </code> <p>np.ndarray Array containing water depth at the fairway [m]</p> required <code>erosion_inputs</code> <code>ErosionInputs</code> <p>ErosionInputs object.</p> required <p>Returns:</p> Name Type Description <code>dn_eq</code> <code>ndarray</code> <p>np.ndarray  Equilibrium bank erosion distance [m]</p> <code>dv_eq</code> <code>ndarray</code> <p>np.ndarray  Equilibrium bank erosion volume [m]</p> Source code in <code>src/dfastbe/bank_erosion/erosion_calculator.py</code> <pre><code>@staticmethod\ndef comp_erosion_eq(\n    bank_height: np.ndarray,\n    segment_length: np.ndarray,\n    water_level_fairway_ref: np.ndarray,\n    discharge_level_pars: SingleParameters,\n    bank_fairway_dist: np.ndarray,\n    water_depth_fairway: np.ndarray,\n    erosion_inputs: SingleErosion,\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Compute the equilibrium bank erosion.\n\n    Args:\n        bank_height : np.ndarray\n            Array containing bank height [m]\n        segment_length : np.ndarray\n            Array containing length of the segment [m]\n        water_level_fairway_ref : np.ndarray\n            Array containing water level at fairway [m]\n        discharge_level_pars (SingleParameters):\n            Discharge level parameters object containing the following attributes.\n                ship_velocity : np.ndarray\n                    Array containing ship velocity [m/s]\n                ship_type : np.ndarray\n                    Array containing ship type [-]\n                ship_draught : np.ndarray\n                    Array containing ship draught [m]\n                mu_slope : np.ndarray\n                    Array containing slope [-]\n        bank_fairway_dist : np.ndarray\n            Array containing distance from bank to fairway [m]\n        water_depth_fairway : np.ndarray\n            Array containing water depth at the fairway [m]\n        erosion_inputs (ErosionInputs):\n            ErosionInputs object.\n\n    Returns:\n        dn_eq : np.ndarray\n             Equilibrium bank erosion distance [m]\n        dv_eq : np.ndarray\n             Equilibrium bank erosion volume [m]\n    \"\"\"\n    # ship induced wave height at the beginning of the foreshore\n    h0 = ErosionCalculator.comp_hw_ship_at_bank(\n        bank_fairway_dist,\n        erosion_inputs.wave_fairway_distance_0,\n        erosion_inputs.wave_fairway_distance_1,\n        water_depth_fairway,\n        discharge_level_pars.ship_type,\n        discharge_level_pars.ship_draught,\n        discharge_level_pars.ship_velocity,\n    )\n    h0 = np.maximum(h0, EPS)\n\n    zup = np.minimum(bank_height, water_level_fairway_ref + 2 * h0)\n    zdo = np.maximum(\n        water_level_fairway_ref - 2 * h0, erosion_inputs.bank_protection_level\n    )\n    ht = np.maximum(zup - zdo, 0)\n    hs = np.maximum(bank_height - water_level_fairway_ref + 2 * h0, 0)\n    eq_erosion_distance = ht / discharge_level_pars.mu_slope\n    eq_erosion_volume = (0.5 * ht + hs) * eq_erosion_distance * segment_length\n\n    return eq_erosion_distance, eq_erosion_volume\n</code></pre>"},{"location":"api/bank_erosion/erosion_calculator.html#dfastbe.bank_erosion.erosion_calculator.ErosionCalculator.comp_hw_ship_at_bank","title":"<code>comp_hw_ship_at_bank(bank_fairway_dist: np.ndarray, fairway_wave_reduction_distance: np.ndarray, fairway_wave_disappear_distance: np.ndarray, water_depth_fairway: np.ndarray, ship_type: np.ndarray, ship_draught: np.ndarray, ship_velocity: np.ndarray) -&gt; np.ndarray</code>  <code>staticmethod</code>","text":"<p>Compute wave heights at bank due to passing ships.</p>"},{"location":"api/bank_erosion/erosion_calculator.html#dfastbe.bank_erosion.erosion_calculator.ErosionCalculator.comp_hw_ship_at_bank--arguments","title":"Arguments","text":"<p>bank_fairway_dist : np.ndarray     Array containing distance from bank to fairway [m] fairway_wave_reduction_distance : np.ndarray     Array containing distance from fairway at which wave reduction starts [m] fairway_wave_disappear_distance : np.ndarray     Array containing distance from fairway at which all waves are gone [m] water_depth_fairway : np.ndarray     Array containing the water depth at the fairway [m] ship_type : np.ndarray     Array containing the ship type [-] ship_draught : np.ndarray     Array containing draught of the ships [m] ship_velocity : np.ndarray     Array containing velocity of the ships [m/s] g : float     Gravitational acceleration [m/s2]</p>"},{"location":"api/bank_erosion/erosion_calculator.html#dfastbe.bank_erosion.erosion_calculator.ErosionCalculator.comp_hw_ship_at_bank--returns","title":"Returns","text":"<p>h0 : np.ndarray     Array containing wave height at the bank [m]</p> Source code in <code>src/dfastbe/bank_erosion/erosion_calculator.py</code> <pre><code>@staticmethod\ndef comp_hw_ship_at_bank(\n    bank_fairway_dist: np.ndarray,\n    fairway_wave_reduction_distance: np.ndarray,\n    fairway_wave_disappear_distance: np.ndarray,\n    water_depth_fairway: np.ndarray,\n    ship_type: np.ndarray,\n    ship_draught: np.ndarray,\n    ship_velocity: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute wave heights at bank due to passing ships.\n\n    Arguments\n    ---------\n    bank_fairway_dist : np.ndarray\n        Array containing distance from bank to fairway [m]\n    fairway_wave_reduction_distance : np.ndarray\n        Array containing distance from fairway at which wave reduction starts [m]\n    fairway_wave_disappear_distance : np.ndarray\n        Array containing distance from fairway at which all waves are gone [m]\n    water_depth_fairway : np.ndarray\n        Array containing the water depth at the fairway [m]\n    ship_type : np.ndarray\n        Array containing the ship type [-]\n    ship_draught : np.ndarray\n        Array containing draught of the ships [m]\n    ship_velocity : np.ndarray\n        Array containing velocity of the ships [m/s]\n    g : float\n        Gravitational acceleration [m/s2]\n\n    Returns\n    -------\n    h0 : np.ndarray\n        Array containing wave height at the bank [m]\n    \"\"\"\n    h = np.copy(water_depth_fairway)\n\n    a1 = np.zeros(len(bank_fairway_dist))\n    # multiple barge convoy set\n    a1[ship_type == 1] = 0.5\n    # RHK ship / motor ship\n    a1[ship_type == 2] = 0.28 * ship_draught[ship_type == 2] ** 1.25\n    # towboat\n    a1[ship_type == 3] = 1\n\n    froude = ship_velocity / np.sqrt(h * g)\n    froude_limit = 0.8\n    high_froude = froude &gt; froude_limit\n    h[high_froude] = ((ship_velocity[high_froude] / froude_limit) ** 2) / g\n    froude[high_froude] = froude_limit\n\n    A = 0.5 * (\n            1\n            + np.cos(\n        (bank_fairway_dist - fairway_wave_disappear_distance)\n        / (fairway_wave_reduction_distance - fairway_wave_disappear_distance)\n        * np.pi\n    )\n    )\n    A[bank_fairway_dist &lt; fairway_wave_disappear_distance] = 1\n    A[bank_fairway_dist &gt; fairway_wave_reduction_distance] = 0\n\n    h0 = a1 * h * (bank_fairway_dist / h) ** (-1 / 3) * froude**4 * A\n    return h0\n</code></pre>"},{"location":"api/bank_erosion/erosion_calculator.html#dfastbe.bank_erosion.erosion_calculator.ErosionCalculator.compute_bank_erosion_dynamics","title":"<code>compute_bank_erosion_dynamics(single_calculation: SingleCalculation, bank_height: np.ndarray, segment_length: np.ndarray, bank_fairway_dist: np.ndarray, water_level_fairway_ref: np.ndarray, discharge_level_pars: SingleParameters, time_erosion: float, erosion_inputs: SingleErosion) -&gt; SingleCalculation</code>  <code>staticmethod</code>","text":"<p>Compute the bank erosion during a specific discharge level.</p> <p>Parameters:</p> Name Type Description Default <code>single_calculation</code> <code>SingleCalculation</code> <p>velocity : np.ndarray     Array containing flow velocity magnitude [m/s] water_level_fairway : np.ndarray     Array containing water levels at fairway [m] chezy : np.ndarray     Array containing Chezy values [m0.5/s]</p> required <code>bank_height </code> <p>np.ndarray Array containing bank height</p> required <code>segment_length </code> <p>np.ndarray Array containing length of line segment [m]</p> required <code>water_level_fairway_ref </code> <p>np.ndarray Array containing reference water levels at fairway [m]</p> required <code>tauc </code> <p>np.ndarray Array containing critical shear stress [N/m2]</p> required <code>discharge_level_pars</code> <code>SingleParameters</code> <p>SingleLevelParameters, num_ship : np.ndarray     Array containing number of ships [-] ship_velocity : np.ndarray     Array containing ship velocity [m/s] num_waves_per_ship : np.ndarray     Array containing number of waves per ship [-] ship_type : np.ndarray     Array containing ship type [-] ship_draught : np.ndarray     Array containing ship draught [m]</p> required <code>time_erosion </code> <p>float Erosion period [yr]</p> required <code>bank_fairway_dist </code> <p>np.ndarray Array containing distance from bank to fairway [m]</p> required <code>fairway_wave_reduction_distance </code> <p>np.ndarray Array containing distance from fairway at which wave reduction starts [m]</p> required <code>fairway_wave_disappear_distance </code> <p>np.ndarray Array containing distance from fairway at which all waves are gone [m]</p> required <code>water_depth_fairway </code> <p>np.ndarray Array containing water depth at fairway [m]</p> required <code>dike_height </code> <p>np.ndarray Array containing bank protection height [m]</p> required <code>water_density </code> <p>float Water density [kg/m3]</p> required <p>Returns:</p> Name Type Description <code>parameters</code> <code>CalculationParameters</code> <p>erosion_distance : np.ndarray     Total bank erosion distance [m] erosion_volume : np.ndarray     Total bank erosion volume [m] erosion_distance_shipping : np.ndarray     Bank erosion distance due to shipping [m] erosion_distance_flow : np.ndarray     Bank erosion distance due to current [m] ship_wave_max : np.ndarray     Maximum bank level subject to ship waves [m] ship_wave_min : np.ndarray     Minimum bank level subject to ship waves [m]</p> Source code in <code>src/dfastbe/bank_erosion/erosion_calculator.py</code> <pre><code>@staticmethod\ndef compute_bank_erosion_dynamics(\n    single_calculation: SingleCalculation,\n    bank_height: np.ndarray,\n    segment_length: np.ndarray,\n    bank_fairway_dist: np.ndarray,\n    water_level_fairway_ref: np.ndarray,\n    discharge_level_pars: SingleParameters,\n    time_erosion: float,\n    erosion_inputs: SingleErosion,\n) -&gt; SingleCalculation:\n    \"\"\"\n    Compute the bank erosion during a specific discharge level.\n\n    Args:\n        single_calculation (SingleCalculation):\n            velocity : np.ndarray\n                Array containing flow velocity magnitude [m/s]\n            water_level_fairway : np.ndarray\n                Array containing water levels at fairway [m]\n            chezy : np.ndarray\n                Array containing Chezy values [m0.5/s]\n        bank_height : np.ndarray\n            Array containing bank height\n        segment_length : np.ndarray\n            Array containing length of line segment [m]\n        water_level_fairway_ref : np.ndarray\n            Array containing reference water levels at fairway [m]\n        tauc : np.ndarray\n            Array containing critical shear stress [N/m2]\n        discharge_level_pars: SingleLevelParameters,\n            num_ship : np.ndarray\n                Array containing number of ships [-]\n            ship_velocity : np.ndarray\n                Array containing ship velocity [m/s]\n            num_waves_per_ship : np.ndarray\n                Array containing number of waves per ship [-]\n            ship_type : np.ndarray\n                Array containing ship type [-]\n            ship_draught : np.ndarray\n                Array containing ship draught [m]\n        time_erosion : float\n            Erosion period [yr]\n        bank_fairway_dist : np.ndarray\n            Array containing distance from bank to fairway [m]\n        fairway_wave_reduction_distance : np.ndarray\n            Array containing distance from fairway at which wave reduction starts [m]\n        fairway_wave_disappear_distance : np.ndarray\n            Array containing distance from fairway at which all waves are gone [m]\n        water_depth_fairway : np.ndarray\n            Array containing water depth at fairway [m]\n        dike_height : np.ndarray\n            Array containing bank protection height [m]\n        water_density : float\n            Water density [kg/m3]\n\n    Returns:\n        parameters (CalculationParameters):\n            erosion_distance : np.ndarray\n                Total bank erosion distance [m]\n            erosion_volume : np.ndarray\n                Total bank erosion volume [m]\n            erosion_distance_shipping : np.ndarray\n                Bank erosion distance due to shipping [m]\n            erosion_distance_flow : np.ndarray\n                Bank erosion distance due to current [m]\n            ship_wave_max : np.ndarray\n                Maximum bank level subject to ship waves [m]\n            ship_wave_min : np.ndarray\n                Minimum bank level subject to ship waves [m]\n    \"\"\"\n    sec_year = 3600 * 24 * 365\n\n    # period of ship waves [s]\n    ship_wave_period = 0.51 * discharge_level_pars.ship_velocity / g\n    ts = (\n            ship_wave_period\n            * discharge_level_pars.num_ship\n            * discharge_level_pars.num_waves_per_ship\n    )\n    vel = single_calculation.bank_velocity\n\n    # the ship induced wave height at the beginning of the foreshore\n    wave_height = ErosionCalculator.comp_hw_ship_at_bank(\n        bank_fairway_dist,\n        erosion_inputs.wave_fairway_distance_0,\n        erosion_inputs.wave_fairway_distance_1,\n        single_calculation.water_depth,\n        discharge_level_pars.ship_type,\n        discharge_level_pars.ship_draught,\n        discharge_level_pars.ship_velocity,\n    )\n    wave_height = np.maximum(wave_height, EPS)\n\n    # compute erosion parameters for each line part\n    # erosion coefficient\n    erosion_coef = 0.2 * np.sqrt(erosion_inputs.tauc) * 1e-6\n\n    # critical velocity\n    critical_velocity = np.sqrt(\n        erosion_inputs.tauc / WATER_DENSITY * single_calculation.chezy ** 2 / g\n    )\n\n    # strength\n    cE = 1.85e-4 / erosion_inputs.tauc\n\n    # total wave damping coefficient\n    # mu_tot = (mu_slope / H0) + mu_reed\n    # water level along bank line\n    ho_line_ship = np.minimum(\n        single_calculation.water_level - erosion_inputs.bank_protection_level, 2 * wave_height\n    )\n    ho_line_flow = np.minimum(\n        single_calculation.water_level - erosion_inputs.bank_protection_level,\n        single_calculation.water_depth,\n        )\n    h_line_ship = np.maximum(bank_height - single_calculation.water_level + ho_line_ship, 0)\n    h_line_flow = np.maximum(bank_height - single_calculation.water_level + ho_line_flow, 0)\n\n    # compute displacement due to flow\n    crit_ratio = np.ones(critical_velocity.shape)\n    mask = (vel &gt; critical_velocity) &amp; (\n            single_calculation.water_level &gt; erosion_inputs.bank_protection_level\n    )\n    crit_ratio[mask] = (vel[mask] / critical_velocity[mask]) ** 2\n    erosion_distance_flow = erosion_coef * (crit_ratio - 1) * time_erosion * sec_year\n\n    # compute displacement due to ship waves\n    ship_wave_max = single_calculation.water_level + 0.5 * wave_height\n    ship_wave_min = single_calculation.water_level - 2 * wave_height\n    mask = (ship_wave_min &lt; water_level_fairway_ref) &amp; (\n            water_level_fairway_ref &lt; ship_wave_max\n    )\n    # limit mu -&gt; 0\n\n    erosion_distance_shipping = cE * wave_height**2 * ts * time_erosion\n    erosion_distance_shipping[~mask] = 0\n\n    # compute erosion volume\n    mask = (h_line_ship &gt; 0) &amp; (\n            single_calculation.water_level &gt; erosion_inputs.bank_protection_level\n    )\n    dv_ship = erosion_distance_shipping * segment_length * h_line_ship\n    dv_ship[~mask] = 0.0\n    erosion_distance_shipping[~mask] = 0.0\n\n    mask = (h_line_flow &gt; 0) &amp; (\n            single_calculation.water_level &gt; erosion_inputs.bank_protection_level\n    )\n    dv_flow = erosion_distance_flow * segment_length * h_line_flow\n    dv_flow[~mask] = 0.0\n    erosion_distance_flow[~mask] = 0.0\n\n    erosion_distance = erosion_distance_shipping + erosion_distance_flow\n    erosion_volume = dv_ship + dv_flow\n    single_calculation.erosion_volume_tot = erosion_volume\n    single_calculation.erosion_distance_tot = erosion_distance\n    single_calculation.erosion_distance_shipping = erosion_distance_shipping\n    single_calculation.erosion_distance_flow = erosion_distance_flow\n    single_calculation.ship_wave_max = ship_wave_max\n    single_calculation.ship_wave_min = ship_wave_min\n    return single_calculation\n</code></pre>"},{"location":"api/bank_erosion/erosion_calculator.html#usage-example","title":"Usage Example","text":"<pre><code>from dfastbe.bank_erosion.erosion_calculator import ErosionCalculator\nfrom dfastbe.bank_erosion.data_models.calculation import SingleCalculation, SingleParameters, SingleErosion\nimport numpy as np\n\n# Initialize ErosionCalculator\ncalculator = ErosionCalculator()\n\n# Compute equilibrium bank erosion\nerosion_distance_eq, erosion_volume_eq = calculator.comp_erosion_eq(\n    bank_height=np.array([5.0, 5.5, 6.0]),\n    segment_length=np.array([10.0, 10.0, 10.0]),\n    water_level_fairway_ref=np.array([2.0, 2.0, 2.0]),\n    discharge_level_pars=discharge_level_pars,\n    bank_fairway_dist=np.array([20.0, 25.0, 30.0]),\n    water_depth_fairway=np.array([3.0, 3.5, 4.0]),\n    erosion_inputs=erosion_inputs\n)\n\n# Compute bank erosion dynamics\nparameter = SingleCalculation()\nparameter.bank_velocity = np.array([1.0, 1.2, 1.5])\nparameter.water_level = np.array([2.0, 2.0, 2.0])\nparameter.chezy = np.array([50.0, 50.0, 50.0])\n\nparameter = calculator.compute_bank_erosion_dynamics(\n    parameter,\n    bank_height=np.array([5.0, 5.5, 6.0]),\n    segment_length=np.array([10.0, 10.0, 10.0]),\n    bank_fairway_dist=np.array([20.0, 25.0, 30.0]),\n    water_level_fairway_ref=np.array([2.0, 2.0, 2.0]),\n    discharge_level_pars=discharge_level_pars,\n    time_erosion=1.0,\n    water_depth_fairway=np.array([3.0, 3.5, 4.0]),\n    erosion_inputs=erosion_inputs\n)\n</code></pre> <p>For more details on the specific methods and their parameters, refer to the API reference below.</p>"},{"location":"api/bank_erosion/mesh_processor.html","title":"Bank Erosion Mesh Processor","text":"<p>The Bank Erosion Mesh Processor module provides utilities for processing mesh data in the D-FAST Bank Erosion software.</p>"},{"location":"api/bank_erosion/mesh_processor.html#overview","title":"Overview","text":"<p>The Bank Erosion Mesh Processor module contains functions for intersecting bank lines with a mesh and processing mesh data. These functions are used by the Bank Erosion module to prepare data for erosion calculations.</p>"},{"location":"api/bank_erosion/mesh_processor.html#components","title":"Components","text":"<p>The Bank Erosion Mesh Processor module consists of the following components:</p>"},{"location":"api/bank_erosion/mesh_processor.html#mesh-processing-functions","title":"Mesh Processing Functions","text":"<p>The mesh processing component provides functions for processing mesh data, such as:</p> <ul> <li>intersect_line_mesh: Intersects a line with a mesh and returns the intersection points and face indices</li> <li>enlarge: Enlarges an array to a new shape</li> <li>get_slices_ab: Gets slices between two points</li> <li>_get_slices_core: Helper function for _get_slices</li> <li>_get_slices: Helper function for intersect_line_mesh</li> </ul>"},{"location":"api/bank_erosion/mesh_processor.html#dfastbe.bank_erosion.mesh.processor","title":"<code>dfastbe.bank_erosion.mesh.processor</code>","text":"<p>module for processing mesh-related operations.</p>"},{"location":"api/bank_erosion/mesh_processor.html#dfastbe.bank_erosion.mesh.processor.IntersectionState","title":"<code>IntersectionState</code>  <code>dataclass</code>","text":"Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>@dataclass\nclass IntersectionState:\n    coords = np.ndarray\n    face_indexes = np.ndarray\n    point_index = 0\n    current_face_index: int\n    vertex_index: np.ndarray | int\n\n    def __init__(self, shape: Tuple[int, int] = (100, 2), verbose: bool = False):\n        \"\"\"Initialize the intersection results with given shape.\"\"\"\n        self.coords = np.zeros(shape, dtype=np.float64)\n        self.face_indexes = np.zeros(shape[0], dtype=np.int64)\n        self.point_index = 0\n        self.current_face_index: int = -1\n        self.verbose = verbose\n\n    def update(self, current_bank_point, shape_length: bool = None):\n        \"\"\"Finalize a segment\n\n        Enlarge arrays if needed, set coordinates and index, and increment ind.\n        \"\"\"\n        shape_length = self.point_index + 1 if shape_length is None else shape_length\n\n        if self.point_index == self.coords.shape[0]:\n            # last coordinate reached, so enlarge arrays\n            self.coords = enlarge(self.coords, (shape_length, 2))\n            self.face_indexes = enlarge(self.face_indexes, (shape_length,))\n\n        self.coords[self.point_index] = current_bank_point\n\n        if self.current_face_index == -2:\n            self.face_indexes[self.point_index] = self.vertex_index[0]\n        else:\n            self.face_indexes[self.point_index] = self.current_face_index\n        self.point_index += 1\n\n    def _log_mesh_transition(self, log_status: Status):\n        \"\"\"Helper to print mesh transition information for debugging.\"\"\"\n        index_str = \"outside\" if self.current_face_index == -1 else self.current_face_index\n        if self.current_face_index == -2:\n            index_str = f\"edge between {self.vertex_index}\"\n\n        log_status.print(index_str)\n\n    def _update_main_attributes(self, log_status):\n        if self.verbose:\n            log_status.transition_type = \"node\"\n            self._log_mesh_transition(log_status)\n\n        face_indexes = log_status.face_index\n        if isinstance(face_indexes, (int, np.integer)):\n            self.current_face_index = face_indexes\n        elif hasattr(face_indexes, \"__len__\") and len(face_indexes) == 1:\n            self.current_face_index = face_indexes[0]\n        else:\n            self.current_face_index = -2\n            self.vertex_index = face_indexes\n\n    def update_index_and_log(self, status: Status, edge, faces):\n        \"\"\"\n        Helper to update mesh index and log transitions for intersect_line_mesh.\n        \"\"\"\n        if status.face_index is not None:\n            self._update_main_attributes(status)\n            return\n\n        status.transition_type = \"edge\"\n        status.transition_index = edge\n\n        for i, face in enumerate(faces):\n            if face == self.current_face_index:\n                other_face = faces[1 - i]\n                if self.verbose:\n                    status.face_index = other_face\n                    self._log_mesh_transition(status)\n                self.current_face_index = other_face\n                return\n\n        raise ValueError(\n            f\"Shouldn't come here .... index {self.current_face_index} differs from both faces \"\n            f\"{faces[0]} and {faces[1]} associated with slicing edge {edge}\"\n        )\n</code></pre>"},{"location":"api/bank_erosion/mesh_processor.html#dfastbe.bank_erosion.mesh.processor.IntersectionState.__init__","title":"<code>__init__(shape: Tuple[int, int] = (100, 2), verbose: bool = False)</code>","text":"<p>Initialize the intersection results with given shape.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>def __init__(self, shape: Tuple[int, int] = (100, 2), verbose: bool = False):\n    \"\"\"Initialize the intersection results with given shape.\"\"\"\n    self.coords = np.zeros(shape, dtype=np.float64)\n    self.face_indexes = np.zeros(shape[0], dtype=np.int64)\n    self.point_index = 0\n    self.current_face_index: int = -1\n    self.verbose = verbose\n</code></pre>"},{"location":"api/bank_erosion/mesh_processor.html#dfastbe.bank_erosion.mesh.processor.IntersectionState.update","title":"<code>update(current_bank_point, shape_length: bool = None)</code>","text":"<p>Finalize a segment</p> <p>Enlarge arrays if needed, set coordinates and index, and increment ind.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>def update(self, current_bank_point, shape_length: bool = None):\n    \"\"\"Finalize a segment\n\n    Enlarge arrays if needed, set coordinates and index, and increment ind.\n    \"\"\"\n    shape_length = self.point_index + 1 if shape_length is None else shape_length\n\n    if self.point_index == self.coords.shape[0]:\n        # last coordinate reached, so enlarge arrays\n        self.coords = enlarge(self.coords, (shape_length, 2))\n        self.face_indexes = enlarge(self.face_indexes, (shape_length,))\n\n    self.coords[self.point_index] = current_bank_point\n\n    if self.current_face_index == -2:\n        self.face_indexes[self.point_index] = self.vertex_index[0]\n    else:\n        self.face_indexes[self.point_index] = self.current_face_index\n    self.point_index += 1\n</code></pre>"},{"location":"api/bank_erosion/mesh_processor.html#dfastbe.bank_erosion.mesh.processor.IntersectionState.update_index_and_log","title":"<code>update_index_and_log(status: Status, edge, faces)</code>","text":"<p>Helper to update mesh index and log transitions for intersect_line_mesh.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>def update_index_and_log(self, status: Status, edge, faces):\n    \"\"\"\n    Helper to update mesh index and log transitions for intersect_line_mesh.\n    \"\"\"\n    if status.face_index is not None:\n        self._update_main_attributes(status)\n        return\n\n    status.transition_type = \"edge\"\n    status.transition_index = edge\n\n    for i, face in enumerate(faces):\n        if face == self.current_face_index:\n            other_face = faces[1 - i]\n            if self.verbose:\n                status.face_index = other_face\n                self._log_mesh_transition(status)\n            self.current_face_index = other_face\n            return\n\n    raise ValueError(\n        f\"Shouldn't come here .... index {self.current_face_index} differs from both faces \"\n        f\"{faces[0]} and {faces[1]} associated with slicing edge {edge}\"\n    )\n</code></pre>"},{"location":"api/bank_erosion/mesh_processor.html#dfastbe.bank_erosion.mesh.processor.MeshProcessor","title":"<code>MeshProcessor</code>","text":"<p>Class to process bank lines and intersect them with a mesh.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>class MeshProcessor:\n    \"\"\"Class to process bank lines and intersect them with a mesh.\"\"\"\n\n    def __init__(self, river_data: ErosionRiverData, mesh_data: MeshData, verbose: bool = False):\n        \"\"\"Constructor for MeshProcessor.\"\"\"\n        self.bank_lines = river_data.bank_lines\n        self.mesh_data = mesh_data\n        self.river_data = river_data\n        self.wrapper = MeshWrapper(mesh_data, verbose=verbose)\n\n    def get_fairway_data(self, river_axis: LineGeometry) -&gt; FairwayData:\n        LogData().log_text(\"chainage_to_fairway\")\n        # intersect fairway and mesh\n        fairway_intersection_coords, fairway_face_indices = self.wrapper.intersect_with_coords(river_axis.as_array())\n\n        if self.river_data.debug:\n            arr = (fairway_intersection_coords[:-1] + fairway_intersection_coords[1:]) / 2\n            line_geom = LineGeometry(arr, crs=river_axis.crs)\n            line_geom.to_file(\n                file_name=f\"{str(self.river_data.output_dir)}/fairway_face_indices.shp\",\n                data={\"iface\": fairway_face_indices},\n            )\n\n        return FairwayData(fairway_face_indices, fairway_intersection_coords)\n\n    def get_bank_data(self) -&gt; BankData:\n        \"\"\"Intersect bank lines with a mesh and return bank data.\n\n        Returns:\n            BankData object containing bank line coordinates, face indices, and other bank-related data.\n        \"\"\"\n        n_bank_lines = len(self.bank_lines)\n\n        bank_line_coords = []\n        bank_face_indices = []\n        for bank_index in range(n_bank_lines):\n            line_coords = np.array(self.bank_lines.geometry[bank_index].coords)\n            LogData().log_text(\"bank_nodes\", data={\"ib\": bank_index + 1, \"n\": len(line_coords)})\n\n            coords_along_bank, face_indices = self.wrapper.intersect_with_coords(line_coords)\n            bank_line_coords.append(coords_along_bank)\n            bank_face_indices.append(face_indices)\n\n        bank_order, data = self._link_lines_to_stations(bank_line_coords, bank_face_indices)\n\n        return BankData.from_column_arrays(\n            data,\n            SingleBank,\n            bank_lines=self.bank_lines,\n            n_bank_lines=n_bank_lines,\n            bank_order=bank_order,\n        )\n\n    def _link_lines_to_stations(self, bank_line_coords, bank_face_indices):\n        # linking bank lines to chainage\n        LogData().log_text(\"chainage_to_banks\")\n        river_center_line = self.river_data.river_center_line.as_array()\n        n_bank_lines = len(self.bank_lines)\n\n        bank_chainage_midpoints = [None] * n_bank_lines\n        is_right_bank = [True] * n_bank_lines\n        for bank_index, coords in enumerate(bank_line_coords):\n            segment_mid_points = LineGeometry((coords[:-1, :] + coords[1:, :]) / 2)\n            chainage_mid_points = segment_mid_points.intersect_with_line(\n                river_center_line\n            )\n\n            # check if the bank line is defined from low chainage to high chainage\n            if chainage_mid_points[0] &gt; chainage_mid_points[-1]:\n                # if not, flip the bank line and all associated data\n                chainage_mid_points = chainage_mid_points[::-1]\n                bank_line_coords[bank_index] = bank_line_coords[bank_index][::-1, :]\n                bank_face_indices[bank_index] = bank_face_indices[bank_index][::-1]\n\n            bank_chainage_midpoints[bank_index] = chainage_mid_points\n\n            # check if the bank line is a left or right bank\n            # when looking from low-to-high chainage\n            is_right_bank[bank_index] = on_right_side(\n                coords, river_center_line[:, :2]\n            )\n            if is_right_bank[bank_index]:\n                LogData().log_text(\"right_side_bank\", data={\"ib\": bank_index + 1})\n            else:\n                LogData().log_text(\"left_side_bank\", data={\"ib\": bank_index + 1})\n\n        bank_order = tuple(\"right\" if val else \"left\" for val in is_right_bank)\n        data = {\n            'is_right_bank': is_right_bank,\n            'bank_line_coords': bank_line_coords,\n            'bank_face_indices': bank_face_indices,\n            'bank_chainage_midpoints': bank_chainage_midpoints\n        }\n        return bank_order, data\n</code></pre>"},{"location":"api/bank_erosion/mesh_processor.html#dfastbe.bank_erosion.mesh.processor.MeshProcessor.__init__","title":"<code>__init__(river_data: ErosionRiverData, mesh_data: MeshData, verbose: bool = False)</code>","text":"<p>Constructor for MeshProcessor.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>def __init__(self, river_data: ErosionRiverData, mesh_data: MeshData, verbose: bool = False):\n    \"\"\"Constructor for MeshProcessor.\"\"\"\n    self.bank_lines = river_data.bank_lines\n    self.mesh_data = mesh_data\n    self.river_data = river_data\n    self.wrapper = MeshWrapper(mesh_data, verbose=verbose)\n</code></pre>"},{"location":"api/bank_erosion/mesh_processor.html#dfastbe.bank_erosion.mesh.processor.MeshProcessor.get_bank_data","title":"<code>get_bank_data() -&gt; BankData</code>","text":"<p>Intersect bank lines with a mesh and return bank data.</p> <p>Returns:</p> Type Description <code>BankData</code> <p>BankData object containing bank line coordinates, face indices, and other bank-related data.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>def get_bank_data(self) -&gt; BankData:\n    \"\"\"Intersect bank lines with a mesh and return bank data.\n\n    Returns:\n        BankData object containing bank line coordinates, face indices, and other bank-related data.\n    \"\"\"\n    n_bank_lines = len(self.bank_lines)\n\n    bank_line_coords = []\n    bank_face_indices = []\n    for bank_index in range(n_bank_lines):\n        line_coords = np.array(self.bank_lines.geometry[bank_index].coords)\n        LogData().log_text(\"bank_nodes\", data={\"ib\": bank_index + 1, \"n\": len(line_coords)})\n\n        coords_along_bank, face_indices = self.wrapper.intersect_with_coords(line_coords)\n        bank_line_coords.append(coords_along_bank)\n        bank_face_indices.append(face_indices)\n\n    bank_order, data = self._link_lines_to_stations(bank_line_coords, bank_face_indices)\n\n    return BankData.from_column_arrays(\n        data,\n        SingleBank,\n        bank_lines=self.bank_lines,\n        n_bank_lines=n_bank_lines,\n        bank_order=bank_order,\n    )\n</code></pre>"},{"location":"api/bank_erosion/mesh_processor.html#dfastbe.bank_erosion.mesh.processor.MeshWrapper","title":"<code>MeshWrapper</code>","text":"<p>A class for processing mesh-related operations.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>class MeshWrapper:\n    \"\"\"A class for processing mesh-related operations.\"\"\"\n\n    def __init__(\n        self, mesh_data: MeshData, d_thresh: float = 0.001, verbose: bool = False\n    ):\n        self.mesh_data = mesh_data\n        self.d_thresh = d_thresh\n        self.verbose = verbose\n\n    def _read_target_object(self, xy_coords):\n        self.given_coords = xy_coords\n        self.intersection_state = IntersectionState(xy_coords.shape, self.verbose)\n\n    def _handle_first_point(self, current_bank_point: np.ndarray):\n        # get the point on the mesh face that is closest to the first bank point\n        dx = self.mesh_data.x_face_coords - current_bank_point[0]\n        dy = self.mesh_data.y_face_coords - current_bank_point[1]\n        closest_cell_ind = np.nonzero(\n            ~(\n                (dx &lt; 0).all(axis=1)\n                | (dx &gt; 0).all(axis=1)\n                | (dy &lt; 0).all(axis=1)\n                | (dy &gt; 0).all(axis=1)\n            )\n        )[0]\n        index, vindex = self._find_starting_face(closest_cell_ind)\n        self.intersection_state.current_face_index = index\n        self.intersection_state.vertex_index = vindex\n        self.intersection_state.update(current_bank_point)\n\n    def _find_starting_face(self, face_indexes: np.ndarray):\n        \"\"\"Find the starting face for a bank line segment.\n\n        This function determines the face index and vertex indices of the mesh\n        that the first point of a bank line segment is associated with.\n\n        Args:\n            face_indexes (np.ndarray): Array of possible cell indices.\n        \"\"\"\n        if len(face_indexes) == 0 and self.verbose:\n            print(\"starting outside mesh\")\n\n        edges_indexes = self.mesh_data.locate_point(self.given_coords[0], face_indexes)\n        if not isinstance(edges_indexes, list):\n            # A single index was returned\n            index = edges_indexes\n            vindex = None\n        else:\n            # A list of indices is expected\n            if edges_indexes:\n                if self.verbose:\n                    print(f\"starting on edge of {edges_indexes}\")\n\n                index = -2 if len(edges_indexes) &gt; 1 else edges_indexes[0]\n                vindex = edges_indexes if len(edges_indexes) &gt; 1 else None\n            else:\n                if self.verbose:\n                    print(\"starting outside mesh\")\n                index = -1\n                vindex = None\n\n        return index, vindex\n\n    def _log_slice_status(self, j, prev_b, bpj):\n        if prev_b &gt; 0:\n            print(f\"{j}: -- no further slices along this segment --\")\n        else:\n            print(f\"{j}: -- no slices along this segment --\")\n\n        if self.intersection_state.current_face_index &gt;= 0:\n            pnt = Point(bpj)\n            polygon_k = self.mesh_data.get_face_by_index(self.intersection_state.current_face_index, as_polygon=True)\n\n            if not polygon_k.contains(pnt):\n                raise ValueError(\n                    f\"{j}: ERROR: point actually not contained within {self.intersection_state.current_face_index}!\"\n                )\n\n    def _process_node_transition(self, segment: RiverSegment, node):\n        \"\"\"Process the transition at a node when a segment ends or continues.\"\"\"\n        finished = False\n\n        if self.verbose:\n            print(\n                f\"{segment.index}: moving via node {node} on edges {segment.edges} at {segment.distances[0]}\"\n            )\n\n        # figure out where we will be heading afterwards ...\n        if segment.distances[0] &lt; 1.0:\n            # segment passes through node and enter non-neighbouring cell ...\n            # direction of current segment from bpj1 to bpj\n            theta = segment.theta\n        else:\n            if (\n                np.isclose(segment.distances[0], 1.0, rtol=RTOL, atol=ATOL)\n                and segment.index == len(self.given_coords) - 1\n            ):\n                # catch case of last segment\n                if self.verbose:\n                    print(f\"{segment.index}: last point ends in a node\")\n\n                self.intersection_state.update(segment.current_point)\n                theta = 0.0\n                finished = True\n            else:\n                # this segment ends in the node, so check next segment ...\n                # direction of next segment from bpj to bp[j+1]\n                theta = math.atan2(\n                    self.given_coords[segment.index + 1][1]\n                    - segment.current_point[1],\n                    self.given_coords[segment.index + 1][0]\n                    - segment.current_point[0],\n                )\n        next_face_index = None\n        if not finished:\n            next_face_index = self.mesh_data.resolve_next_face_by_direction(\n                theta, node, segment.index\n            )\n        return False, next_face_index\n\n    def _slice_by_node_or_edge(\n        self, segment: RiverSegment, node, edge, faces\n    ):\n        finished = False\n        next_face_index = None\n        if node &gt;= 0:\n            # if we slice at a node ...\n            finished, next_face_index = self._process_node_transition(segment, node)\n\n        elif segment.distances[0] == 1:\n            # ending at slice point, so ending on an edge ...\n            if self.verbose:\n                print(\n                    f\"{segment.index}: ending on edge {edge} at {segment.distances[0]}\"\n                )\n            # figure out where we will be heading afterwards ...\n            if segment.index == len(self.given_coords) - 1:\n                # catch case of last segment\n                if self.verbose:\n                    print(f\"{segment.index}: last point ends on an edge\")\n                self.intersection_state.update(segment.current_point)\n                finished = True\n            else:\n                next_point = [self.given_coords[segment.index + 1][0], self.given_coords[segment.index + 1][1]]\n                next_face_index = self.determine_next_face_on_edge(segment, next_point, edge, faces)\n\n        return finished, next_face_index\n\n    def _process_bank_segment(self, segment: RiverSegment):\n\n        while True:\n            if self.intersection_state.current_face_index == -2:\n                index_src = self._resolve_ambiguous_edge_transition(segment, self.intersection_state.vertex_index)\n\n                if len(index_src) == 1:\n                    self.intersection_state.current_face_index = index_src[0]\n                    self.intersection_state.vertex_index = index_src[0:1]\n                else:\n                    self.intersection_state.current_face_index = -2\n\n            elif segment.is_length_zero():\n                # segment has zero length\n                break\n            else:\n                segment.distances, segment.edges, segment.nodes = (\n                    self.mesh_data.find_segment_intersections(\n                        self.intersection_state.current_face_index,\n                        segment,\n                    )\n                )\n\n            if len(segment.edges) == 0:\n                # rest of segment associated with same face\n                shape_length = self.intersection_state.point_index * SHAPE_MULTIPLIER\n                self.intersection_state.update(\n                    segment.current_point, shape_length=shape_length\n                )\n                break\n\n            if len(segment.edges) &gt; 1:\n                segment.select_first_intersection()\n\n            # slice location identified ...   (number of edges should be 1)\n            node = segment.nodes[0]\n            edge = segment.edges[0]\n            faces = self.mesh_data.edge_face_connectivity[edge]\n            segment.min_relative_distance = segment.distances[0]\n\n            finished, face_index = self._slice_by_node_or_edge(\n                segment,\n                node,\n                edge,\n                faces,\n            )\n            if finished:\n                break\n\n            status = Status(**{\n                \"step\": segment.index,\n                \"transition_index\": node,\n                \"face_index\": face_index,\n                \"prev_b\": segment.min_relative_distance,\n            })\n            self.intersection_state.update_index_and_log(status, edge, faces)\n            segment_x = (\n                    segment.previous_point\n                    + segment.min_relative_distance\n                    * (segment.current_point - segment.previous_point)\n            )\n            shape_length = self.intersection_state.point_index * SHAPE_MULTIPLIER\n            self.intersection_state.update(segment_x, shape_length=shape_length)\n            if segment.min_relative_distance == 1:\n                break\n\n    def _resolve_ambiguous_edge_transition(self, segment: RiverSegment, vindex):\n        \"\"\"Resolve ambiguous edge transitions when a line segment is on the edge of multiple mesh faces.\"\"\"\n        b = np.zeros(0)\n        edges = np.zeros(0, dtype=np.int64)\n        nodes = np.zeros(0, dtype=np.int64)\n        index_src = np.zeros(0, dtype=np.int64)\n\n        for i in vindex:\n            b1, edges1, nodes1 = self.mesh_data.find_segment_intersections(i, segment)\n            b = np.concatenate((b, b1), axis=0)\n            edges = np.concatenate((edges, edges1), axis=0)\n            nodes = np.concatenate((nodes, nodes1), axis=0)\n            index_src = np.concatenate((index_src, i + 0 * edges1), axis=0)\n\n        segment.edges, id_edges = np.unique(edges, return_index=True)\n        segment.distances = b[id_edges]\n        segment.nodes = nodes[id_edges]\n        index_src = index_src[id_edges]\n\n        return index_src\n\n    def resolve_next_face_by_direction(\n            self, theta: float, node, verbose_index: int = None\n    ):\n        \"\"\"Helper to resolve the next face index based on the direction theta at a node.\"\"\"\n\n        if self.verbose:\n            print(f\"{verbose_index}: moving in direction theta = {theta}\")\n\n        edges = self.mesh_data.find_edges(theta, node, verbose_index)\n\n        if self.verbose:\n            print(f\"{verbose_index}: the edge to the left is edge {edges.left}\")\n            print(f\"{verbose_index}: the edge to the right is edge {edges.right}\")\n\n        if edges.left == edges.right:\n            if self.verbose:\n                print(f\"{verbose_index}: continue along edge {edges.left}\")\n\n            next_face_index = self.mesh_data.edge_face_connectivity[edges.left, :]\n        else:\n            if self.verbose:\n                print(\n                    f\"{verbose_index}: continue between edges {edges.left}\"\n                    f\" on the left and {edges.right} on the right\"\n                )\n            next_face_index = self.mesh_data.resolve_next_face_from_edges(\n                node, edges, verbose_index\n            )\n        return next_face_index\n\n    def determine_next_face_on_edge(\n        self, segment: RiverSegment, next_point: List[float], edge, faces,\n    ):\n        \"\"\"Determine the next face to continue along an edge based on the segment direction.\"\"\"\n        theta = math.atan2(\n            next_point[1] - segment.current_point[1],\n            next_point[0] - segment.current_point[0],\n            )\n        if self.verbose:\n            print(f\"{segment.index}: moving in direction theta = {theta}\")\n\n        theta_edge = self.mesh_data.calculate_edge_angle(edge)\n        if theta == theta_edge or theta == -theta_edge:\n            if self.verbose:\n                print(f\"{segment.index}: continue along edge {edge}\")\n            next_face_index = faces\n        else:\n            # check whether the (extended) segment slices any edge of faces[0]\n            fe1 = self.mesh_data.face_edge_connectivity[faces[0]]\n            reversed_segment = RiverSegment(\n                index=segment.index,\n                previous_point=segment.current_point,\n                current_point=next_point,\n                min_relative_distance=0,\n            )\n            _, _, edges = self.mesh_data.calculate_edge_intersections(\n                fe1,\n                reversed_segment,\n                False,\n            )\n            # yes, a slice (typically 1, but could be 2 if it slices at a node\n            # but that doesn't matter) ... so, we continue towards faces[0]\n            # if there are no slices for faces[0], we continue towards faces[1]\n            next_face_index = faces[0] if len(edges) &gt; 0 else faces[1]\n        return next_face_index\n\n    def intersect_with_coords(self, given_coords: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Intersects a coords with an unstructured mesh and returns the intersection coordinates and mesh face indices.\n\n        This function determines where a given line (e.g., a bank line) intersects the faces of an unstructured mesh.\n        It calculates the intersection points and identifies the mesh faces corresponding to each segment of the line.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray]:\n                A tuple containing:\n                - `coords` (np.ndarray):\n                    A 2D array of shape (M, 2) containing the x, y coordinates of the intersection points.\n                - `idx` (np.ndarray):\n                    A 1D array of shape (M-1,) containing the indices of the mesh faces corresponding to each segment\n                    of the intersected line.\n\n        Raises:\n            Exception:\n                If the line starts outside the mesh and cannot be associated with any mesh face, or if the line crosses\n                ambiguous regions (e.g., edges shared by multiple faces).\n\n        Notes:\n            - The function uses Shapely geometry operations to determine whether points are inside polygons or on edges.\n            - The function handles cases where the line starts outside the mesh, crosses multiple edges, or ends on a node.\n            - Tiny segments shorter than `d_thresh` are removed from the output.\n        \"\"\"\n        self._read_target_object(given_coords)\n        for point_index, current_bank_point in enumerate(given_coords):\n            if self.verbose:\n                print(\n                    f\"Current location: {current_bank_point[0]}, {current_bank_point[1]}\"\n                )\n            if point_index == 0:\n                self._handle_first_point(current_bank_point)\n            else:\n                segment = RiverSegment(\n                    index=point_index,\n                    min_relative_distance=0,\n                    current_point=current_bank_point,\n                    previous_point=given_coords[point_index - 1],\n                )\n                self._process_bank_segment(segment)\n\n        # clip to actual length (idx refers to segments, so we can ignore the last value)\n        self.intersection_state.coords = self.intersection_state.coords[: self.intersection_state.point_index]\n        self.intersection_state.face_indexes = self.intersection_state.face_indexes[: self.intersection_state.point_index - 1]\n\n        # remove tiny segments\n        d = np.sqrt((np.diff(self.intersection_state.coords, axis=0) ** 2).sum(axis=1))\n        mask = np.concatenate((np.ones((1), dtype=\"bool\"), d &gt; self.d_thresh))\n        self.intersection_state.coords = self.intersection_state.coords[mask, :]\n        self.intersection_state.face_indexes = self.intersection_state.face_indexes[mask[1:]]\n\n        # since index refers to segments, don't return the first one\n        return self.intersection_state.coords, self.intersection_state.face_indexes\n</code></pre>"},{"location":"api/bank_erosion/mesh_processor.html#dfastbe.bank_erosion.mesh.processor.MeshWrapper.determine_next_face_on_edge","title":"<code>determine_next_face_on_edge(segment: RiverSegment, next_point: List[float], edge, faces)</code>","text":"<p>Determine the next face to continue along an edge based on the segment direction.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>def determine_next_face_on_edge(\n    self, segment: RiverSegment, next_point: List[float], edge, faces,\n):\n    \"\"\"Determine the next face to continue along an edge based on the segment direction.\"\"\"\n    theta = math.atan2(\n        next_point[1] - segment.current_point[1],\n        next_point[0] - segment.current_point[0],\n        )\n    if self.verbose:\n        print(f\"{segment.index}: moving in direction theta = {theta}\")\n\n    theta_edge = self.mesh_data.calculate_edge_angle(edge)\n    if theta == theta_edge or theta == -theta_edge:\n        if self.verbose:\n            print(f\"{segment.index}: continue along edge {edge}\")\n        next_face_index = faces\n    else:\n        # check whether the (extended) segment slices any edge of faces[0]\n        fe1 = self.mesh_data.face_edge_connectivity[faces[0]]\n        reversed_segment = RiverSegment(\n            index=segment.index,\n            previous_point=segment.current_point,\n            current_point=next_point,\n            min_relative_distance=0,\n        )\n        _, _, edges = self.mesh_data.calculate_edge_intersections(\n            fe1,\n            reversed_segment,\n            False,\n        )\n        # yes, a slice (typically 1, but could be 2 if it slices at a node\n        # but that doesn't matter) ... so, we continue towards faces[0]\n        # if there are no slices for faces[0], we continue towards faces[1]\n        next_face_index = faces[0] if len(edges) &gt; 0 else faces[1]\n    return next_face_index\n</code></pre>"},{"location":"api/bank_erosion/mesh_processor.html#dfastbe.bank_erosion.mesh.processor.MeshWrapper.intersect_with_coords","title":"<code>intersect_with_coords(given_coords: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]</code>","text":"<p>Intersects a coords with an unstructured mesh and returns the intersection coordinates and mesh face indices.</p> <p>This function determines where a given line (e.g., a bank line) intersects the faces of an unstructured mesh. It calculates the intersection points and identifies the mesh faces corresponding to each segment of the line.</p> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray]: A tuple containing: - <code>coords</code> (np.ndarray):     A 2D array of shape (M, 2) containing the x, y coordinates of the intersection points. - <code>idx</code> (np.ndarray):     A 1D array of shape (M-1,) containing the indices of the mesh faces corresponding to each segment     of the intersected line.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the line starts outside the mesh and cannot be associated with any mesh face, or if the line crosses ambiguous regions (e.g., edges shared by multiple faces).</p> Notes <ul> <li>The function uses Shapely geometry operations to determine whether points are inside polygons or on edges.</li> <li>The function handles cases where the line starts outside the mesh, crosses multiple edges, or ends on a node.</li> <li>Tiny segments shorter than <code>d_thresh</code> are removed from the output.</li> </ul> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>def intersect_with_coords(self, given_coords: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Intersects a coords with an unstructured mesh and returns the intersection coordinates and mesh face indices.\n\n    This function determines where a given line (e.g., a bank line) intersects the faces of an unstructured mesh.\n    It calculates the intersection points and identifies the mesh faces corresponding to each segment of the line.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]:\n            A tuple containing:\n            - `coords` (np.ndarray):\n                A 2D array of shape (M, 2) containing the x, y coordinates of the intersection points.\n            - `idx` (np.ndarray):\n                A 1D array of shape (M-1,) containing the indices of the mesh faces corresponding to each segment\n                of the intersected line.\n\n    Raises:\n        Exception:\n            If the line starts outside the mesh and cannot be associated with any mesh face, or if the line crosses\n            ambiguous regions (e.g., edges shared by multiple faces).\n\n    Notes:\n        - The function uses Shapely geometry operations to determine whether points are inside polygons or on edges.\n        - The function handles cases where the line starts outside the mesh, crosses multiple edges, or ends on a node.\n        - Tiny segments shorter than `d_thresh` are removed from the output.\n    \"\"\"\n    self._read_target_object(given_coords)\n    for point_index, current_bank_point in enumerate(given_coords):\n        if self.verbose:\n            print(\n                f\"Current location: {current_bank_point[0]}, {current_bank_point[1]}\"\n            )\n        if point_index == 0:\n            self._handle_first_point(current_bank_point)\n        else:\n            segment = RiverSegment(\n                index=point_index,\n                min_relative_distance=0,\n                current_point=current_bank_point,\n                previous_point=given_coords[point_index - 1],\n            )\n            self._process_bank_segment(segment)\n\n    # clip to actual length (idx refers to segments, so we can ignore the last value)\n    self.intersection_state.coords = self.intersection_state.coords[: self.intersection_state.point_index]\n    self.intersection_state.face_indexes = self.intersection_state.face_indexes[: self.intersection_state.point_index - 1]\n\n    # remove tiny segments\n    d = np.sqrt((np.diff(self.intersection_state.coords, axis=0) ** 2).sum(axis=1))\n    mask = np.concatenate((np.ones((1), dtype=\"bool\"), d &gt; self.d_thresh))\n    self.intersection_state.coords = self.intersection_state.coords[mask, :]\n    self.intersection_state.face_indexes = self.intersection_state.face_indexes[mask[1:]]\n\n    # since index refers to segments, don't return the first one\n    return self.intersection_state.coords, self.intersection_state.face_indexes\n</code></pre>"},{"location":"api/bank_erosion/mesh_processor.html#dfastbe.bank_erosion.mesh.processor.MeshWrapper.resolve_next_face_by_direction","title":"<code>resolve_next_face_by_direction(theta: float, node, verbose_index: int = None)</code>","text":"<p>Helper to resolve the next face index based on the direction theta at a node.</p> Source code in <code>src/dfastbe/bank_erosion/mesh/processor.py</code> <pre><code>def resolve_next_face_by_direction(\n        self, theta: float, node, verbose_index: int = None\n):\n    \"\"\"Helper to resolve the next face index based on the direction theta at a node.\"\"\"\n\n    if self.verbose:\n        print(f\"{verbose_index}: moving in direction theta = {theta}\")\n\n    edges = self.mesh_data.find_edges(theta, node, verbose_index)\n\n    if self.verbose:\n        print(f\"{verbose_index}: the edge to the left is edge {edges.left}\")\n        print(f\"{verbose_index}: the edge to the right is edge {edges.right}\")\n\n    if edges.left == edges.right:\n        if self.verbose:\n            print(f\"{verbose_index}: continue along edge {edges.left}\")\n\n        next_face_index = self.mesh_data.edge_face_connectivity[edges.left, :]\n    else:\n        if self.verbose:\n            print(\n                f\"{verbose_index}: continue between edges {edges.left}\"\n                f\" on the left and {edges.right} on the right\"\n            )\n        next_face_index = self.mesh_data.resolve_next_face_from_edges(\n            node, edges, verbose_index\n        )\n    return next_face_index\n</code></pre>"},{"location":"api/bank_erosion/mesh_processor.html#usage-example","title":"Usage Example","text":"<pre><code>from dfastbe.bank_erosion.mesh.processor import MeshWrapper\nfrom dfastbe.bank_erosion.mesh.data_models import MeshData\nfrom dfastbe.io.config import ConfigFile\nfrom dfastbe.bank_erosion.bank_erosion import Erosion\n\n\n# Load configuration file\nconfig_file = ConfigFile.read(\"config.cfg\")\n\n# Initialize Erosion object\nerosion = Erosion(config_file)\n\n# Get mesh data\nmesh_data = erosion.simulation_data.compute_mesh_topology()\n\n# Intersect a bank line with the mesh\nbank_line_coords = erosion.river_data.bank_lines.geometry[0].coords\ncoords_along_bank, face_indices = MeshWrapper(mesh_data).intersect_with_coords(bank_line_coords)\n\n# Print results\nprint(f\"Number of intersection points: {len(coords_along_bank)}\")\nprint(f\"Number of face indices: {len(face_indices)}\")\n</code></pre> <p>For more details on the specific functions, refer to the API reference below.</p>"},{"location":"api/bank_erosion/data_models/calculation.html","title":"Bank Erosion Calculation Data Models","text":"<p>The Bank Erosion Calculation Data Models module provides data structures for representing calculation parameters, inputs, and results in the D-FAST Bank Erosion software.</p>"},{"location":"api/bank_erosion/data_models/calculation.html#overview","title":"Overview","text":"<p>The Bank Erosion Calculation Data Models module contains classes that represent various aspects of bank erosion calculations, such as bank data, erosion inputs, calculation parameters, and results. These data models are used by the Bank Erosion module to process and analyze bank erosion.</p> <pre><code>classDiagram\n    %% Main Classes\n\n    %% Generic Base Class\n    class BaseBank~T~ {\n        +T left\n        +T right\n        +Optional[int] id\n        +get_bank(int)\n        +from_column_arrays(Dict, Type, Tuple)\n        +__iter__()\n    }\n\n\n    %% Data Models - Bank Erosion\n    class ErosionRiverData {\n        -ConfigFile config_file\n        -LineString river_center_line\n        -Tuple station_bounds\n        +__init__(ConfigFile)\n        +simulation_data()\n        -_get_bank_output_dir()\n        -_get_bank_line_dir()\n        -_read_river_axis()\n    }\n\n    class ErosionSimulationData {\n        +compute_mesh_topology()\n        +apply_masked_indexing(array, array)\n        +calculate_bank_velocity(SingleBank, array)\n        +calculate_bank_height(SingleBank, array)\n    }\n\n    class BankData {\n        +List banks\n        +from_column_arrays(dict, Type, GeoDataFrame, int, Tuple)\n        +bank_line_coords()\n        +is_right_bank()\n        +bank_chainage_midpoints()\n        +num_stations_per_bank()\n    }\n\n    class SingleBank {\n        +LineString bank_line\n        +array face_indices\n        +array chainage\n        +bool is_right\n        +__post_init__()\n        -_segment_length()\n        -_dx()\n        -_dy()\n        +get_mid_points(bool, str)\n    }\n\n    class FairwayData {\n        +LineString fairway_axis\n        +Polygon fairway_polygon\n        +array fairway_initial_water_levels\n        +array fairway_velocities\n        +array fairway_chezy_coefficients\n    }\n\n    class ErosionInputs {\n        +List banks\n        +dict shipping_data\n        +from_column_arrays(dict, Type, Dict, array, Tuple)\n        +bank_protection_level()\n        +tauc()\n    }\n\n    class SingleErosion {\n        +array wave_fairway_distance_0\n        +array wave_fairway_distance_1\n        +array bank_protection_level\n        +array tauc\n        +array bank_type\n    }\n\n    class ErosionResults {\n        +int erosion_time\n        +List velocity\n        +List bank_height\n        +List water_level\n        +List chezy\n        +List vol_per_discharge\n        +List ship_wave_max\n        +List ship_wave_min\n        +List line_size\n        +List flow_erosion_dist\n        +List ship_erosion_dist\n        +List total_erosion_dist\n        +List total_eroded_vol\n        +List eq_erosion_dist\n        +List eq_eroded_vol\n        +array avg_erosion_rate\n        +array eq_eroded_vol_per_km\n        +array total_eroded_vol_per_km\n    }\n\n    class WaterLevelData {\n        +List water_levels\n        +array hfw_max\n    }\n\n    class MeshData {\n        +array x_node\n        +array y_node\n        +array n_nodes\n        +array face_node\n        +array face_x\n        +array face_y\n        +array face_area\n        +array face_nodes_count\n        +array face_nodes_indices\n    }\n\n    class DischargeLevels {\n        +List levels\n        +__init__(List)\n        +__getitem__(int)\n        +__len__()\n        +append(SingleDischargeLevel)\n        +get_max_hfw_level()\n        +total_erosion_volume()\n        +__iter__()\n        +accumulate(str, str)\n        -_accumulate_attribute_side(str, str)\n        -_get_attr_both_sides_level(str, object)\n        +get_attr_level(str)\n        +get_water_level_data(array)\n    }\n\n    class SingleDischargeLevel {\n        +List banks\n        +from_column_arrays(dict, Type, float, Tuple)\n    }\n\n    class SingleCalculation {\n        +array water_level\n        +array velocity\n        +array chezy\n        +array flow_erosion_dist\n        +array ship_erosion_dist\n        +array total_erosion_dist\n        +array total_eroded_vol\n        +array eq_erosion_dist\n        +array eq_eroded_vol\n    }\n\n    class SingleLevelParameters {\n        +List banks\n    }\n\n    class SingleParameters {\n        +float discharge\n        +float probability\n        +dict ship_parameters\n    }\n\n\n    %% Relationships\n    ErosionRiverData --|&gt; BaseRiverData : inherits\n    ErosionRiverData --&gt; ConfigFile : uses\n\n    ErosionSimulationData --|&gt; BaseSimulationData : inherits\n    ErosionSimulationData --&gt; MeshData : uses\n    ErosionSimulationData --&gt; SingleBank : uses\n\n    %% Inheritance relationships\n    BankData --|&gt; BaseBank : inherits\n    BankData --|&gt; BaseBank : inherits\n    ErosionInputs --|&gt; BaseBank : inherits\n    SingleDischargeLevel --|&gt; BaseBank : inherits\n    SingleLevelParameters --|&gt; BaseBank : inherits\n\n    %% Containment relationships\n    BankData --&gt; SingleBank : contains\n    ErosionInputs --&gt; SingleErosion : contains\n    SingleDischargeLevel --&gt; SingleCalculation : contains\n    SingleLevelParameters --&gt; SingleParameters : contains\n    DischargeLevels --&gt; SingleDischargeLevel : contains</code></pre>"},{"location":"api/bank_erosion/data_models/calculation.html#components","title":"Components","text":"<p>The Bank Erosion Calculation Data Models module consists of the following components:</p>"},{"location":"api/bank_erosion/data_models/calculation.html#data-models","title":"Data Models","text":"<p>The data models component provides classes for representing various types of data related to bank erosion calculations, such as:</p> <ul> <li>BaseBank: Generic base class for representing paired bank data (left and right banks)</li> <li>SingleErosion: Represents erosion inputs for a single bank</li> <li>ErosionInputs: Represents inputs for erosion calculations</li> <li>WaterLevelData: Represents water level data for erosion calculations</li> <li>MeshData: Represents mesh data for erosion calculations</li> <li>SingleBank: Represents a single bank for erosion calculations</li> <li>BankData: Represents bank data for erosion calculations</li> <li>FairwayData: Represents fairway data for erosion calculations</li> <li>ErosionResults: Represents results of erosion calculations</li> <li>SingleParameters: Represents parameters for each bank</li> <li>SingleLevelParameters: Represents parameters for discharge levels</li> <li>SingleCalculation: Represents parameters for discharge calculations</li> <li>SingleDischargeLevel: Represents a calculation level for erosion calculations</li> <li>DischargeLevels: Represents discharge levels for erosion calculations</li> </ul>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation","title":"<code>dfastbe.bank_erosion.data_models.calculation</code>","text":"<p>Erosion-related data structures.</p>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.BankData","title":"<code>BankData</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseBank[SingleBank]</code></p> <p>Class to hold bank-related data.</p> <p>Parameters:</p> Name Type Description Default <code>is_right_bank</code> <code>List[bool]</code> <p>List indicating if the bank is right or not.</p> required <code>bank_chainage_midpoints</code> <code>List[ndarray]</code> <p>River chainage for the midpoints of each segment of the bank line</p> required <code>bank_line_coords</code> <code>List[ndarray]</code> <p>Coordinates of the bank lines.</p> required <code>bank_face_indices</code> <code>List[ndarray]</code> <p>Indices of the faces associated with the banks.</p> required <code>bank_lines</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing the bank lines.</p> <code>GeoDataFrame()</code> <code>n_bank_lines</code> <code>int</code> <p>Number of bank lines.</p> <code>0</code> <code>bank_line_size</code> <code>List[ndarray]</code> <p>Size of each individual bank line.</p> required <code>fairway_distances</code> <code>List[ndarray]</code> <p>The distance of each bank line point to the closest fairway point.</p> required <code>fairway_face_indices</code> <code>List[ndarray]</code> <p>The face index of the closest fairway point for each bank line point.</p> required Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>@dataclass\nclass BankData(BaseBank[SingleBank]):\n    \"\"\"Class to hold bank-related data.\n\n    args:\n        is_right_bank (List[bool]):\n            List indicating if the bank is right or not.\n        bank_chainage_midpoints (List[np.ndarray]):\n            River chainage for the midpoints of each segment of the bank line\n        bank_line_coords (List[np.ndarray]):\n            Coordinates of the bank lines.\n        bank_face_indices (List[np.ndarray]):\n            Indices of the faces associated with the banks.\n        bank_lines (GeoDataFrame):\n            GeoDataFrame containing the bank lines.\n        n_bank_lines (int):\n            Number of bank lines.\n        bank_line_size (List[np.ndarray]):\n            Size of each individual bank line.\n        fairway_distances (List[np.ndarray]):\n            The distance of each bank line point to the closest fairway point.\n        fairway_face_indices (List[np.ndarray]):\n            The face index of the closest fairway point for each bank line point.\n    \"\"\"\n    bank_lines: GeoDataFrame = field(default_factory=GeoDataFrame)\n    n_bank_lines: int = 0\n\n    @classmethod\n    def from_column_arrays(\n        cls,\n        data: dict,\n        bank_cls: Type[\"SingleBank\"],\n        bank_lines: GeoDataFrame,\n        n_bank_lines: int,\n        bank_order: Tuple[str, str] = (\"left\", \"right\")\n    ) -&gt; \"BankData\":\n        # Only include fields that belong to the bank-specific data\n        base_fields = {k: v for k, v in data.items() if k != \"id\"}\n        base = BaseBank.from_column_arrays(\n            {\"id\": data.get(\"id\"), **base_fields}, bank_cls, bank_order=bank_order\n        )\n\n        return cls(\n            id=base.id,\n            left=base.left,\n            right=base.right,\n            bank_lines=bank_lines,\n            n_bank_lines=n_bank_lines,\n        )\n\n    @property\n    def bank_line_coords(self) -&gt; List[np.ndarray]:\n        \"\"\"Get the coordinates of the bank lines.\"\"\"\n        return [self.left.bank_line_coords, self.right.bank_line_coords]\n\n    @property\n    def is_right_bank(self) -&gt; List[bool]:\n        \"\"\"Get the bank direction.\"\"\"\n        return [self.left.is_right_bank, self.right.is_right_bank]\n\n    @property\n    def bank_chainage_midpoints(self) -&gt; List[np.ndarray]:\n        \"\"\"Get the chainage midpoints of the bank lines.\"\"\"\n        return [self.left.bank_chainage_midpoints, self.right.bank_chainage_midpoints]\n\n    @property\n    def num_stations_per_bank(self) -&gt; List[int]:\n        \"\"\"Get the number of stations per bank.\"\"\"\n        return [self.left.length, self.right.length]\n\n    @property\n    def height(self) -&gt; List[np.ndarray]:\n        \"\"\"Get the bank height.\"\"\"\n        return [self.left.height, self.right.height]\n</code></pre>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.BankData.bank_chainage_midpoints","title":"<code>bank_chainage_midpoints: List[np.ndarray]</code>  <code>property</code>","text":"<p>Get the chainage midpoints of the bank lines.</p>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.BankData.bank_line_coords","title":"<code>bank_line_coords: List[np.ndarray]</code>  <code>property</code>","text":"<p>Get the coordinates of the bank lines.</p>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.BankData.height","title":"<code>height: List[np.ndarray]</code>  <code>property</code>","text":"<p>Get the bank height.</p>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.BankData.is_right_bank","title":"<code>is_right_bank: List[bool]</code>  <code>property</code>","text":"<p>Get the bank direction.</p>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.BankData.num_stations_per_bank","title":"<code>num_stations_per_bank: List[int]</code>  <code>property</code>","text":"<p>Get the number of stations per bank.</p>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.BaseBank","title":"<code>BaseBank</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[GenericType]</code></p> Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>@dataclass\nclass BaseBank(Generic[GenericType]):\n    left: GenericType\n    right: GenericType\n    id: Optional[int] = field(default=None)\n\n    def get_bank(self, bank_index: int) -&gt; GenericType:\n        if bank_index == 0:\n            return self.left\n        elif bank_index == 1:\n            return self.right\n        else:\n            raise ValueError(\"bank_index must be 0 (left) or 1 (right)\")\n\n    @classmethod\n    def from_column_arrays(\n        cls: Type[\"BaseBank[GenericType]\"],\n        data: Dict[str, Any],\n        bank_cls: Type[GenericType],\n        bank_order: Tuple[str, str] = (\"left\", \"right\")\n    ) -&gt; \"BaseBank[GenericType]\":\n        if set(bank_order) != {\"left\", \"right\"}:\n            raise ValueError(\"bank_order must be a permutation of ('left', 'right')\")\n\n        id_val = data.get(\"id\")\n\n        # Extract the first and second array for each parameter (excluding id)\n        first_args = {}\n        second_args = {}\n        for key, value in data.items():\n            if key == \"id\":\n                continue\n            if not isinstance(value, list) or len(value) != 2:\n                raise ValueError(f\"Expected 2-column array for key '{key}', got shape {value.shape}\")\n\n            split = dict(zip(bank_order, value))\n            first_args[key] = split[\"left\"]\n            second_args[key] = split[\"right\"]\n\n        left = bank_cls(**first_args)\n        right = bank_cls(**second_args)\n\n        return cls(id=id_val, left=left, right=right)\n\n    def __iter__(self) -&gt; Iterator[GenericType]:\n        \"\"\"Iterate over the banks.\"\"\"\n        return iter([self.left, self.right])\n</code></pre>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.BaseBank.__iter__","title":"<code>__iter__() -&gt; Iterator[GenericType]</code>","text":"<p>Iterate over the banks.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>def __iter__(self) -&gt; Iterator[GenericType]:\n    \"\"\"Iterate over the banks.\"\"\"\n    return iter([self.left, self.right])\n</code></pre>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.DischargeLevels","title":"<code>DischargeLevels</code>","text":"Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>class DischargeLevels:\n\n    def __init__(self, levels: List[SingleDischargeLevel]):\n        self.levels = levels\n\n    def __getitem__(self, index: int) -&gt; SingleDischargeLevel:\n        return self.levels[index]\n\n    def __len__(self) -&gt; int:\n        return len(self.levels)\n\n    def append(self, level_calc: SingleDischargeLevel):\n        self.levels.append(level_calc)\n\n    def get_max_hfw_level(self) -&gt; float:\n        return max(level.hfw_max for level in self.levels)\n\n    def total_erosion_volume(self) -&gt; float:\n        return sum(\n            np.sum(level.left.erosion_volume_tot) + np.sum(level.right.erosion_volume_tot)\n            for level in self.levels\n        )\n\n    def __iter__(self):\n        return iter(self.levels)\n\n    def accumulate(self, attribute_name: str, bank_side: Union[str, List[str]] = None) -&gt; List[np.ndarray]:\n        if bank_side is None:\n            bank_side = [\"left\", \"right\"]\n        elif isinstance(bank_side, str):\n            bank_side = [bank_side]\n\n        if not all(side in [\"left\", \"right\"] for side in bank_side):\n            raise ValueError(\"bank_side must be 'left', 'right', or a list of these.\")\n\n        total = [\n            self._accumulate_attribute_side(attribute_name, side) for side in bank_side\n        ]\n        return total\n\n    def _accumulate_attribute_side(self, attribute_name: str, bank_side: str) -&gt; np.ndarray:\n        for i, level in enumerate(self.levels):\n            bank = getattr(level, bank_side)\n            attr = getattr(bank, attribute_name, None)\n            if attr is None:\n                raise AttributeError(f\"{attribute_name} not found in {bank_side} bank of level with id={level.id}\")\n            if i == 0:\n                total = attr\n            else:\n                total += attr\n        return total\n\n    def _get_attr_both_sides_level(self, attribute_name: str, level) -&gt; List[np.ndarray]:\n        \"\"\"Get the attributes of the levels for both left and right bank.\"\"\"\n        sides = [getattr(self.levels[level], side) for side in [\"left\", \"right\"]]\n        attr = [getattr(side, attribute_name, None) for side in sides]\n        return attr\n\n    def get_attr_level(self, attribute_name: str) -&gt; List[List[np.ndarray]]:\n        \"\"\"Get the attributes of the levels for both left and right bank.\"\"\"\n        return [self._get_attr_both_sides_level(attribute_name, level) for level in range(len(self.levels))]\n\n    def get_water_level_data(self) -&gt; WaterLevelData:\n        return WaterLevelData(\n            hfw_max=self.levels[-1].hfw_max,\n            water_level=self.get_attr_level(\"water_level\"),\n            ship_wave_max=self.get_attr_level(\"ship_wave_max\"),\n            ship_wave_min=self.get_attr_level(\"ship_wave_min\"),\n            velocity=self.get_attr_level(\"bank_velocity\"),\n            chezy=self.get_attr_level(\"chezy\"),\n            vol_per_discharge=self.get_attr_level(\"volume_per_discharge\"),\n        )\n</code></pre>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.DischargeLevels.get_attr_level","title":"<code>get_attr_level(attribute_name: str) -&gt; List[List[np.ndarray]]</code>","text":"<p>Get the attributes of the levels for both left and right bank.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>def get_attr_level(self, attribute_name: str) -&gt; List[List[np.ndarray]]:\n    \"\"\"Get the attributes of the levels for both left and right bank.\"\"\"\n    return [self._get_attr_both_sides_level(attribute_name, level) for level in range(len(self.levels))]\n</code></pre>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.ErosionInputs","title":"<code>ErosionInputs</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseBank[SingleErosion]</code></p> <p>Class to hold erosion inputs.</p> <p>Parameters:</p> Name Type Description Default <code>shipping_data</code> <code>Dict[str, ndarray]</code> <p>Data on all the vessels that travel through the river.</p> <code>dict()</code> <code>wave_fairway_distance_0</code> <code>List[ndarray]</code> <p>Threshold fairway distance 0 for wave attenuation.</p> required <code>wave_fairway_distance_1</code> <code>List[ndarray]</code> <p>Threshold fairway distance 1 for wave attenuation.</p> required <code>bank_protection_level</code> <code>List[ndarray]</code> <p>Bank protection level.</p> required <code>tauc</code> <code>List[ndarray]</code> <p>Critical bank shear stress values.</p> required <code>bank_type</code> <code>List[ndarray]</code> <p>Integer representation of the bank type. Represents an index into the taucls_str array.</p> <code>(lambda: array([]))()</code> <code>taucls</code> <code>ndarray</code> <p>Critical bank shear stress values for different bank types.</p> required <code>taucls_str</code> <code>Tuple[str]</code> <p>String representation for different bank types.</p> required Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>@dataclass\nclass ErosionInputs(BaseBank[SingleErosion]):\n    \"\"\"Class to hold erosion inputs.\n\n    args:\n        shipping_data (Dict[str, np.ndarray]):\n            Data on all the vessels that travel through the river.\n        wave_fairway_distance_0 (List[np.ndarray]):\n            Threshold fairway distance 0 for wave attenuation.\n        wave_fairway_distance_1 (List[np.ndarray]):\n            Threshold fairway distance 1 for wave attenuation.\n        bank_protection_level (List[np.ndarray]):\n            Bank protection level.\n        tauc (List[np.ndarray]):\n            Critical bank shear stress values.\n        bank_type (List[np.ndarray]):\n            Integer representation of the bank type. Represents an index into the taucls_str array.\n        taucls (np.ndarray):\n            Critical bank shear stress values for different bank types.\n        taucls_str (Tuple[str]):\n            String representation for different bank types.\n    \"\"\"\n    shipping_data: Dict[str, List[np.ndarray]] = field(default_factory=dict)\n    bank_type: np.ndarray = field(default_factory=lambda: np.array([]))\n    taucls: ClassVar[np.ndarray] = np.array([1e20, 95, 3.0, 0.95, 0.15])\n    taucls_str: ClassVar[Tuple[str]] = (\n        \"protected\",\n        \"vegetation\",\n        \"good clay\",\n        \"moderate/bad clay\",\n        \"sand\",\n    )\n\n    @classmethod\n    def from_column_arrays(\n        cls, data: dict, bank_cls: Type[\"SingleErosion\"], shipping_data: Dict[str, List[np.ndarray]],\n        bank_type: np.ndarray, bank_order: Tuple[str, str] = (\"left\", \"right\")\n    ) -&gt; \"ErosionInputs\":\n        # Only include fields that belong to the bank-specific data\n        base_fields = {k: v for k, v in data.items() if k != \"id\"}\n        base = BaseBank.from_column_arrays(\n            {\"id\": data.get(\"id\"), **base_fields}, bank_cls, bank_order=bank_order\n        )\n\n        return cls(\n            id=base.id,\n            left=base.left,\n            right=base.right,\n            shipping_data=shipping_data,\n            bank_type=bank_type,\n        )\n\n    @property\n    def bank_protection_level(self) -&gt; List[np.ndarray]:\n        \"\"\"Get the bank protection level.\"\"\"\n        return [self.left.bank_protection_level, self.right.bank_protection_level]\n\n    @property\n    def tauc(self) -&gt; List[np.ndarray]:\n        \"\"\"Get the critical bank shear stress values.\"\"\"\n        return [self.left.tauc, self.right.tauc]\n</code></pre>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.ErosionInputs.bank_protection_level","title":"<code>bank_protection_level: List[np.ndarray]</code>  <code>property</code>","text":"<p>Get the bank protection level.</p>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.ErosionInputs.tauc","title":"<code>tauc: List[np.ndarray]</code>  <code>property</code>","text":"<p>Get the critical bank shear stress values.</p>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.ErosionResults","title":"<code>ErosionResults</code>  <code>dataclass</code>","text":"<p>Class to hold erosion results.</p> <p>Parameters:</p> Name Type Description Default <code>eq_erosion_dist</code> <code>List[ndarray]</code> <p>Erosion distance at equilibrium for each bank line.</p> required <code>total_erosion_dist</code> <code>List[ndarray]</code> <p>Total erosion distance for each bank line.</p> required <code>flow_erosion_dist</code> <code>List[ndarray]</code> <p>Total erosion distance caused by flow for each bank line.</p> required <code>ship_erosion_dist</code> <code>List[ndarray]</code> <p>Total erosion distance caused by ship waves for each bank line.</p> required <code>eq_eroded_vol</code> <code>List[ndarray]</code> <p>Eroded volume at equilibrium for each bank line.</p> required <code>total_eroded_vol</code> <code>List[ndarray]</code> <p>Total eroded volume for each bank line.</p> required <code>erosion_time</code> <code>int</code> <p>Time over which erosion is calculated.</p> required <code>avg_erosion_rate</code> <code>ndarray</code> <p>Average erosion rate data.</p> <code>(lambda: empty(0))()</code> <code>eq_eroded_vol_per_km</code> <code>ndarray</code> <p>Equilibrium eroded volume calculated per kilometer bin.</p> <code>(lambda: empty(0))()</code> <code>total_eroded_vol_per_km</code> <code>ndarray</code> <p>Total eroded volume calculated per kilometer bin.</p> <code>(lambda: empty(0))()</code> <p>Examples:</p> <ul> <li> <p>You can create an instance of the ErosionResults class as follows: <pre><code>&gt;&gt;&gt; from dfastbe.bank_erosion.data_models.calculation import ErosionResults\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; erosion_results = ErosionResults(\n...     eq_erosion_dist=[np.array([0.1, 0.2])],\n...     total_erosion_dist=[np.array([0.3, 0.4])],\n...     flow_erosion_dist=[np.array([0.5, 0.6])],\n...     ship_erosion_dist=[np.array([0.7, 0.8])],\n...     eq_eroded_vol=[np.array([1.1, 1.2])],\n...     total_eroded_vol=[np.array([1.3, 1.4])],\n...     erosion_time=10,\n...     avg_erosion_rate=np.array([0.1, 0.2]),\n...     eq_eroded_vol_per_km=np.array([0.3, 0.4]),\n...     total_eroded_vol_per_km=np.array([0.5, 0.6]),\n... )\n&gt;&gt;&gt; print(erosion_results)\nErosionResults(eq_erosion_dist=[array([0.1, 0.2])], total_erosion_dist=[array([0.3, 0.4])], flow_erosion_dist=[array([0.5, 0.6])], ship_erosion_dist=[array([0.7, 0.8])], eq_eroded_vol=[array([1.1, 1.2])], total_eroded_vol=[array([1.3, 1.4])], erosion_time=10, avg_erosion_rate=array([0.1, 0.2]), eq_eroded_vol_per_km=array([0.3, 0.4]), total_eroded_vol_per_km=array([0.5, 0.6]))\n</code></pre></p> </li> <li> <p>The <code>avg_erosion_rate</code>, <code>eq_eroded_vol_per_km</code>, and <code>total_eroded_vol_per_km</code> attributes are optional and can be set to empty arrays if not needed.</p> </li> </ul> <pre><code>&gt;&gt;&gt; from dfastbe.bank_erosion.data_models.calculation import ErosionResults\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; erosion_results = ErosionResults(\n...     eq_erosion_dist=[np.array([0.1, 0.2])],\n...     total_erosion_dist=[np.array([0.3, 0.4])],\n...     flow_erosion_dist=[np.array([0.5, 0.6])],\n...     ship_erosion_dist=[np.array([0.7, 0.8])],\n...     eq_eroded_vol=[np.array([1.1, 1.2])],\n...     total_eroded_vol=[np.array([1.3, 1.4])],\n...     erosion_time=10,\n... )\n&gt;&gt;&gt; print(erosion_results)\nErosionResults(eq_erosion_dist=[array([0.1, 0.2])], total_erosion_dist=[array([0.3, 0.4])], flow_erosion_dist=[array([0.5, 0.6])], ship_erosion_dist=[array([0.7, 0.8])], eq_eroded_vol=[array([1.1, 1.2])], total_eroded_vol=[array([1.3, 1.4])], erosion_time=10, avg_erosion_rate=array([], dtype=float64), eq_eroded_vol_per_km=array([], dtype=float64), total_eroded_vol_per_km=array([], dtype=float64))\n</code></pre> Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>@dataclass\nclass ErosionResults:\n    \"\"\"Class to hold erosion results.\n\n    args:\n        eq_erosion_dist (List[np.ndarray]):\n            Erosion distance at equilibrium for each bank line.\n        total_erosion_dist (List[np.ndarray]):\n            Total erosion distance for each bank line.\n        flow_erosion_dist (List[np.ndarray]):\n            Total erosion distance caused by flow for each bank line.\n        ship_erosion_dist (List[np.ndarray]):\n            Total erosion distance caused by ship waves for each bank line.\n        eq_eroded_vol (List[np.ndarray]):\n            Eroded volume at equilibrium for each bank line.\n        total_eroded_vol (List[np.ndarray]):\n            Total eroded volume for each bank line.\n        erosion_time (int):\n            Time over which erosion is calculated.\n        avg_erosion_rate (np.ndarray):\n            Average erosion rate data.\n        eq_eroded_vol_per_km (np.ndarray):\n            Equilibrium eroded volume calculated per kilometer bin.\n        total_eroded_vol_per_km (np.ndarray):\n            Total eroded volume calculated per kilometer bin.\n\n    Examples:\n        - You can create an instance of the ErosionResults class as follows:\n        ```python\n        &gt;&gt;&gt; from dfastbe.bank_erosion.data_models.calculation import ErosionResults\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; erosion_results = ErosionResults(\n        ...     eq_erosion_dist=[np.array([0.1, 0.2])],\n        ...     total_erosion_dist=[np.array([0.3, 0.4])],\n        ...     flow_erosion_dist=[np.array([0.5, 0.6])],\n        ...     ship_erosion_dist=[np.array([0.7, 0.8])],\n        ...     eq_eroded_vol=[np.array([1.1, 1.2])],\n        ...     total_eroded_vol=[np.array([1.3, 1.4])],\n        ...     erosion_time=10,\n        ...     avg_erosion_rate=np.array([0.1, 0.2]),\n        ...     eq_eroded_vol_per_km=np.array([0.3, 0.4]),\n        ...     total_eroded_vol_per_km=np.array([0.5, 0.6]),\n        ... )\n        &gt;&gt;&gt; print(erosion_results)\n        ErosionResults(eq_erosion_dist=[array([0.1, 0.2])], total_erosion_dist=[array([0.3, 0.4])], flow_erosion_dist=[array([0.5, 0.6])], ship_erosion_dist=[array([0.7, 0.8])], eq_eroded_vol=[array([1.1, 1.2])], total_eroded_vol=[array([1.3, 1.4])], erosion_time=10, avg_erosion_rate=array([0.1, 0.2]), eq_eroded_vol_per_km=array([0.3, 0.4]), total_eroded_vol_per_km=array([0.5, 0.6]))\n\n        ```\n\n        - The `avg_erosion_rate`, `eq_eroded_vol_per_km`, and `total_eroded_vol_per_km` attributes are optional and\n        can be set to empty arrays if not needed.\n\n        ```python\n        &gt;&gt;&gt; from dfastbe.bank_erosion.data_models.calculation import ErosionResults\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; erosion_results = ErosionResults(\n        ...     eq_erosion_dist=[np.array([0.1, 0.2])],\n        ...     total_erosion_dist=[np.array([0.3, 0.4])],\n        ...     flow_erosion_dist=[np.array([0.5, 0.6])],\n        ...     ship_erosion_dist=[np.array([0.7, 0.8])],\n        ...     eq_eroded_vol=[np.array([1.1, 1.2])],\n        ...     total_eroded_vol=[np.array([1.3, 1.4])],\n        ...     erosion_time=10,\n        ... )\n        &gt;&gt;&gt; print(erosion_results)\n        ErosionResults(eq_erosion_dist=[array([0.1, 0.2])], total_erosion_dist=[array([0.3, 0.4])], flow_erosion_dist=[array([0.5, 0.6])], ship_erosion_dist=[array([0.7, 0.8])], eq_eroded_vol=[array([1.1, 1.2])], total_eroded_vol=[array([1.3, 1.4])], erosion_time=10, avg_erosion_rate=array([], dtype=float64), eq_eroded_vol_per_km=array([], dtype=float64), total_eroded_vol_per_km=array([], dtype=float64))\n\n        ```\n    \"\"\"\n\n    eq_erosion_dist: List[np.ndarray]\n    total_erosion_dist: List[np.ndarray]\n    flow_erosion_dist: List[np.ndarray]\n    ship_erosion_dist: List[np.ndarray]\n    eq_eroded_vol: List[np.ndarray]\n    total_eroded_vol: List[np.ndarray]\n    erosion_time: int\n    avg_erosion_rate: np.ndarray = field(default_factory=lambda : np.empty(0))\n    eq_eroded_vol_per_km: np.ndarray = field(default_factory=lambda : np.empty(0))\n    total_eroded_vol_per_km: np.ndarray = field(default_factory=lambda : np.empty(0))\n</code></pre>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.FairwayData","title":"<code>FairwayData</code>  <code>dataclass</code>","text":"<p>Class to hold fairway-related data.</p> <p>Parameters:</p> Name Type Description Default <code>fairway_face_indices</code> <code>ndarray</code> <p>Mesh face indices matching to the fairway points.</p> required <code>intersection_coords</code> <code>ndarray</code> <p>The x, y coordinates of the intersection points of the fairway with the simulation mesh.</p> required <code>fairway_initial_water_levels</code> <code>List[ndarray]</code> <p>Reference water level at the fairway</p> <code>list()</code> Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>@dataclass\nclass FairwayData:\n    \"\"\"Class to hold fairway-related data.\n\n    args:\n        fairway_face_indices (np.ndarray):\n            Mesh face indices matching to the fairway points.\n        intersection_coords (np.ndarray):\n            The x, y coordinates of the intersection points of the fairway with the simulation mesh.\n        fairway_initial_water_levels (List[np.ndarray]):\n            Reference water level at the fairway\n    \"\"\"\n    fairway_face_indices: np.ndarray\n    intersection_coords: np.ndarray\n    fairway_initial_water_levels: List[np.ndarray] = field(default_factory=list)\n</code></pre>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.SingleBank","title":"<code>SingleBank</code>  <code>dataclass</code>","text":"Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>@dataclass\nclass SingleBank:\n    is_right_bank: bool\n    bank_line_coords: np.ndarray\n    bank_face_indices: np.ndarray\n    bank_line_size: np.ndarray = field(default_factory=lambda: np.array([]))\n    fairway_distances: np.ndarray = field(default_factory=lambda: np.array([]))\n    fairway_face_indices: np.ndarray = field(default_factory=lambda: np.array([]))\n    bank_chainage_midpoints: np.ndarray = field(default_factory=lambda: np.array([]))\n\n    segment_length: np.ndarray = field(init=False)\n    dx: np.ndarray = field(init=False)\n    dy: np.ndarray = field(init=False)\n    length: int = field(init=False)\n\n    # bank height is calculated at the first discharge level only.\n    height: Optional[np.ndarray] = field(default=lambda : np.array([]))\n\n    def __post_init__(self):\n        \"\"\"Post-initialization to ensure bank_line_coords is a list of numpy arrays.\"\"\"\n        self.segment_length = self._segment_length()\n        self.dx = self._dx()\n        self.dy = self._dy()\n        self.length = len(self.bank_chainage_midpoints)\n\n    def _segment_length(self) -&gt; np.ndarray:\n        \"\"\"Calculate the length of each segment in the bank line.\n\n        Returns:\n            List[np.ndarray]: Length of each segment in the bank line.\n        \"\"\"\n        return np.linalg.norm(np.diff(self.bank_line_coords, axis=0), axis=1)\n\n    def _dx(self) -&gt; np.ndarray:\n        \"\"\"Calculate the distance between each bank line point.\n\n        Returns:\n            List[np.ndarray]: Distance to the closest fairway point for each bank line point.\n        \"\"\"\n        return np.diff(self.bank_line_coords[:, 0])\n\n    def _dy(self) -&gt; np.ndarray:\n        \"\"\"Calculate the distance between each bank line point.\n\n        Returns:\n            List[np.ndarray]: Distance to the closest fairway point for each bank line point.\n        \"\"\"\n        return np.diff(self.bank_line_coords[:, 1])\n\n    def get_mid_points(self, as_geo_series: bool = False, crs: str = None) -&gt; Union[GeoSeries, np.ndarray]:\n        \"\"\"Band line midpoints.\n\n        Args:\n            as_geo_series (bool):\n                bool indicating if the output should be a GeoSeries or not.\n            crs (str):\n                coordinate reference system.\n        Returns:\n            the midpoints of the bank line coordinates as a GeoSeries or numpy array.\n        \"\"\"\n        bank_coords = self.bank_line_coords\n        bank_coords_mind = (bank_coords[:-1] + bank_coords[1:]) / 2\n\n        if as_geo_series:\n            bank_coords_mind = [Point(xy) for xy in bank_coords_mind]\n            bank_coords_mind = GeoSeries(bank_coords_mind, crs=crs)\n        return bank_coords_mind\n</code></pre>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.SingleBank.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization to ensure bank_line_coords is a list of numpy arrays.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Post-initialization to ensure bank_line_coords is a list of numpy arrays.\"\"\"\n    self.segment_length = self._segment_length()\n    self.dx = self._dx()\n    self.dy = self._dy()\n    self.length = len(self.bank_chainage_midpoints)\n</code></pre>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.SingleBank.get_mid_points","title":"<code>get_mid_points(as_geo_series: bool = False, crs: str = None) -&gt; Union[GeoSeries, np.ndarray]</code>","text":"<p>Band line midpoints.</p> <p>Parameters:</p> Name Type Description Default <code>as_geo_series</code> <code>bool</code> <p>bool indicating if the output should be a GeoSeries or not.</p> <code>False</code> <code>crs</code> <code>str</code> <p>coordinate reference system.</p> <code>None</code> <p>Returns:     the midpoints of the bank line coordinates as a GeoSeries or numpy array.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>def get_mid_points(self, as_geo_series: bool = False, crs: str = None) -&gt; Union[GeoSeries, np.ndarray]:\n    \"\"\"Band line midpoints.\n\n    Args:\n        as_geo_series (bool):\n            bool indicating if the output should be a GeoSeries or not.\n        crs (str):\n            coordinate reference system.\n    Returns:\n        the midpoints of the bank line coordinates as a GeoSeries or numpy array.\n    \"\"\"\n    bank_coords = self.bank_line_coords\n    bank_coords_mind = (bank_coords[:-1] + bank_coords[1:]) / 2\n\n    if as_geo_series:\n        bank_coords_mind = [Point(xy) for xy in bank_coords_mind]\n        bank_coords_mind = GeoSeries(bank_coords_mind, crs=crs)\n    return bank_coords_mind\n</code></pre>"},{"location":"api/bank_erosion/data_models/calculation.html#dfastbe.bank_erosion.data_models.calculation.WaterLevelData","title":"<code>WaterLevelData</code>  <code>dataclass</code>","text":"<p>Class to hold water level data.</p> <p>Parameters:</p> Name Type Description Default <code>hfw_max</code> <code>float</code> <p>Maximum water depth along the fairway.</p> required <code>water_level</code> <code>List[List[ndarray]]</code> <p>Water level data.</p> required <code>ship_wave_max</code> <code>List[List[ndarray]]</code> <p>Maximum bank height subject to ship waves [m]</p> required <code>ship_wave_min</code> <code>List[List[ndarray]]</code> <p>Minimum bank height subject to ship waves [m]</p> required <code>velocity</code> <code>List[List[ndarray]]</code> <p>Flow velocity magnitude along the bank [m/s]</p> required <code>bank_height</code> <code>List[ndarray]</code> <p>Bank height data.</p> required <code>chezy</code> <code>List[List[ndarray]]</code> <p>Chezy coefficient data.</p> required <code>vol_per_discharge</code> <code>List[List[ndarray]]</code> <p>Eroded volume per discharge level for each bank line.</p> required Source code in <code>src/dfastbe/bank_erosion/data_models/calculation.py</code> <pre><code>@dataclass\nclass WaterLevelData:\n    \"\"\"Class to hold water level data.\n\n    args:\n        hfw_max (float): Maximum water depth along the fairway.\n        water_level (List[List[np.ndarray]]): Water level data.\n        ship_wave_max (List[List[np.ndarray]]): Maximum bank height subject to ship waves [m]\n        ship_wave_min (List[List[np.ndarray]]): Minimum bank height subject to ship waves [m]\n        velocity (List[List[np.ndarray]]): Flow velocity magnitude along the bank [m/s]\n        bank_height (List[np.ndarray]): Bank height data.\n        chezy (List[List[np.ndarray]]): Chezy coefficient data.\n        vol_per_discharge (List[List[np.ndarray]]):\n            Eroded volume per discharge level for each bank line.\n    \"\"\"\n    hfw_max: float\n    water_level: List[List[np.ndarray]]\n    ship_wave_max: List[List[np.ndarray]]\n    ship_wave_min: List[List[np.ndarray]]\n    velocity: List[List[np.ndarray]]\n    chezy: List[List[np.ndarray]]\n    vol_per_discharge: List[List[np.ndarray]]\n</code></pre>"},{"location":"api/bank_erosion/data_models/calculation.html#usage-example","title":"Usage Example","text":"<pre><code>from dfastbe.bank_erosion.data_models.calculation import BankData, ErosionInputs, ErosionResults\nfrom dfastbe.io.config import ConfigFile\nfrom dfastbe.bank_erosion.bank_erosion import Erosion\n\n\n# Load configuration file\nconfig_file = ConfigFile.read(\"config.cfg\")\n\n# Initialize Erosion object\nerosion = Erosion(config_file)\n\n# Access bank data\nbank_data = erosion.mesh_processor.get_bank_data(erosion.simulation_data.mesh_data)\n\n# Print bank data properties\nprint(f\"Number of bank lines: {bank_data.n_bank_lines}\")\nprint(f\"Left bank is right bank: {bank_data.left.is_right}\")\nprint(f\"Right bank is right bank: {bank_data.right.is_right}\")\n</code></pre> <p>For more details on the specific classes and their properties, refer to the API reference below.</p>"},{"location":"api/bank_erosion/data_models/inputs.html","title":"Bank Erosion Input Data Models","text":"<p>The Bank Erosion Input Data Models module provides data structures for representing input data in the D-FAST Bank Erosion software.</p>"},{"location":"api/bank_erosion/data_models/inputs.html#overview","title":"Overview","text":"<p>The Bank Erosion Input Data Models module contains classes that represent various aspects of bank erosion input data, such as river data and simulation data. These data models are used by the Bank Erosion module to process and analyze bank erosion.</p> <pre><code>classDiagram\n    %% Main Classes\n\n\n    %% Data Models - Bank Erosion\n    class ErosionRiverData {\n        -ConfigFile config_file\n        -LineString river_center_line\n        -Tuple station_bounds\n        +__init__(ConfigFile)\n        +simulation_data()\n        -_get_bank_output_dir()\n        -_get_bank_line_dir()\n        -_read_river_axis()\n    }\n\n    class ErosionSimulationData {\n        +compute_mesh_topology()\n        +apply_masked_indexing(array, array)\n        +calculate_bank_velocity(SingleBank, array)\n        +calculate_bank_height(SingleBank, array)\n    }</code></pre>"},{"location":"api/bank_erosion/data_models/inputs.html#components","title":"Components","text":"<p>The Bank Erosion Input Data Models module consists of the following components:</p>"},{"location":"api/bank_erosion/data_models/inputs.html#data-models","title":"Data Models","text":"<p>The data models component provides classes for representing various types of input data related to bank erosion, such as:</p> <ul> <li>ErosionSimulationData: Represents simulation data for erosion calculations, including mesh topology, bank velocity, and bank height</li> <li>ErosionRiverData: Represents river data for erosion calculations, including river center line, bank lines, and simulation data</li> <li>BankLinesResultsError: An exception class for bank lines results errors</li> </ul>"},{"location":"api/bank_erosion/data_models/inputs.html#dfastbe.bank_erosion.data_models.inputs","title":"<code>dfastbe.bank_erosion.data_models.inputs</code>","text":""},{"location":"api/bank_erosion/data_models/inputs.html#dfastbe.bank_erosion.data_models.inputs.BankLinesResultsError","title":"<code>BankLinesResultsError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for BankLine results errors.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>class BankLinesResultsError(Exception):\n    \"\"\"Custom exception for BankLine results errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/bank_erosion/data_models/inputs.html#dfastbe.bank_erosion.data_models.inputs.ErosionRiverData","title":"<code>ErosionRiverData</code>","text":"<p>               Bases: <code>BaseRiverData</code></p> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>class ErosionRiverData(BaseRiverData):\n\n    def __init__(self, config_file: ConfigFile):\n        super().__init__(config_file)\n        self.bank_dir = self._get_bank_line_dir()\n        self.output_dir = config_file.get_output_dir(\"erosion\")\n        self.debug = config_file.debug\n        # set plotting flags\n        self.plot_flags = config_file.get_plotting_flags(config_file.root_dir)\n        # get filter settings for bank levels and flow velocities along banks\n        self.zb_dx = config_file.get_float(\n            \"Erosion\", \"BedFilterDist\", 0.0, positive=True\n        )\n        self.vel_dx = config_file.get_float(\n            \"Erosion\", \"VelFilterDist\", 0.0, positive=True\n        )\n        LogData().log_text(\"get_levels\")\n        self.num_discharge_levels = config_file.get_int(\"Erosion\", \"NLevel\")\n        self.output_intervals = config_file.get_float(\"Erosion\", \"OutputInterval\", 1.0)\n        self.bank_lines = config_file.read_bank_lines(str(self.bank_dir))\n        self.river_axis = self._read_river_axis()\n        self.erosion_time = config_file.get_int(\"Erosion\", \"TErosion\", positive=True)\n\n    def simulation_data(self) -&gt; ErosionSimulationData:\n        \"\"\"Simulation Data.\"\"\"\n        ref_level = self.config_file.get_int(\"Erosion\", \"RefLevel\") - 1\n        # read simulation data (get_sim_data)\n        sim_file = self.config_file.get_sim_file(\"Erosion\", str(ref_level + 1))\n        LogData().log_text(\"-\")\n        LogData().log_text(\"read_simdata\", data={\"file\": sim_file})\n        LogData().log_text(\"-\")\n        simulation_data = ErosionSimulationData.read(sim_file)\n\n        return simulation_data\n\n    def _get_bank_output_dir(self) -&gt; Path:\n        bank_output_dir = self.config_file.get_str(\"General\", \"BankDir\")\n        LogData().log_text(\"bank_dir_out\", data={\"dir\": bank_output_dir})\n        if os.path.exists(bank_output_dir):\n            LogData().log_text(\"overwrite_dir\", data={\"dir\": bank_output_dir})\n        else:\n            os.makedirs(bank_output_dir)\n\n        return Path(bank_output_dir)\n\n    def _get_bank_line_dir(self) -&gt; Path:\n        bank_dir = self.config_file.get_str(\"General\", \"BankDir\")\n        LogData().log_text(\"bank_dir_in\", data={\"dir\": bank_dir})\n        bank_dir = Path(bank_dir)\n        if not bank_dir.exists():\n            LogData().log_text(\"missing_dir\", data={\"dir\": bank_dir})\n            raise BankLinesResultsError(\n                f\"Required bank line directory:{bank_dir} does not exist. please use the banklines command to run the \"\n                \"bankline detection tool first it.\"\n            )\n        else:\n            return bank_dir\n\n    def _read_river_axis(self) -&gt; LineString:\n        \"\"\"Get the river axis from the analysis settings.\"\"\"\n        river_axis_file = self.config_file.get_str(\"Erosion\", \"RiverAxis\")\n        LogData().log_text(\"read_river_axis\", data={\"file\": river_axis_file})\n        river_axis = XYCModel.read(river_axis_file)\n        return river_axis\n\n    def process_river_axis_by_center_line(self) -&gt; LineGeometry:\n        \"\"\"Process the river axis by the center line.\n\n        Intersect the river center line with the river axis to map the stations from the first to the latter\n        then clip the river axis by the first and last station of the centerline.\n        \"\"\"\n        river_axis = LineGeometry(self.river_axis, crs=self.config_file.crs)\n        river_axis_numpy = river_axis.as_array()\n        # optional sorting --&gt; see 04_Waal_D3D example\n        # check: sum all distances and determine maximum distance ...\n        # if maximum &gt; alpha * sum then perform sort\n        # Waal OK: 0.0082 ratio max/sum, Waal NotOK: 0.13 - Waal: 2500 points,\n        # so even when OK still some 21 times more than 1/2500 = 0.0004\n        dist2 = (np.diff(river_axis_numpy, axis=0) ** 2).sum(axis=1)\n        alpha = dist2.max() / dist2.sum()\n        if alpha &gt; 0.03:\n            print(\"The river axis needs sorting!!\")\n\n        # map km to axis points, further using axis\n        LogData().log_text(\"chainage_to_axis\")\n        river_center_line_arr = self.river_center_line.as_array()\n        river_axis_km = river_axis.intersect_with_line(river_center_line_arr)\n\n        # clip river axis to reach of interest (get the closest point to the first and last station)\n        i1 = np.argmin(\n            ((river_center_line_arr[0, :2] - river_axis_numpy) ** 2).sum(axis=1)\n        )\n        i2 = np.argmin(\n            ((river_center_line_arr[-1, :2] - river_axis_numpy) ** 2).sum(axis=1)\n        )\n        if i1 &lt; i2:\n            river_axis_km = river_axis_km[i1 : i2 + 1]\n            river_axis_numpy = river_axis_numpy[i1 : i2 + 1]\n        else:\n            # reverse river axis\n            river_axis_km = river_axis_km[i2 : i1 + 1][::-1]\n            river_axis_numpy = river_axis_numpy[i2 : i1 + 1][::-1]\n\n        river_axis = LineGeometry(river_axis_numpy, crs=self.config_file.crs)\n        river_axis.add_data(data={\"stations\": river_axis_km})\n        return river_axis\n</code></pre>"},{"location":"api/bank_erosion/data_models/inputs.html#dfastbe.bank_erosion.data_models.inputs.ErosionRiverData.process_river_axis_by_center_line","title":"<code>process_river_axis_by_center_line() -&gt; LineGeometry</code>","text":"<p>Process the river axis by the center line.</p> <p>Intersect the river center line with the river axis to map the stations from the first to the latter then clip the river axis by the first and last station of the centerline.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>def process_river_axis_by_center_line(self) -&gt; LineGeometry:\n    \"\"\"Process the river axis by the center line.\n\n    Intersect the river center line with the river axis to map the stations from the first to the latter\n    then clip the river axis by the first and last station of the centerline.\n    \"\"\"\n    river_axis = LineGeometry(self.river_axis, crs=self.config_file.crs)\n    river_axis_numpy = river_axis.as_array()\n    # optional sorting --&gt; see 04_Waal_D3D example\n    # check: sum all distances and determine maximum distance ...\n    # if maximum &gt; alpha * sum then perform sort\n    # Waal OK: 0.0082 ratio max/sum, Waal NotOK: 0.13 - Waal: 2500 points,\n    # so even when OK still some 21 times more than 1/2500 = 0.0004\n    dist2 = (np.diff(river_axis_numpy, axis=0) ** 2).sum(axis=1)\n    alpha = dist2.max() / dist2.sum()\n    if alpha &gt; 0.03:\n        print(\"The river axis needs sorting!!\")\n\n    # map km to axis points, further using axis\n    LogData().log_text(\"chainage_to_axis\")\n    river_center_line_arr = self.river_center_line.as_array()\n    river_axis_km = river_axis.intersect_with_line(river_center_line_arr)\n\n    # clip river axis to reach of interest (get the closest point to the first and last station)\n    i1 = np.argmin(\n        ((river_center_line_arr[0, :2] - river_axis_numpy) ** 2).sum(axis=1)\n    )\n    i2 = np.argmin(\n        ((river_center_line_arr[-1, :2] - river_axis_numpy) ** 2).sum(axis=1)\n    )\n    if i1 &lt; i2:\n        river_axis_km = river_axis_km[i1 : i2 + 1]\n        river_axis_numpy = river_axis_numpy[i1 : i2 + 1]\n    else:\n        # reverse river axis\n        river_axis_km = river_axis_km[i2 : i1 + 1][::-1]\n        river_axis_numpy = river_axis_numpy[i2 : i1 + 1][::-1]\n\n    river_axis = LineGeometry(river_axis_numpy, crs=self.config_file.crs)\n    river_axis.add_data(data={\"stations\": river_axis_km})\n    return river_axis\n</code></pre>"},{"location":"api/bank_erosion/data_models/inputs.html#dfastbe.bank_erosion.data_models.inputs.ErosionRiverData.simulation_data","title":"<code>simulation_data() -&gt; ErosionSimulationData</code>","text":"<p>Simulation Data.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>def simulation_data(self) -&gt; ErosionSimulationData:\n    \"\"\"Simulation Data.\"\"\"\n    ref_level = self.config_file.get_int(\"Erosion\", \"RefLevel\") - 1\n    # read simulation data (get_sim_data)\n    sim_file = self.config_file.get_sim_file(\"Erosion\", str(ref_level + 1))\n    LogData().log_text(\"-\")\n    LogData().log_text(\"read_simdata\", data={\"file\": sim_file})\n    LogData().log_text(\"-\")\n    simulation_data = ErosionSimulationData.read(sim_file)\n\n    return simulation_data\n</code></pre>"},{"location":"api/bank_erosion/data_models/inputs.html#dfastbe.bank_erosion.data_models.inputs.ErosionSimulationData","title":"<code>ErosionSimulationData</code>","text":"<p>               Bases: <code>BaseSimulationData</code></p> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>class ErosionSimulationData(BaseSimulationData):\n\n    def compute_mesh_topology(self, verbose: bool = False) -&gt; MeshData:\n        \"\"\"Derive secondary topology arrays from the face-node connectivity of the mesh.\n\n        This function computes the edge-node, edge-face, and face-edge connectivity arrays,\n        as well as the boundary edges of the mesh, based on the face-node connectivity provided\n        in the simulation data.\n\n        Returns:\n            MeshData: a dataclass containing the following attributes:\n                - `x_face_coords`: x-coordinates of face nodes\n                - `y_face_coords`: y-coordinates of face nodes\n                - `x_edge_coords`: x-coordinates of edge nodes\n                - `y_edge_coords`: y-coordinates of edge nodes\n                - `face_node`: the node indices for each of the mesh faces.\n                - `n_nodes`: number of nodes per face\n                - `edge_node`: the node indices for each of the mesh edges.\n                - `edge_face_connectivity`: the face indices for each of the mesh edge\n                - `face_edge_connectivity`: the edge indices for each of the mesh face\n                - `boundary_edge_nrs`: indices of boundary edges\n\n        Raises:\n            KeyError:\n                If required keys (e.g., `face_node`, `nnodes`, `x_node`, `y_node`) are missing from the `sim` object.\n\n        Notes:\n            - The function identifies unique edges by sorting and comparing node indices.\n            - Boundary edges are identified as edges that belong to only one face.\n            - The function assumes that the mesh is well-formed, with consistent face-node connectivity.\n        \"\"\"\n\n        # get a sorted list of edge node connections (shared edges occur twice)\n        # face_nr contains the face index to which the edge belongs\n        n_faces = self.face_node.shape[0]\n        n_edges = sum(self.n_nodes)\n        edge_node = np.zeros((n_edges, 2), dtype=int)\n        face_nr = np.zeros((n_edges,), dtype=int)\n        i = 0\n        for face_i in range(n_faces):\n            num_edges = self.n_nodes[face_i]  # note: nEdges = nNodes\n            for edge_i in range(num_edges):\n                if edge_i == 0:\n                    edge_node[i, 1] = self.face_node[face_i, num_edges - 1]\n                else:\n                    edge_node[i, 1] = self.face_node[face_i, edge_i - 1]\n                edge_node[i, 0] = self.face_node[face_i, edge_i]\n                face_nr[i] = face_i\n                i = i + 1\n        edge_node.sort(axis=1)\n        i2 = np.argsort(edge_node[:, 1], kind=\"stable\")\n        i1 = np.argsort(edge_node[i2, 0], kind=\"stable\")\n        i12 = i2[i1]\n        edge_node = edge_node[i12, :]\n        face_nr = face_nr[i12]\n\n        # detect which edges are equal to the previous edge, and get a list of all unique edges\n        numpy_true = np.array([True])\n        equal_to_previous = np.concatenate(\n            (~numpy_true, (np.diff(edge_node, axis=0) == 0).all(axis=1))\n        )\n        unique_edge = ~equal_to_previous\n        n_unique_edges = np.sum(unique_edge)\n        # reduce the edge node connections to only the unique edges\n        edge_node = edge_node[unique_edge, :]\n\n        # number the edges\n        edge_nr = np.zeros(n_edges, dtype=int)\n        edge_nr[unique_edge] = np.arange(n_unique_edges, dtype=int)\n        edge_nr[equal_to_previous] = edge_nr[\n            np.concatenate((equal_to_previous[1:], equal_to_previous[:1]))\n        ]\n\n        # if two consecutive edges are unique, the first one occurs only once and represents a boundary edge\n        is_boundary_edge = unique_edge &amp; np.concatenate((unique_edge[1:], numpy_true))\n        boundary_edge_nrs = edge_nr[is_boundary_edge]\n\n        # go back to the original face order\n        edge_nr_in_face_order = np.zeros(n_edges, dtype=int)\n        edge_nr_in_face_order[i12] = edge_nr\n        # create the face edge connectivity array\n        face_edge_connectivity = np.zeros(self.face_node.shape, dtype=int)\n\n        i = 0\n        for face_i in range(n_faces):\n            num_edges = self.n_nodes[face_i]  # note: num_edges = n_nodes\n            for edge_i in range(num_edges):\n                face_edge_connectivity[face_i, edge_i] = edge_nr_in_face_order[i]\n                i = i + 1\n\n        # determine the edge face connectivity\n        edge_face = -np.ones((n_unique_edges, 2), dtype=int)\n        edge_face[edge_nr[unique_edge], 0] = face_nr[unique_edge]\n        edge_face[edge_nr[equal_to_previous], 1] = face_nr[equal_to_previous]\n\n        x_face_coords = self.apply_masked_indexing(self.x_node, self.face_node)\n        y_face_coords = self.apply_masked_indexing(self.y_node, self.face_node)\n        x_edge_coords = self.x_node[edge_node]\n        y_edge_coords = self.y_node[edge_node]\n\n        return MeshData(\n            x_face_coords=x_face_coords,\n            y_face_coords=y_face_coords,\n            x_edge_coords=x_edge_coords,\n            y_edge_coords=y_edge_coords,\n            face_node=self.face_node,\n            n_nodes=self.n_nodes,\n            edge_node=edge_node,\n            edge_face_connectivity=edge_face,\n            face_edge_connectivity=face_edge_connectivity,\n            boundary_edge_nrs=boundary_edge_nrs,\n            verbose=verbose,\n        )\n\n    @staticmethod\n    def apply_masked_indexing(\n        x0: np.array, idx: np.ma.masked_array\n    ) -&gt; np.ma.masked_array:\n        \"\"\"\n        Index one array by another transferring the mask.\n\n        Args:\n            x0 : np.ndarray\n                A linear array.\n            idx : np.ma.masked_array\n                An index array with possibly masked indices.\n\n        returns:\n            x1: np.ma.masked_array\n                An array with same shape as idx, with mask.\n        \"\"\"\n        idx_safe = idx.copy()\n        idx_safe.data[np.ma.getmask(idx)] = 0\n        x1 = np.ma.masked_where(np.ma.getmask(idx), x0[idx_safe])\n        return x1\n\n    def calculate_bank_velocity(self, single_bank: \"SingleBank\", vel_dx) -&gt; np.ndarray:\n        from dfastbe.bank_erosion.utils import moving_avg\n\n        bank_face_indices = single_bank.bank_face_indices\n        vel_bank = (\n            np.abs(\n                self.velocity_x_face[bank_face_indices] * single_bank.dx\n                + self.velocity_y_face[bank_face_indices] * single_bank.dy\n            )\n            / single_bank.segment_length\n        )\n\n        if vel_dx &gt; 0.0:\n            vel_bank = moving_avg(single_bank.bank_chainage_midpoints, vel_bank, vel_dx)\n\n        return vel_bank\n\n    def calculate_bank_height(self, single_bank: SingleBank, zb_dx):\n        # bank height = maximum bed elevation per cell\n        from dfastbe.bank_erosion.utils import moving_avg\n\n        bank_index = single_bank.bank_face_indices\n        if self.bed_elevation_location == \"node\":\n            zb_nodes = self.bed_elevation_values\n            zb_all = self.apply_masked_indexing(zb_nodes, self.face_node[bank_index, :])\n            zb_bank = zb_all.max(axis=1)\n            if zb_dx &gt; 0.0:\n                zb_bank = moving_avg(\n                    single_bank.bank_chainage_midpoints,\n                    zb_bank,\n                    zb_dx,\n                )\n        else:\n            # don't know ... need to check neighbouring cells ...\n            zb_bank = None\n\n        return zb_bank\n\n    def get_fairway_data(self, fairway_face_indices):\n        # get fairway face indices\n        # fairway_face_indices = fairway_face_indices\n\n        # get water depth along the fair-way\n        water_depth_fairway = self.water_depth_face[fairway_face_indices]\n        water_level = self.water_level_face[fairway_face_indices]\n        chez_face = self.chezy_face[fairway_face_indices]\n        chezy = 0 * chez_face + chez_face.mean()\n\n        data = {\n            \"water_depth\": water_depth_fairway,\n            \"water_level\": water_level,\n            \"chezy\": chezy,\n        }\n        return data\n</code></pre>"},{"location":"api/bank_erosion/data_models/inputs.html#dfastbe.bank_erosion.data_models.inputs.ErosionSimulationData.apply_masked_indexing","title":"<code>apply_masked_indexing(x0: np.array, idx: np.ma.masked_array) -&gt; np.ma.masked_array</code>  <code>staticmethod</code>","text":"<p>Index one array by another transferring the mask.</p> <p>Parameters:</p> Name Type Description Default <code>x0 </code> <p>np.ndarray A linear array.</p> required <code>idx </code> <p>np.ma.masked_array An index array with possibly masked indices.</p> required <p>Returns:</p> Name Type Description <code>x1</code> <code>masked_array</code> <p>np.ma.masked_array An array with same shape as idx, with mask.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>@staticmethod\ndef apply_masked_indexing(\n    x0: np.array, idx: np.ma.masked_array\n) -&gt; np.ma.masked_array:\n    \"\"\"\n    Index one array by another transferring the mask.\n\n    Args:\n        x0 : np.ndarray\n            A linear array.\n        idx : np.ma.masked_array\n            An index array with possibly masked indices.\n\n    returns:\n        x1: np.ma.masked_array\n            An array with same shape as idx, with mask.\n    \"\"\"\n    idx_safe = idx.copy()\n    idx_safe.data[np.ma.getmask(idx)] = 0\n    x1 = np.ma.masked_where(np.ma.getmask(idx), x0[idx_safe])\n    return x1\n</code></pre>"},{"location":"api/bank_erosion/data_models/inputs.html#dfastbe.bank_erosion.data_models.inputs.ErosionSimulationData.compute_mesh_topology","title":"<code>compute_mesh_topology(verbose: bool = False) -&gt; MeshData</code>","text":"<p>Derive secondary topology arrays from the face-node connectivity of the mesh.</p> <p>This function computes the edge-node, edge-face, and face-edge connectivity arrays, as well as the boundary edges of the mesh, based on the face-node connectivity provided in the simulation data.</p> <p>Returns:</p> Name Type Description <code>MeshData</code> <code>MeshData</code> <p>a dataclass containing the following attributes: - <code>x_face_coords</code>: x-coordinates of face nodes - <code>y_face_coords</code>: y-coordinates of face nodes - <code>x_edge_coords</code>: x-coordinates of edge nodes - <code>y_edge_coords</code>: y-coordinates of edge nodes - <code>face_node</code>: the node indices for each of the mesh faces. - <code>n_nodes</code>: number of nodes per face - <code>edge_node</code>: the node indices for each of the mesh edges. - <code>edge_face_connectivity</code>: the face indices for each of the mesh edge - <code>face_edge_connectivity</code>: the edge indices for each of the mesh face - <code>boundary_edge_nrs</code>: indices of boundary edges</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If required keys (e.g., <code>face_node</code>, <code>nnodes</code>, <code>x_node</code>, <code>y_node</code>) are missing from the <code>sim</code> object.</p> Notes <ul> <li>The function identifies unique edges by sorting and comparing node indices.</li> <li>Boundary edges are identified as edges that belong to only one face.</li> <li>The function assumes that the mesh is well-formed, with consistent face-node connectivity.</li> </ul> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>def compute_mesh_topology(self, verbose: bool = False) -&gt; MeshData:\n    \"\"\"Derive secondary topology arrays from the face-node connectivity of the mesh.\n\n    This function computes the edge-node, edge-face, and face-edge connectivity arrays,\n    as well as the boundary edges of the mesh, based on the face-node connectivity provided\n    in the simulation data.\n\n    Returns:\n        MeshData: a dataclass containing the following attributes:\n            - `x_face_coords`: x-coordinates of face nodes\n            - `y_face_coords`: y-coordinates of face nodes\n            - `x_edge_coords`: x-coordinates of edge nodes\n            - `y_edge_coords`: y-coordinates of edge nodes\n            - `face_node`: the node indices for each of the mesh faces.\n            - `n_nodes`: number of nodes per face\n            - `edge_node`: the node indices for each of the mesh edges.\n            - `edge_face_connectivity`: the face indices for each of the mesh edge\n            - `face_edge_connectivity`: the edge indices for each of the mesh face\n            - `boundary_edge_nrs`: indices of boundary edges\n\n    Raises:\n        KeyError:\n            If required keys (e.g., `face_node`, `nnodes`, `x_node`, `y_node`) are missing from the `sim` object.\n\n    Notes:\n        - The function identifies unique edges by sorting and comparing node indices.\n        - Boundary edges are identified as edges that belong to only one face.\n        - The function assumes that the mesh is well-formed, with consistent face-node connectivity.\n    \"\"\"\n\n    # get a sorted list of edge node connections (shared edges occur twice)\n    # face_nr contains the face index to which the edge belongs\n    n_faces = self.face_node.shape[0]\n    n_edges = sum(self.n_nodes)\n    edge_node = np.zeros((n_edges, 2), dtype=int)\n    face_nr = np.zeros((n_edges,), dtype=int)\n    i = 0\n    for face_i in range(n_faces):\n        num_edges = self.n_nodes[face_i]  # note: nEdges = nNodes\n        for edge_i in range(num_edges):\n            if edge_i == 0:\n                edge_node[i, 1] = self.face_node[face_i, num_edges - 1]\n            else:\n                edge_node[i, 1] = self.face_node[face_i, edge_i - 1]\n            edge_node[i, 0] = self.face_node[face_i, edge_i]\n            face_nr[i] = face_i\n            i = i + 1\n    edge_node.sort(axis=1)\n    i2 = np.argsort(edge_node[:, 1], kind=\"stable\")\n    i1 = np.argsort(edge_node[i2, 0], kind=\"stable\")\n    i12 = i2[i1]\n    edge_node = edge_node[i12, :]\n    face_nr = face_nr[i12]\n\n    # detect which edges are equal to the previous edge, and get a list of all unique edges\n    numpy_true = np.array([True])\n    equal_to_previous = np.concatenate(\n        (~numpy_true, (np.diff(edge_node, axis=0) == 0).all(axis=1))\n    )\n    unique_edge = ~equal_to_previous\n    n_unique_edges = np.sum(unique_edge)\n    # reduce the edge node connections to only the unique edges\n    edge_node = edge_node[unique_edge, :]\n\n    # number the edges\n    edge_nr = np.zeros(n_edges, dtype=int)\n    edge_nr[unique_edge] = np.arange(n_unique_edges, dtype=int)\n    edge_nr[equal_to_previous] = edge_nr[\n        np.concatenate((equal_to_previous[1:], equal_to_previous[:1]))\n    ]\n\n    # if two consecutive edges are unique, the first one occurs only once and represents a boundary edge\n    is_boundary_edge = unique_edge &amp; np.concatenate((unique_edge[1:], numpy_true))\n    boundary_edge_nrs = edge_nr[is_boundary_edge]\n\n    # go back to the original face order\n    edge_nr_in_face_order = np.zeros(n_edges, dtype=int)\n    edge_nr_in_face_order[i12] = edge_nr\n    # create the face edge connectivity array\n    face_edge_connectivity = np.zeros(self.face_node.shape, dtype=int)\n\n    i = 0\n    for face_i in range(n_faces):\n        num_edges = self.n_nodes[face_i]  # note: num_edges = n_nodes\n        for edge_i in range(num_edges):\n            face_edge_connectivity[face_i, edge_i] = edge_nr_in_face_order[i]\n            i = i + 1\n\n    # determine the edge face connectivity\n    edge_face = -np.ones((n_unique_edges, 2), dtype=int)\n    edge_face[edge_nr[unique_edge], 0] = face_nr[unique_edge]\n    edge_face[edge_nr[equal_to_previous], 1] = face_nr[equal_to_previous]\n\n    x_face_coords = self.apply_masked_indexing(self.x_node, self.face_node)\n    y_face_coords = self.apply_masked_indexing(self.y_node, self.face_node)\n    x_edge_coords = self.x_node[edge_node]\n    y_edge_coords = self.y_node[edge_node]\n\n    return MeshData(\n        x_face_coords=x_face_coords,\n        y_face_coords=y_face_coords,\n        x_edge_coords=x_edge_coords,\n        y_edge_coords=y_edge_coords,\n        face_node=self.face_node,\n        n_nodes=self.n_nodes,\n        edge_node=edge_node,\n        edge_face_connectivity=edge_face,\n        face_edge_connectivity=face_edge_connectivity,\n        boundary_edge_nrs=boundary_edge_nrs,\n        verbose=verbose,\n    )\n</code></pre>"},{"location":"api/bank_erosion/data_models/inputs.html#dfastbe.bank_erosion.data_models.inputs.ShipsParameters","title":"<code>ShipsParameters</code>  <code>dataclass</code>","text":"<p>Data for ships going through the fairway for bank erosion simulation.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>ConfigFile</code> <p>Configuration file containing parameters.</p> required <code>velocity</code> <code>List[ndarray]</code> <p>Ship velocities for each bank.</p> required <code>number</code> <code>List[ndarray]</code> <p>Number of ships for each bank.</p> required <code>num_waves</code> <code>List[ndarray]</code> <p>Number of waves per ship for each bank.</p> required <code>draught</code> <code>List[ndarray]</code> <p>Draught of ships for each bank.</p> required <code>type</code> <code>List[ndarray]</code> <p>Type of ships for each bank.</p> required <code>slope</code> <code>List[ndarray]</code> <p>Slope values for each bank.</p> required <code>reed</code> <code>List[ndarray]</code> <p>Reed values for each bank.</p> required Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>@dataclass\nclass ShipsParameters:\n    \"\"\"Data for ships going through the fairway for bank erosion simulation.\n\n    Args:\n        config_file (ConfigFile):\n            Configuration file containing parameters.\n        velocity (List[np.ndarray]):\n            Ship velocities for each bank.\n        number (List[np.ndarray]):\n            Number of ships for each bank.\n        num_waves (List[np.ndarray]):\n            Number of waves per ship for each bank.\n        draught (List[np.ndarray]):\n            Draught of ships for each bank.\n        type (List[np.ndarray]):\n            Type of ships for each bank.\n        slope (List[np.ndarray]):\n            Slope values for each bank.\n        reed (List[np.ndarray]):\n            Reed values for each bank.\n    \"\"\"\n\n    config_file: ConfigFile\n    velocity: List[np.ndarray]\n    number: List[np.ndarray]\n    num_waves: List[np.ndarray]\n    draught: List[np.ndarray]\n    type: List[np.ndarray]\n    slope: List[np.ndarray]\n    reed: List[np.ndarray]\n\n    REED_DAMPING_COEFFICIENT = 8.5e-4\n    REED_DAMPING_EXPONENT = 0.8\n\n    @classmethod\n    def get_ship_data(\n        cls, num_stations_per_bank: List[int], config_file: ConfigFile\n    ) -&gt; \"ShipsParameters\":\n        \"\"\"Get ship parameters from the configuration file.\n\n        Args:\n            num_stations_per_bank (List[int]):\n                The number of stations per bank.\n            config_file (ConfigFile):\n                Configuration file containing parameters.\n\n        Returns:\n            ShipsParameters: An instance of ShipsParameters with parameters read from the config file.\n        \"\"\"\n\n        param_defs = cls._get_initial_parameter_definitions()\n        param_resolved = cls._get_parameters(\n            config_file, num_stations_per_bank, param_defs\n        )\n\n        param_dict = {\n            \"velocity\": param_resolved[\"vship\"],\n            \"number\": param_resolved[\"nship\"],\n            \"num_waves\": param_resolved[\"nwave\"],\n            \"draught\": param_resolved[\"draught\"],\n            \"type\": param_resolved[\"shiptype\"],\n            \"slope\": param_resolved[\"slope\"],\n            \"reed\": param_resolved[\"reed\"],\n        }\n\n        return cls(config_file, **param_dict)\n\n    @staticmethod\n    def _get_parameters(\n        config_file: ConfigFile,\n        num_stations_per_bank: List[int],\n        param_defs: List[Parameters],\n        level_i_str: str = \"\",\n    ) -&gt; Dict[str, np.ndarray]:\n        \"\"\"Resolve a list of Parameters with values from the configuration file.\"\"\"\n        param_resolved = {}\n\n        for param in param_defs:\n            param_resolved[f\"{param.name.lower()}\"] = config_file.get_parameter(\n                \"Erosion\",\n                f\"{param.name}{level_i_str}\",\n                num_stations_per_bank,\n                default=param.default,\n                valid=param.valid,\n                onefile=param.onefile,\n                positive=param.positive,\n                ext=param.ext,\n            )\n        return param_resolved\n\n    @classmethod\n    def _get_initial_parameter_definitions(cls) -&gt; List[Parameters]:\n        \"\"\"Get parameter definitions for discharge parameters.\n\n        Returns:\n            List[namedtuple]: List of parameter definitions.\n        \"\"\"\n        return [\n            Parameters(\"VShip\", None, None, True, True, None),\n            Parameters(\"NShip\", None, None, True, True, None),\n            Parameters(\"NWave\", 5, None, True, True, None),\n            Parameters(\"Draught\", None, None, True, True, None),\n            Parameters(\"ShipType\", None, [1, 2, 3], True, None, None),\n            Parameters(\"Slope\", 20, None, None, True, \"slp\"),\n            Parameters(\"Reed\", 0, None, None, True, \"rdd\"),\n        ]\n\n    def _get_discharge_parameter_definitions(self) -&gt; List[Parameters]:\n        \"\"\"Get parameter definitions for discharge parameters.\n\n        Returns:\n            List[namedtuple]: List of parameter definitions.\n        \"\"\"\n        return [\n            Parameters(\"VShip\", self.velocity, None, None, None, None),\n            Parameters(\"NShip\", self.number, None, None, None, None),\n            Parameters(\"NWave\", self.num_waves, None, None, None, None),\n            Parameters(\"Draught\", self.draught, None, None, None, None),\n            Parameters(\"ShipType\", self.type, [1, 2, 3], True, None, None),\n            Parameters(\"Slope\", self.slope, None, None, True, \"slp\"),\n            Parameters(\"Reed\", self.reed, None, None, True, \"rdd\"),\n        ]\n\n    @staticmethod\n    def _calculate_ship_derived_parameters(\n        slope_values: List[np.ndarray], reed_values: List[np.ndarray]\n    ) -&gt; Tuple[List[np.ndarray], List[np.ndarray]]:\n        \"\"\"Calculate derived parameters from slope and reed values.\n\n        Args:\n            slope_values (List[np.ndarray]): Slope values for each bank.\n            reed_values (List[np.ndarray]): Reed values for each bank.\n\n        Returns:\n            Tuple[List[np.ndarray], List[np.ndarray]]: Calculated mu_slope and mu_reed values.\n        \"\"\"\n        mu_slope = []\n        mu_reed = []\n\n        for ps, pr in zip(slope_values, reed_values):\n            # Calculate mu_slope (inverse of slope for non-zero values)\n            mus = ps.copy()\n            mus[mus &gt; 0] = 1.0 / mus[mus &gt; 0]\n            mu_slope.append(mus)\n\n            # Calculate mu_reed (empirical damping coefficient)\n            mu_reed.append(\n                ShipsParameters.REED_DAMPING_COEFFICIENT\n                * pr**ShipsParameters.REED_DAMPING_EXPONENT\n            )\n\n        return mu_slope, mu_reed\n\n    def read_discharge_parameters(\n        self,\n        level_i: int,\n        num_stations_per_bank: List[int],\n    ) -&gt; SingleLevelParameters:\n        \"\"\"Read Discharge level parameters.\n\n        Read all discharge-specific input arrays for level_i.\n\n        Args:\n            level_i (int):\n                The index of the discharge level.\n            num_stations_per_bank (List[int]):\n                The number of stations per bank.\n\n        Returns:\n            SingleLevelParameters: The discharge level parameters.\n        \"\"\"\n        param_defs = self._get_discharge_parameter_definitions()\n        param_resolved = self._get_parameters(\n            self.config_file, num_stations_per_bank, param_defs, f\"{level_i + 1}\"\n        )\n\n        mu_slope, mu_reed = self._calculate_ship_derived_parameters(\n            param_resolved[\"slope\"], param_resolved[\"reed\"]\n        )\n\n        return SingleLevelParameters.from_column_arrays(\n            {\n                \"id\": level_i,\n                \"ship_velocity\": param_resolved[\"vship\"],\n                \"num_ship\": param_resolved[\"nship\"],\n                \"num_waves_per_ship\": param_resolved[\"nwave\"],\n                \"ship_draught\": param_resolved[\"draught\"],\n                \"ship_type\": param_resolved[\"shiptype\"],\n                \"par_slope\": param_resolved[\"slope\"],\n                \"par_reed\": param_resolved[\"reed\"],\n                \"mu_slope\": mu_slope,\n                \"mu_reed\": mu_reed,\n            },\n            SingleParameters,\n        )\n</code></pre>"},{"location":"api/bank_erosion/data_models/inputs.html#dfastbe.bank_erosion.data_models.inputs.ShipsParameters.get_ship_data","title":"<code>get_ship_data(num_stations_per_bank: List[int], config_file: ConfigFile) -&gt; ShipsParameters</code>  <code>classmethod</code>","text":"<p>Get ship parameters from the configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>num_stations_per_bank</code> <code>List[int]</code> <p>The number of stations per bank.</p> required <code>config_file</code> <code>ConfigFile</code> <p>Configuration file containing parameters.</p> required <p>Returns:</p> Name Type Description <code>ShipsParameters</code> <code>ShipsParameters</code> <p>An instance of ShipsParameters with parameters read from the config file.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>@classmethod\ndef get_ship_data(\n    cls, num_stations_per_bank: List[int], config_file: ConfigFile\n) -&gt; \"ShipsParameters\":\n    \"\"\"Get ship parameters from the configuration file.\n\n    Args:\n        num_stations_per_bank (List[int]):\n            The number of stations per bank.\n        config_file (ConfigFile):\n            Configuration file containing parameters.\n\n    Returns:\n        ShipsParameters: An instance of ShipsParameters with parameters read from the config file.\n    \"\"\"\n\n    param_defs = cls._get_initial_parameter_definitions()\n    param_resolved = cls._get_parameters(\n        config_file, num_stations_per_bank, param_defs\n    )\n\n    param_dict = {\n        \"velocity\": param_resolved[\"vship\"],\n        \"number\": param_resolved[\"nship\"],\n        \"num_waves\": param_resolved[\"nwave\"],\n        \"draught\": param_resolved[\"draught\"],\n        \"type\": param_resolved[\"shiptype\"],\n        \"slope\": param_resolved[\"slope\"],\n        \"reed\": param_resolved[\"reed\"],\n    }\n\n    return cls(config_file, **param_dict)\n</code></pre>"},{"location":"api/bank_erosion/data_models/inputs.html#dfastbe.bank_erosion.data_models.inputs.ShipsParameters.read_discharge_parameters","title":"<code>read_discharge_parameters(level_i: int, num_stations_per_bank: List[int]) -&gt; SingleLevelParameters</code>","text":"<p>Read Discharge level parameters.</p> <p>Read all discharge-specific input arrays for level_i.</p> <p>Parameters:</p> Name Type Description Default <code>level_i</code> <code>int</code> <p>The index of the discharge level.</p> required <code>num_stations_per_bank</code> <code>List[int]</code> <p>The number of stations per bank.</p> required <p>Returns:</p> Name Type Description <code>SingleLevelParameters</code> <code>SingleLevelParameters</code> <p>The discharge level parameters.</p> Source code in <code>src/dfastbe/bank_erosion/data_models/inputs.py</code> <pre><code>def read_discharge_parameters(\n    self,\n    level_i: int,\n    num_stations_per_bank: List[int],\n) -&gt; SingleLevelParameters:\n    \"\"\"Read Discharge level parameters.\n\n    Read all discharge-specific input arrays for level_i.\n\n    Args:\n        level_i (int):\n            The index of the discharge level.\n        num_stations_per_bank (List[int]):\n            The number of stations per bank.\n\n    Returns:\n        SingleLevelParameters: The discharge level parameters.\n    \"\"\"\n    param_defs = self._get_discharge_parameter_definitions()\n    param_resolved = self._get_parameters(\n        self.config_file, num_stations_per_bank, param_defs, f\"{level_i + 1}\"\n    )\n\n    mu_slope, mu_reed = self._calculate_ship_derived_parameters(\n        param_resolved[\"slope\"], param_resolved[\"reed\"]\n    )\n\n    return SingleLevelParameters.from_column_arrays(\n        {\n            \"id\": level_i,\n            \"ship_velocity\": param_resolved[\"vship\"],\n            \"num_ship\": param_resolved[\"nship\"],\n            \"num_waves_per_ship\": param_resolved[\"nwave\"],\n            \"ship_draught\": param_resolved[\"draught\"],\n            \"ship_type\": param_resolved[\"shiptype\"],\n            \"par_slope\": param_resolved[\"slope\"],\n            \"par_reed\": param_resolved[\"reed\"],\n            \"mu_slope\": mu_slope,\n            \"mu_reed\": mu_reed,\n        },\n        SingleParameters,\n    )\n</code></pre>"},{"location":"api/bank_erosion/data_models/inputs.html#usage-example","title":"Usage Example","text":"<pre><code>from dfastbe.bank_erosion.data_models.inputs import ErosionRiverData, ErosionSimulationData\nfrom dfastbe.io.config import ConfigFile\n\n# Load configuration file\nconfig_file = ConfigFile.read(\"config.cfg\")\n\n# Create river data object\nriver_data = ErosionRiverData(config_file)\n\n# Access river data properties\nprint(f\"River center line: {river_data.river_center_line}\")\nprint(f\"Bank lines: {river_data.bank_lines}\")\n\n# Get simulation data\nsimulation_data = river_data.simulation_data()\n\n# Compute mesh topology\nmesh_data = simulation_data.compute_mesh_topology()\n</code></pre> <p>For more details on the specific classes and their properties, refer to the API reference below.</p>"},{"location":"api/bank_lines/bank_lines.html","title":"Bank Lines Module","text":"<p>The Bank Lines module is responsible for detecting bank lines from hydrodynamic simulation results. It is one of the core components of the D-FAST Bank Erosion software.</p>"},{"location":"api/bank_lines/bank_lines.html#overview","title":"Overview","text":"<p>The Bank Lines module processes hydrodynamic simulation results to detect bank lines, which are the boundaries between wet and dry areas in the river. These bank lines are then used as input for bank erosion calculations. The module can detect bank lines for multiple simulations and combine them into a single set of bank lines.</p> <pre><code>classDiagram\n    %% Main Classes\n\n    class BankLines {\n        -ConfigFile config_file\n        -bool gui\n        -Path output_dir\n        -bool debug\n        -dict plot_flags\n        -float max_river_width\n        +__init__(ConfigFile, bool)\n        +detect()\n        +mask(GeoSeries, Polygon)\n        +plot(array, int, List, Tuple, List, ConfigFile)\n        +save(List, GeoSeries, List, List, ConfigFile)\n        +detect_bank_lines(BaseSimulationData, float, ConfigFile)\n        -_calculate_water_depth(BaseSimulationData)\n        -_generate_bank_lines(BaseSimulationData, array, array, array, float)\n        -_progress_bar(int, int)\n    }\n\n    class ConfigFile {\n        -ConfigParser config\n        -str path\n        +__init__(ConfigParser, Path)\n        +read(Path)\n        +write(str)\n        +make_paths_absolute()\n        +get_str(str, str, str)\n        +get_bool(str, str, bool)\n        +get_float(str, str, float, bool)\n        +get_int(str, str, int, bool)\n        +get_sim_file(str, str)\n        +get_start_end_stations()\n        +get_search_lines()\n        +read_bank_lines(str)\n        +get_parameter(str, str, List, Any, str, bool, List, bool)\n        +get_bank_search_distances(int)\n        +get_range(str, str)\n        +get_river_center_line()\n        +resolve(str)\n        +relative_to(str)\n        +get_plotting_flags(Path)\n        +get_output_dir(str)\n    }\n\n    %% Data Models - Bank Lines\n    class BankLinesRiverData {\n        -ConfigFile config_file\n        -LineString river_center_line\n        -Tuple station_bounds\n        +search_lines()\n        -_get_bank_lines_simulation_data()\n        +simulation_data()\n    }\n\n    class SearchLines {\n        +List lines\n        +LineGeometry mask\n        +__init__(List, LineGeometry)\n        +mask(List, LineString, float)\n        -_select_closest_part(MultiLineString, LineString, float)\n        +to_polygons()\n    }\n\n    %% Data Models - IO\n    class LineGeometry {\n        +LineString line\n        +dict data\n        +__init__(LineString, Tuple, str)\n        +as_array()\n        +add_data(Dict)\n        +to_file(str, Dict)\n        +mask(LineString, Tuple)\n        -_find_mask_index(float, array)\n        -_handle_bound(int, float, bool, array)\n        -_interpolate_point(int, float, array)\n        +intersect_with_line(array)\n    }\n\n    class BaseSimulationData {\n        +array x_node\n        +array y_node\n        +array n_nodes\n        +array face_node\n        +array bed_elevation_location\n        +array bed_elevation_values\n        +array water_level_face\n        +array water_depth_face\n        +array velocity_x_face\n        +array velocity_y_face\n        +array chezy_face\n        +float dry_wet_threshold\n        +__init__(array, array, array, array, array, array, array, array, array, array, array, float)\n        +read(str, str)\n        +clip(LineString, float)\n    }\n\n    class BaseRiverData {\n        -ConfigFile config_file\n        -LineString river_center_line\n        -Tuple station_bounds\n        +__init__(ConfigFile)\n        +get_bbox(array, float)\n        +get_erosion_sim_data(int)\n    }\n\n\n    BankLines --&gt; ConfigFile : uses\n    BankLines --&gt; BankLinesRiverData : uses\n    BankLines --&gt; SearchLines : uses\n    BankLines --&gt; LineGeometry : uses\n    BankLines --&gt; BaseSimulationData : uses\n\n    SearchLines --&gt; LineGeometry : uses\n\n    BankLinesRiverData --|&gt; BaseRiverData : inherits\n    BankLinesRiverData --&gt; ConfigFile : uses\n    BankLinesRiverData --&gt; SearchLines : uses\n    BankLinesRiverData --&gt; BaseSimulationData : uses\n\n    BaseRiverData --&gt; ConfigFile : uses\n    BaseRiverData --&gt; LineGeometry : uses\n</code></pre>"},{"location":"api/bank_lines/bank_lines.html#components","title":"Components","text":"<p>The Bank Lines module consists of the following components:</p>"},{"location":"api/bank_lines/bank_lines.html#main-classes","title":"Main Classes","text":""},{"location":"api/bank_lines/bank_lines.html#dfastbe.bank_lines.bank_lines","title":"<code>dfastbe.bank_lines.bank_lines</code>","text":"<p>Bank line detection module.</p>"},{"location":"api/bank_lines/bank_lines.html#dfastbe.bank_lines.bank_lines.BankLines","title":"<code>BankLines</code>","text":"<p>               Bases: <code>BaseCalculator</code></p> <p>Bank line detection class.</p> Source code in <code>src/dfastbe/bank_lines/bank_lines.py</code> <pre><code>class BankLines(BaseCalculator):\n    \"\"\"Bank line detection class.\"\"\"\n\n    def __init__(self, config_file: ConfigFile, gui: bool = False):\n        \"\"\"Bank line initializer.\n\n        Args:\n            config_file : configparser.ConfigParser\n                Analysis configuration settings.\n            gui : bool\n                Flag indicating whether this routine is called from the GUI.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n            &gt;&gt;&gt; bank_lines = BankLines(config_file)  # doctest: +ELLIPSIS\n            N...e\n            &gt;&gt;&gt; isinstance(bank_lines, BankLines)\n            True\n\n            ```\n        \"\"\"\n        super().__init__(config_file, gui)\n        # the root_dir is used to get the FigureDir in the `_get_plotting_flags`\n        self.bank_output_dir = config_file.get_output_dir(\"banklines\")\n\n        # set plotting flags\n        self.plot_flags = config_file.get_plotting_flags(self.root_dir)\n        self.river_data = BankLinesRiverData(config_file)\n        self.search_lines = self.river_data.search_lines\n        self.simulation_data, self.critical_water_depth = (\n            self.river_data.simulation_data()\n        )\n        if self.plot_flags.plot_data:\n            self.plotter = self.get_plotter()\n\n    @property\n    def max_river_width(self) -&gt; int:\n        \"\"\"int: Maximum river width in meters.\"\"\"\n        return MAX_RIVER_WIDTH\n\n    def get_plotter(self) -&gt; BankLinesPlotter:\n        return BankLinesPlotter(\n            self.gui, self.plot_flags, self.config_file.crs, self.simulation_data, self.river_data.river_center_line,\n            self.river_data.river_center_line.station_bounds,\n        )\n\n    def detect(self) -&gt; None:\n        \"\"\"Run the bank line detection analysis for a specified configuration.\n\n        This method performs bank line detection using the provided configuration file.\n        It generates shapefiles that can be opened with GeoPandas or QGIS, and also\n        creates a plot of the detected bank lines along with the simulation data.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; import matplotlib\n            &gt;&gt;&gt; matplotlib.use('Agg')\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n            &gt;&gt;&gt; bank_lines = BankLines(config_file)  # doctest: +ELLIPSIS\n            N...e\n            &gt;&gt;&gt; bank_lines.detect()\n            &gt;&gt;&gt; bank_lines.plot()\n            &gt;&gt;&gt; bank_lines.save()\n               0...-\n\n            ```\n            In the BankDir directory specified in the .cfg, the following files are created:\n            - \"raw_detected_bankline_fragments.shp\"\n            - \"bank_areas.shp\"\n            - \"bankline_fragments_per_bank_area.shp\"\n            - \"bankfile.shp\"\n            In the FigureDir directory specified in the .cfg, the following files are created:\n            - \"1_banklinedetection.png\"\n        \"\"\"\n        timed_logger(\"-- start analysis --\")\n\n        LogData().log_text(\n            \"header_banklines\",\n            data={\n                \"version\": __version__,\n                \"location\": \"https://github.com/Deltares/D-FAST_Bank_Erosion\",\n            },\n        )\n        LogData().log_text(\"-\")\n\n        # clip the chainage path to the range of chainages of interest\n        river_center_line = self.river_data.river_center_line\n        river_center_line_values = river_center_line.values\n        center_line_arr = river_center_line.as_array()\n\n        bank_areas: List[Polygon] = self.search_lines.to_polygons()\n\n        to_right = [True] * self.search_lines.size\n        for ib in range(self.search_lines.size):\n            to_right[ib] = on_right_side(\n                np.array(self.search_lines.values[ib].coords), center_line_arr[:, :2]\n            )\n\n        LogData().log_text(\"identify_banklines\")\n        banklines = self.detect_bank_lines(\n            self.simulation_data, self.critical_water_depth, self.config_file\n        )\n\n        # clip the set of detected bank lines to the bank areas\n        LogData().log_text(\"simplify_banklines\")\n        bank = []\n        masked_bank_lines = []\n        for ib, bank_area in enumerate(bank_areas):\n            LogData().log_text(\"bank_lines\", data={\"ib\": ib + 1})\n            masked_bank_line = self.mask(banklines, bank_area)\n            if not masked_bank_line.is_empty:\n                masked_bank_lines.append(masked_bank_line)\n                bank.append(sort_connect_bank_lines(masked_bank_line, river_center_line_values, to_right[ib]))\n\n        self.results = {\n            \"bank\": bank,\n            \"banklines\": banklines,\n            \"masked_bank_lines\": masked_bank_lines,\n            \"bank_areas\": bank_areas,\n        }\n\n        LogData().log_text(\"end_banklines\")\n        timed_logger(\"-- stop analysis --\")\n\n    @staticmethod\n    def mask(banklines: GeoSeries, bank_area: Polygon) -&gt; MultiLineString:\n        \"\"\"\n        Clip the bank line segments to the area of interest.\n\n        Args:\n            banklines (GeoSeries):\n                Unordered set of bank line segments.\n            bank_area (Polygon):\n                A search area corresponding to one of the bank search lines.\n\n        Returns:\n            MultiLineString: Un-ordered set of bank line segments, clipped to bank area.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n            &gt;&gt;&gt; river_data = BankLinesRiverData(config_file)  # doctest: +ELLIPSIS\n            N...e\n            &gt;&gt;&gt; bank_lines = BankLines(config_file)\n            N...e\n            &gt;&gt;&gt; simulation_data, critical_water_depth = river_data.simulation_data()\n            N...e\n            &gt;&gt;&gt; banklines = bank_lines.detect_bank_lines(simulation_data, critical_water_depth, config_file)\n            P...)\n            &gt;&gt;&gt; bank_area = bank_lines.search_lines.to_polygons()[0]\n            &gt;&gt;&gt; bank_lines.mask(banklines, bank_area)\n            &lt;MULTILINESTRING ((207830.389 392063.658, 2078...&gt;\n\n            ```\n        \"\"\"\n        # intersection returns one MultiLineString object\n        masked_bank_lines = banklines.intersection(bank_area)[0]\n\n        return masked_bank_lines\n\n    def plot(self):\n        if self.plot_flags.plot_data:\n            self.plotter.plot(\n                self.search_lines.size,\n                self.results[\"bank\"],\n                self.results[\"bank_areas\"],\n            )\n\n    def save(self):\n        \"\"\"Save results to files.\"\"\"\n        if self.results is None:\n            raise ValueError(\"No results to save. Run the detect method first.\")\n\n        bank_name = self.config_file.get_str(\"General\", \"BankFile\", \"bankfile\")\n        bank_file = self.bank_output_dir / f\"{bank_name}{EXTENSION}\"\n        LogData().log_text(\"save_banklines\", data={\"file\": bank_file})\n        gpd.GeoSeries(self.results[\"bank\"], crs=self.config_file.crs).to_file(bank_file)\n\n        gpd.GeoSeries(self.results[\"masked_bank_lines\"], crs=self.config_file.crs).to_file(\n            self.bank_output_dir / f\"{BANKLINE_FRAGMENTS_PER_BANK_AREA_FILE}{EXTENSION}\"\n        )\n        self.results[\"banklines\"].to_file(\n            self.bank_output_dir / f\"{RAW_DETECTED_BANKLINE_FRAGMENTS_FILE}{EXTENSION}\"\n        )\n        gpd.GeoSeries(self.results[\"bank_areas\"], crs=self.config_file.crs).to_file(\n            self.bank_output_dir / f\"{BANK_AREAS_FILE}{EXTENSION}\"\n        )\n\n    @staticmethod\n    def detect_bank_lines(\n        simulation_data: BaseSimulationData,\n        critical_water_depth: float,\n        config_file: ConfigFile,\n    ) -&gt; gpd.GeoSeries:\n        \"\"\"Detect all possible bank line segments based on simulation data.\n\n        Use a critical water depth critical_water_depth as a water depth threshold for dry/wet boundary.\n\n        Args:\n            simulation_data (BaseSimulationData):\n                Simulation data: mesh, bed levels, water levels, velocities, etc.\n            critical_water_depth (float):\n                Critical water depth for determining the banks.\n\n        Returns:\n            geopandas.GeoSeries:\n                The collection of all detected bank segments in the remaining model area.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n            &gt;&gt;&gt; river_data = BankLinesRiverData(config_file)  # doctest: +ELLIPSIS\n            N...e\n            &gt;&gt;&gt; simulation_data, critical_water_depth = river_data.simulation_data()\n            N...e\n            &gt;&gt;&gt; BankLines.detect_bank_lines(simulation_data, critical_water_depth, config_file)\n            P...\n            0    MULTILINESTRING ((207927.151 391960.747, 20792...\n            dtype: geometry\n\n            ```\n        \"\"\"\n        h_node = BankLines._calculate_water_depth(simulation_data)\n        lines = BankLines._generate_bank_lines(\n            simulation_data, h_node, critical_water_depth\n        )\n        multi_line = union_all(lines)\n        merged_line = line_merge(multi_line)\n\n        return gpd.GeoSeries(merged_line, crs=config_file.crs)\n\n    @staticmethod\n    def _calculate_water_depth(\n        simulation_data: BaseSimulationData,\n    ) -&gt; np.ndarray:\n        \"\"\"Calculate the water depth at each node in the simulation data.\n\n        This method computes the water depth for each node by considering the\n        water levels at the faces and the bed elevation values at the nodes.\n        There are two cases to consider:\n           (1) the water levels at the \"dry\" faces are equal to the bed level\n               at the faces (Delft3D-FLOW, WAQUA, D-Flow FM before June 2023)\n           (2) the water levels at the \"dry\" faces are undefined (D-Flow FM\n               after June 2023)\n\n        Args:\n            simulation_data (BaseSimulationData):\n                Simulation data containing face-node relationships, water levels,\n                and bed elevation values.\n\n        Returns:\n            np.ndarray:\n                An array representing the water depth at each node.\n        \"\"\"\n        face_node = simulation_data.face_node\n        max_num_nodes = face_node.shape[1]\n        num_nodes_total = len(simulation_data.x_node)\n\n        # mask all nodes that shouldn't be used to compute the water level at the nodes.\n        # start with all unused entries in the face node connectivity\n        # mask all node indices if the water level at the face is undefined (dry)\n        mask = face_node.mask.copy()\n        mask[np.isnan(simulation_data.water_level_face)] = True\n\n        # construct two arrays of equal size:\n        # * an array of the unmasked node indices in face_node, and\n        # * an array of water levels at the corresponding face\n        total_num_node_indices = face_node.size\n        num_masked_node_indices = sum(mask.reshape(total_num_node_indices))\n        num_unmasked_node_indices = total_num_node_indices - num_masked_node_indices\n        unmasked = ~mask\n        node_indices = face_node[unmasked]\n        water_levels = np.repeat(simulation_data.water_level_face, max_num_nodes)[\n            unmasked.flatten()\n        ]\n\n        # compute the water level at nodes as the average of the water levels at all corresponding faces and use the bed level if none of the corresponding faces has a water level\n        zw_node = np.bincount(node_indices, weights=water_levels, minlength=num_nodes_total)\n        num_val = np.bincount(\n            node_indices, weights=np.ones(num_unmasked_node_indices), minlength=num_nodes_total\n        )\n        zw_node = zw_node / np.maximum(num_val, 1)\n        zw_node[num_val == 0] = simulation_data.bed_elevation_values[num_val == 0]\n        h_node = zw_node - simulation_data.bed_elevation_values\n\n        return h_node\n\n    @staticmethod\n    def _generate_bank_lines(\n        simulation_data: BaseSimulationData,\n        h_node: np.ndarray,\n        critical_water_depth: float,\n    ) -&gt; List[LineString]:\n        \"\"\"Detect bank lines based on wet/dry nodes.\n\n        Args:\n            simulation_data (BaseSimulationData):\n                Simulation data: mesh, bed levels, water levels, velocities, etc.\n            h_node (np.ndarray):\n                Water depth at each node.\n            critical_water_depth (float):\n                Critical water depth for determining the banks.\n\n        Returns:\n            List[LineString or MultiLineString]:\n                List of detected bank lines.\n        \"\"\"\n        num_faces = len(simulation_data.face_node)\n        lines = []\n\n        for i in range(num_faces):\n            BankLines._progress_bar(i, num_faces)\n\n            n_node = simulation_data.n_nodes[i]\n            face_nodes = simulation_data.face_node[i,:n_node]\n            x_face_nodes = simulation_data.x_node[face_nodes]\n            y_face_nodes = simulation_data.y_node[face_nodes]\n            h_face_nodes = h_node[face_nodes]\n\n            wet_face_nodes = h_face_nodes &gt; critical_water_depth\n            n_wet = wet_face_nodes.sum()\n            if n_wet == 0 or n_wet == n_node:\n                continue\n\n            if n_node == 3:\n                line = tri_to_line(\n                    x_face_nodes, y_face_nodes, wet_face_nodes, h_face_nodes, critical_water_depth\n                )\n            else:\n                line = poly_to_line(\n                    n_node,\n                    x_face_nodes,\n                    y_face_nodes,\n                    wet_face_nodes,\n                    h_face_nodes,\n                    critical_water_depth,\n                )\n\n            if line is not None:\n                lines.append(line)\n\n        return lines\n\n    @staticmethod\n    def _progress_bar(current: int, total: int) -&gt; None:\n        \"\"\"Print progress bar.\n\n        Args:\n            current (int): Current iteration.\n            total (int): Total iterations.\n        \"\"\"\n        if current % 100 == 0:\n            percent = (current / total) * 100\n            print(f\"Progress: {percent:.2f}% ({current}/{total})\", end=\"\\r\")\n        if current == total - 1:\n            print(\"Progress: 100.00% (100%)\")\n</code></pre>"},{"location":"api/bank_lines/bank_lines.html#dfastbe.bank_lines.bank_lines.BankLines.max_river_width","title":"<code>max_river_width: int</code>  <code>property</code>","text":"<p>int: Maximum river width in meters.</p>"},{"location":"api/bank_lines/bank_lines.html#dfastbe.bank_lines.bank_lines.BankLines.__init__","title":"<code>__init__(config_file: ConfigFile, gui: bool = False)</code>","text":"<p>Bank line initializer.</p> <p>Parameters:</p> Name Type Description Default <code>config_file </code> <p>configparser.ConfigParser Analysis configuration settings.</p> required <code>gui </code> <p>bool Flag indicating whether this routine is called from the GUI.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n&gt;&gt;&gt; bank_lines = BankLines(config_file)  # doctest: +ELLIPSIS\nN...e\n&gt;&gt;&gt; isinstance(bank_lines, BankLines)\nTrue\n</code></pre> Source code in <code>src/dfastbe/bank_lines/bank_lines.py</code> <pre><code>def __init__(self, config_file: ConfigFile, gui: bool = False):\n    \"\"\"Bank line initializer.\n\n    Args:\n        config_file : configparser.ConfigParser\n            Analysis configuration settings.\n        gui : bool\n            Flag indicating whether this routine is called from the GUI.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n        &gt;&gt;&gt; bank_lines = BankLines(config_file)  # doctest: +ELLIPSIS\n        N...e\n        &gt;&gt;&gt; isinstance(bank_lines, BankLines)\n        True\n\n        ```\n    \"\"\"\n    super().__init__(config_file, gui)\n    # the root_dir is used to get the FigureDir in the `_get_plotting_flags`\n    self.bank_output_dir = config_file.get_output_dir(\"banklines\")\n\n    # set plotting flags\n    self.plot_flags = config_file.get_plotting_flags(self.root_dir)\n    self.river_data = BankLinesRiverData(config_file)\n    self.search_lines = self.river_data.search_lines\n    self.simulation_data, self.critical_water_depth = (\n        self.river_data.simulation_data()\n    )\n    if self.plot_flags.plot_data:\n        self.plotter = self.get_plotter()\n</code></pre>"},{"location":"api/bank_lines/bank_lines.html#dfastbe.bank_lines.bank_lines.BankLines.detect","title":"<code>detect() -&gt; None</code>","text":"<p>Run the bank line detection analysis for a specified configuration.</p> <p>This method performs bank line detection using the provided configuration file. It generates shapefiles that can be opened with GeoPandas or QGIS, and also creates a plot of the detected bank lines along with the simulation data.</p> <p>Examples:</p> <p><pre><code>&gt;&gt;&gt; import matplotlib\n&gt;&gt;&gt; matplotlib.use('Agg')\n&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n&gt;&gt;&gt; bank_lines = BankLines(config_file)  # doctest: +ELLIPSIS\nN...e\n&gt;&gt;&gt; bank_lines.detect()\n&gt;&gt;&gt; bank_lines.plot()\n&gt;&gt;&gt; bank_lines.save()\n   0...-\n</code></pre> In the BankDir directory specified in the .cfg, the following files are created: - \"raw_detected_bankline_fragments.shp\" - \"bank_areas.shp\" - \"bankline_fragments_per_bank_area.shp\" - \"bankfile.shp\" In the FigureDir directory specified in the .cfg, the following files are created: - \"1_banklinedetection.png\"</p> Source code in <code>src/dfastbe/bank_lines/bank_lines.py</code> <pre><code>def detect(self) -&gt; None:\n    \"\"\"Run the bank line detection analysis for a specified configuration.\n\n    This method performs bank line detection using the provided configuration file.\n    It generates shapefiles that can be opened with GeoPandas or QGIS, and also\n    creates a plot of the detected bank lines along with the simulation data.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; import matplotlib\n        &gt;&gt;&gt; matplotlib.use('Agg')\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n        &gt;&gt;&gt; bank_lines = BankLines(config_file)  # doctest: +ELLIPSIS\n        N...e\n        &gt;&gt;&gt; bank_lines.detect()\n        &gt;&gt;&gt; bank_lines.plot()\n        &gt;&gt;&gt; bank_lines.save()\n           0...-\n\n        ```\n        In the BankDir directory specified in the .cfg, the following files are created:\n        - \"raw_detected_bankline_fragments.shp\"\n        - \"bank_areas.shp\"\n        - \"bankline_fragments_per_bank_area.shp\"\n        - \"bankfile.shp\"\n        In the FigureDir directory specified in the .cfg, the following files are created:\n        - \"1_banklinedetection.png\"\n    \"\"\"\n    timed_logger(\"-- start analysis --\")\n\n    LogData().log_text(\n        \"header_banklines\",\n        data={\n            \"version\": __version__,\n            \"location\": \"https://github.com/Deltares/D-FAST_Bank_Erosion\",\n        },\n    )\n    LogData().log_text(\"-\")\n\n    # clip the chainage path to the range of chainages of interest\n    river_center_line = self.river_data.river_center_line\n    river_center_line_values = river_center_line.values\n    center_line_arr = river_center_line.as_array()\n\n    bank_areas: List[Polygon] = self.search_lines.to_polygons()\n\n    to_right = [True] * self.search_lines.size\n    for ib in range(self.search_lines.size):\n        to_right[ib] = on_right_side(\n            np.array(self.search_lines.values[ib].coords), center_line_arr[:, :2]\n        )\n\n    LogData().log_text(\"identify_banklines\")\n    banklines = self.detect_bank_lines(\n        self.simulation_data, self.critical_water_depth, self.config_file\n    )\n\n    # clip the set of detected bank lines to the bank areas\n    LogData().log_text(\"simplify_banklines\")\n    bank = []\n    masked_bank_lines = []\n    for ib, bank_area in enumerate(bank_areas):\n        LogData().log_text(\"bank_lines\", data={\"ib\": ib + 1})\n        masked_bank_line = self.mask(banklines, bank_area)\n        if not masked_bank_line.is_empty:\n            masked_bank_lines.append(masked_bank_line)\n            bank.append(sort_connect_bank_lines(masked_bank_line, river_center_line_values, to_right[ib]))\n\n    self.results = {\n        \"bank\": bank,\n        \"banklines\": banklines,\n        \"masked_bank_lines\": masked_bank_lines,\n        \"bank_areas\": bank_areas,\n    }\n\n    LogData().log_text(\"end_banklines\")\n    timed_logger(\"-- stop analysis --\")\n</code></pre>"},{"location":"api/bank_lines/bank_lines.html#dfastbe.bank_lines.bank_lines.BankLines.detect_bank_lines","title":"<code>detect_bank_lines(simulation_data: BaseSimulationData, critical_water_depth: float, config_file: ConfigFile) -&gt; gpd.GeoSeries</code>  <code>staticmethod</code>","text":"<p>Detect all possible bank line segments based on simulation data.</p> <p>Use a critical water depth critical_water_depth as a water depth threshold for dry/wet boundary.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_data</code> <code>BaseSimulationData</code> <p>Simulation data: mesh, bed levels, water levels, velocities, etc.</p> required <code>critical_water_depth</code> <code>float</code> <p>Critical water depth for determining the banks.</p> required <p>Returns:</p> Type Description <code>GeoSeries</code> <p>geopandas.GeoSeries: The collection of all detected bank segments in the remaining model area.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n&gt;&gt;&gt; river_data = BankLinesRiverData(config_file)  # doctest: +ELLIPSIS\nN...e\n&gt;&gt;&gt; simulation_data, critical_water_depth = river_data.simulation_data()\nN...e\n&gt;&gt;&gt; BankLines.detect_bank_lines(simulation_data, critical_water_depth, config_file)\nP...\n0    MULTILINESTRING ((207927.151 391960.747, 20792...\ndtype: geometry\n</code></pre> Source code in <code>src/dfastbe/bank_lines/bank_lines.py</code> <pre><code>@staticmethod\ndef detect_bank_lines(\n    simulation_data: BaseSimulationData,\n    critical_water_depth: float,\n    config_file: ConfigFile,\n) -&gt; gpd.GeoSeries:\n    \"\"\"Detect all possible bank line segments based on simulation data.\n\n    Use a critical water depth critical_water_depth as a water depth threshold for dry/wet boundary.\n\n    Args:\n        simulation_data (BaseSimulationData):\n            Simulation data: mesh, bed levels, water levels, velocities, etc.\n        critical_water_depth (float):\n            Critical water depth for determining the banks.\n\n    Returns:\n        geopandas.GeoSeries:\n            The collection of all detected bank segments in the remaining model area.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n        &gt;&gt;&gt; river_data = BankLinesRiverData(config_file)  # doctest: +ELLIPSIS\n        N...e\n        &gt;&gt;&gt; simulation_data, critical_water_depth = river_data.simulation_data()\n        N...e\n        &gt;&gt;&gt; BankLines.detect_bank_lines(simulation_data, critical_water_depth, config_file)\n        P...\n        0    MULTILINESTRING ((207927.151 391960.747, 20792...\n        dtype: geometry\n\n        ```\n    \"\"\"\n    h_node = BankLines._calculate_water_depth(simulation_data)\n    lines = BankLines._generate_bank_lines(\n        simulation_data, h_node, critical_water_depth\n    )\n    multi_line = union_all(lines)\n    merged_line = line_merge(multi_line)\n\n    return gpd.GeoSeries(merged_line, crs=config_file.crs)\n</code></pre>"},{"location":"api/bank_lines/bank_lines.html#dfastbe.bank_lines.bank_lines.BankLines.mask","title":"<code>mask(banklines: GeoSeries, bank_area: Polygon) -&gt; MultiLineString</code>  <code>staticmethod</code>","text":"<p>Clip the bank line segments to the area of interest.</p> <p>Parameters:</p> Name Type Description Default <code>banklines</code> <code>GeoSeries</code> <p>Unordered set of bank line segments.</p> required <code>bank_area</code> <code>Polygon</code> <p>A search area corresponding to one of the bank search lines.</p> required <p>Returns:</p> Name Type Description <code>MultiLineString</code> <code>MultiLineString</code> <p>Un-ordered set of bank line segments, clipped to bank area.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n&gt;&gt;&gt; river_data = BankLinesRiverData(config_file)  # doctest: +ELLIPSIS\nN...e\n&gt;&gt;&gt; bank_lines = BankLines(config_file)\nN...e\n&gt;&gt;&gt; simulation_data, critical_water_depth = river_data.simulation_data()\nN...e\n&gt;&gt;&gt; banklines = bank_lines.detect_bank_lines(simulation_data, critical_water_depth, config_file)\nP...)\n&gt;&gt;&gt; bank_area = bank_lines.search_lines.to_polygons()[0]\n&gt;&gt;&gt; bank_lines.mask(banklines, bank_area)\n&lt;MULTILINESTRING ((207830.389 392063.658, 2078...&gt;\n</code></pre> Source code in <code>src/dfastbe/bank_lines/bank_lines.py</code> <pre><code>@staticmethod\ndef mask(banklines: GeoSeries, bank_area: Polygon) -&gt; MultiLineString:\n    \"\"\"\n    Clip the bank line segments to the area of interest.\n\n    Args:\n        banklines (GeoSeries):\n            Unordered set of bank line segments.\n        bank_area (Polygon):\n            A search area corresponding to one of the bank search lines.\n\n    Returns:\n        MultiLineString: Un-ordered set of bank line segments, clipped to bank area.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n        &gt;&gt;&gt; river_data = BankLinesRiverData(config_file)  # doctest: +ELLIPSIS\n        N...e\n        &gt;&gt;&gt; bank_lines = BankLines(config_file)\n        N...e\n        &gt;&gt;&gt; simulation_data, critical_water_depth = river_data.simulation_data()\n        N...e\n        &gt;&gt;&gt; banklines = bank_lines.detect_bank_lines(simulation_data, critical_water_depth, config_file)\n        P...)\n        &gt;&gt;&gt; bank_area = bank_lines.search_lines.to_polygons()[0]\n        &gt;&gt;&gt; bank_lines.mask(banklines, bank_area)\n        &lt;MULTILINESTRING ((207830.389 392063.658, 2078...&gt;\n\n        ```\n    \"\"\"\n    # intersection returns one MultiLineString object\n    masked_bank_lines = banklines.intersection(bank_area)[0]\n\n    return masked_bank_lines\n</code></pre>"},{"location":"api/bank_lines/bank_lines.html#dfastbe.bank_lines.bank_lines.BankLines.save","title":"<code>save()</code>","text":"<p>Save results to files.</p> Source code in <code>src/dfastbe/bank_lines/bank_lines.py</code> <pre><code>def save(self):\n    \"\"\"Save results to files.\"\"\"\n    if self.results is None:\n        raise ValueError(\"No results to save. Run the detect method first.\")\n\n    bank_name = self.config_file.get_str(\"General\", \"BankFile\", \"bankfile\")\n    bank_file = self.bank_output_dir / f\"{bank_name}{EXTENSION}\"\n    LogData().log_text(\"save_banklines\", data={\"file\": bank_file})\n    gpd.GeoSeries(self.results[\"bank\"], crs=self.config_file.crs).to_file(bank_file)\n\n    gpd.GeoSeries(self.results[\"masked_bank_lines\"], crs=self.config_file.crs).to_file(\n        self.bank_output_dir / f\"{BANKLINE_FRAGMENTS_PER_BANK_AREA_FILE}{EXTENSION}\"\n    )\n    self.results[\"banklines\"].to_file(\n        self.bank_output_dir / f\"{RAW_DETECTED_BANKLINE_FRAGMENTS_FILE}{EXTENSION}\"\n    )\n    gpd.GeoSeries(self.results[\"bank_areas\"], crs=self.config_file.crs).to_file(\n        self.bank_output_dir / f\"{BANK_AREAS_FILE}{EXTENSION}\"\n    )\n</code></pre>"},{"location":"api/bank_lines/bank_lines.html#data-models","title":"Data Models","text":""},{"location":"api/bank_lines/bank_lines.html#dfastbe.bank_lines.data_models","title":"<code>dfastbe.bank_lines.data_models</code>","text":""},{"location":"api/bank_lines/bank_lines.html#dfastbe.bank_lines.data_models.BankLinesRiverData","title":"<code>BankLinesRiverData</code>","text":"<p>               Bases: <code>BaseRiverData</code></p> Source code in <code>src/dfastbe/bank_lines/data_models.py</code> <pre><code>class BankLinesRiverData(BaseRiverData):\n\n    @property\n    def search_lines(self) -&gt; SearchLines:\n        \"\"\"Get search lines for bank lines.\n\n        Returns:\n            SearchLines:\n                Search lines for bank lines.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n            &gt;&gt;&gt; bank_lines_river_data = BankLinesRiverData(config_file)\n            No message found for read_chainage\n            No message found for clip_chainage\n            &gt;&gt;&gt; search_lines = bank_lines_river_data.search_lines\n            No message found for read_search_line\n            No message found for read_search_line\n            &gt;&gt;&gt; len(search_lines.values)\n            2\n\n            ```\n        \"\"\"\n        search_lines = SearchLines(self.config_file.get_search_lines(), self.river_center_line)\n        search_lines.d_lines = self.config_file.get_bank_search_distances(search_lines.size)\n        return search_lines\n\n    def _get_bank_lines_simulation_data(self) -&gt; Tuple[BaseSimulationData, float]:\n        \"\"\"read simulation data and drying flooding threshold dh0\n\n        Returns:\n            Tuple[BaseSimulationData, float]:\n                simulation data and critical water depth (h0).\n        \"\"\"\n        sim_file = self.config_file.get_sim_file(\"Detect\", \"\")\n        LogData().log_text(\"read_simdata\", data={\"file\": sim_file})\n        simulation_data = BaseSimulationData.read(sim_file)\n        # increase critical water depth h0 by flooding threshold dh0\n        # get critical water depth used for defining bank line (default = 0.0 m)\n        critical_water_depth = self.config_file.get_float(\n            \"Detect\", \"WaterDepth\", default=0\n        )\n        h0 = critical_water_depth + simulation_data.dry_wet_threshold\n        return simulation_data, h0\n\n    def simulation_data(self) -&gt; Tuple[BaseSimulationData, float]:\n        \"\"\"Get simulation data and critical water depth and clip to river center line.\n\n        Returns:\n            Tuple[BaseSimulationData, float]:\n                simulation data and critical water depth (h0).\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n            &gt;&gt;&gt; bank_lines_river_data = BankLinesRiverData(config_file)  # doctest: +ELLIPSIS\n            N...e\n            &gt;&gt;&gt; simulation_data, h0 = bank_lines_river_data.simulation_data()\n            N...e\n            &gt;&gt;&gt; h0\n            0.1\n\n            ```\n        \"\"\"\n        simulation_data, h0 = self._get_bank_lines_simulation_data()\n        # clip simulation data to boundaries ...\n        LogData().log_text(\"clip_data\")\n        simulation_data.clip(self.river_center_line.values, self.search_lines.max_distance)\n\n        return simulation_data, h0\n</code></pre>"},{"location":"api/bank_lines/bank_lines.html#dfastbe.bank_lines.data_models.BankLinesRiverData.search_lines","title":"<code>search_lines: SearchLines</code>  <code>property</code>","text":"<p>Get search lines for bank lines.</p> <p>Returns:</p> Name Type Description <code>SearchLines</code> <code>SearchLines</code> <p>Search lines for bank lines.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n&gt;&gt;&gt; bank_lines_river_data = BankLinesRiverData(config_file)\nNo message found for read_chainage\nNo message found for clip_chainage\n&gt;&gt;&gt; search_lines = bank_lines_river_data.search_lines\nNo message found for read_search_line\nNo message found for read_search_line\n&gt;&gt;&gt; len(search_lines.values)\n2\n</code></pre>"},{"location":"api/bank_lines/bank_lines.html#dfastbe.bank_lines.data_models.BankLinesRiverData.simulation_data","title":"<code>simulation_data() -&gt; Tuple[BaseSimulationData, float]</code>","text":"<p>Get simulation data and critical water depth and clip to river center line.</p> <p>Returns:</p> Type Description <code>Tuple[BaseSimulationData, float]</code> <p>Tuple[BaseSimulationData, float]: simulation data and critical water depth (h0).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n&gt;&gt;&gt; bank_lines_river_data = BankLinesRiverData(config_file)  # doctest: +ELLIPSIS\nN...e\n&gt;&gt;&gt; simulation_data, h0 = bank_lines_river_data.simulation_data()\nN...e\n&gt;&gt;&gt; h0\n0.1\n</code></pre> Source code in <code>src/dfastbe/bank_lines/data_models.py</code> <pre><code>def simulation_data(self) -&gt; Tuple[BaseSimulationData, float]:\n    \"\"\"Get simulation data and critical water depth and clip to river center line.\n\n    Returns:\n        Tuple[BaseSimulationData, float]:\n            simulation data and critical water depth (h0).\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n        &gt;&gt;&gt; bank_lines_river_data = BankLinesRiverData(config_file)  # doctest: +ELLIPSIS\n        N...e\n        &gt;&gt;&gt; simulation_data, h0 = bank_lines_river_data.simulation_data()\n        N...e\n        &gt;&gt;&gt; h0\n        0.1\n\n        ```\n    \"\"\"\n    simulation_data, h0 = self._get_bank_lines_simulation_data()\n    # clip simulation data to boundaries ...\n    LogData().log_text(\"clip_data\")\n    simulation_data.clip(self.river_center_line.values, self.search_lines.max_distance)\n\n    return simulation_data, h0\n</code></pre>"},{"location":"api/bank_lines/bank_lines.html#dfastbe.bank_lines.data_models.SearchLines","title":"<code>SearchLines</code>","text":"Source code in <code>src/dfastbe/bank_lines/data_models.py</code> <pre><code>class SearchLines:\n\n    def __init__(self, lines: List[LineString], mask: LineGeometry = None):\n        \"\"\"Search lines initialization.\n\n        Args:\n            lines (List[LineString]):\n                List of search lines.\n            mask (LineGeometry, optional):\n                Center line for masking the search lines. Defaults to None.\n        \"\"\"\n        if mask is None:\n            self.values = lines\n            self.max_distance = None\n        else:\n            self.values, self.max_distance = self.mask(lines, mask.values)\n\n        self.size = len(lines)\n\n    @property\n    def d_lines(self) -&gt; List[float]:\n        if hasattr(self, \"_d_lines\"):\n            return self._d_lines\n        else:\n            raise ValueError(\"The d_lines property has not been set yet.\")\n\n    @d_lines.setter\n    def d_lines(self, value: List[float]):\n        self._d_lines = value\n\n    @staticmethod\n    def mask(\n        search_lines: List[LineString],\n        river_center_line: LineString,\n        max_river_width: float = MAX_RIVER_WIDTH,\n    ) -&gt; Tuple[List[LineString], float]:\n        \"\"\"\n        Clip the list of lines to the envelope of a certain size surrounding a reference line.\n\n        Args:\n            search_lines (List[LineString]):\n                List of lines to be clipped.\n            river_center_line (LineString):\n                Reference line to which the search lines are clipped.\n            max_river_width: float\n                Maximum distance away from river_profile.\n\n        Returns:\n            Tuple[List[LineString], float]:\n                - List of clipped search lines.\n                - Maximum distance from any point within line to reference line.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from shapely.geometry import LineString\n            &gt;&gt;&gt; search_lines = [LineString([(0, 0), (1, 1)]), LineString([(2, 2), (3, 3)])]\n            &gt;&gt;&gt; river_center_line = LineString([(0, 0), (2, 2)])\n            &gt;&gt;&gt; search_lines_clipped, max_distance = SearchLines.mask(search_lines, river_center_line)\n            &gt;&gt;&gt; max_distance\n            2.0\n\n            ```\n        \"\"\"\n        num = len(search_lines)\n        profile_buffer = river_center_line.buffer(max_river_width, cap_style=2)\n\n        # The algorithm uses simplified geometries for determining the distance between lines for speed.\n        # Stay accurate to within about 1 m\n        profile_simplified = river_center_line.simplify(1)\n\n        max_distance = 0\n        for ind in range(num):\n            # Clip the bank search lines to the reach of interest (indicated by the reference line).\n            search_lines[ind] = search_lines[ind].intersection(profile_buffer)\n\n            # If the bank search line breaks into multiple parts, select the part closest to the reference line.\n            if search_lines[ind].geom_type == \"MultiLineString\":\n                search_lines[ind] = SearchLines._select_closest_part(\n                    search_lines[ind], profile_simplified, max_river_width\n                )\n\n            # Determine the maximum distance from a point on this line to the reference line.\n            line_simplified = search_lines[ind].simplify(1)\n            max_distance = max(\n                [Point(c).distance(profile_simplified) for c in line_simplified.coords]\n            )\n\n            # Increase the value of max_distance by 2 to account for error introduced by using simplified lines.\n            max_distance = max(max_distance, max_distance + 2)\n\n        return search_lines, max_distance\n\n    @staticmethod\n    def _select_closest_part(\n        search_lines_segments: MultiLineString,\n        reference_line: LineString,\n        max_river_width: float,\n    ) -&gt; LineString:\n        \"\"\"Select the closest part of a MultiLineString to the reference line.\n\n        Args:\n            search_lines_segments (MultiLineString):\n                The MultiLineString containing multiple line segments to evaluate.\n            reference_line (LineString):\n                The reference line to calculate distances.\n            max_river_width (float):\n                Maximum allowable distance.\n\n        Returns:\n            LineString: The closest part of the MultiLineString.\n        \"\"\"\n        closest_part = search_lines_segments.geoms[0]\n        min_distance = max_river_width\n\n        for part in search_lines_segments.geoms:\n            simplified_part = part.simplify(1)\n            distance = simplified_part.distance(reference_line)\n            if distance &lt; min_distance:\n                min_distance = distance\n                closest_part = part\n\n        return closest_part\n\n    def to_polygons(self) -&gt; List[Polygon]:\n        \"\"\"\n        Construct a series of polygons surrounding the bank search lines.\n\n        Returns:\n            bank_areas:\n                Array containing the areas of interest surrounding the bank search lines.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; search_lines = [LineString([(0, 0), (1, 1)]), LineString([(2, 2), (3, 3)])]\n            &gt;&gt;&gt; search_lines_clipped = SearchLines(search_lines)\n            &gt;&gt;&gt; search_lines_clipped.d_lines = [10, 20]\n            &gt;&gt;&gt; bank_areas = search_lines_clipped.to_polygons()\n            &gt;&gt;&gt; len(bank_areas)\n            2\n\n            ```\n        \"\"\"\n        bank_areas = [\n            self.values[b].buffer(distance, cap_style=2)\n            for b, distance in enumerate(self.d_lines)\n        ]\n        return bank_areas\n</code></pre>"},{"location":"api/bank_lines/bank_lines.html#dfastbe.bank_lines.data_models.SearchLines.__init__","title":"<code>__init__(lines: List[LineString], mask: LineGeometry = None)</code>","text":"<p>Search lines initialization.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>List[LineString]</code> <p>List of search lines.</p> required <code>mask</code> <code>LineGeometry</code> <p>Center line for masking the search lines. Defaults to None.</p> <code>None</code> Source code in <code>src/dfastbe/bank_lines/data_models.py</code> <pre><code>def __init__(self, lines: List[LineString], mask: LineGeometry = None):\n    \"\"\"Search lines initialization.\n\n    Args:\n        lines (List[LineString]):\n            List of search lines.\n        mask (LineGeometry, optional):\n            Center line for masking the search lines. Defaults to None.\n    \"\"\"\n    if mask is None:\n        self.values = lines\n        self.max_distance = None\n    else:\n        self.values, self.max_distance = self.mask(lines, mask.values)\n\n    self.size = len(lines)\n</code></pre>"},{"location":"api/bank_lines/bank_lines.html#dfastbe.bank_lines.data_models.SearchLines.mask","title":"<code>mask(search_lines: List[LineString], river_center_line: LineString, max_river_width: float = MAX_RIVER_WIDTH) -&gt; Tuple[List[LineString], float]</code>  <code>staticmethod</code>","text":"<p>Clip the list of lines to the envelope of a certain size surrounding a reference line.</p> <p>Parameters:</p> Name Type Description Default <code>search_lines</code> <code>List[LineString]</code> <p>List of lines to be clipped.</p> required <code>river_center_line</code> <code>LineString</code> <p>Reference line to which the search lines are clipped.</p> required <code>max_river_width</code> <code>float</code> <p>float Maximum distance away from river_profile.</p> <code>MAX_RIVER_WIDTH</code> <p>Returns:</p> Type Description <code>Tuple[List[LineString], float]</code> <p>Tuple[List[LineString], float]: - List of clipped search lines. - Maximum distance from any point within line to reference line.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shapely.geometry import LineString\n&gt;&gt;&gt; search_lines = [LineString([(0, 0), (1, 1)]), LineString([(2, 2), (3, 3)])]\n&gt;&gt;&gt; river_center_line = LineString([(0, 0), (2, 2)])\n&gt;&gt;&gt; search_lines_clipped, max_distance = SearchLines.mask(search_lines, river_center_line)\n&gt;&gt;&gt; max_distance\n2.0\n</code></pre> Source code in <code>src/dfastbe/bank_lines/data_models.py</code> <pre><code>@staticmethod\ndef mask(\n    search_lines: List[LineString],\n    river_center_line: LineString,\n    max_river_width: float = MAX_RIVER_WIDTH,\n) -&gt; Tuple[List[LineString], float]:\n    \"\"\"\n    Clip the list of lines to the envelope of a certain size surrounding a reference line.\n\n    Args:\n        search_lines (List[LineString]):\n            List of lines to be clipped.\n        river_center_line (LineString):\n            Reference line to which the search lines are clipped.\n        max_river_width: float\n            Maximum distance away from river_profile.\n\n    Returns:\n        Tuple[List[LineString], float]:\n            - List of clipped search lines.\n            - Maximum distance from any point within line to reference line.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from shapely.geometry import LineString\n        &gt;&gt;&gt; search_lines = [LineString([(0, 0), (1, 1)]), LineString([(2, 2), (3, 3)])]\n        &gt;&gt;&gt; river_center_line = LineString([(0, 0), (2, 2)])\n        &gt;&gt;&gt; search_lines_clipped, max_distance = SearchLines.mask(search_lines, river_center_line)\n        &gt;&gt;&gt; max_distance\n        2.0\n\n        ```\n    \"\"\"\n    num = len(search_lines)\n    profile_buffer = river_center_line.buffer(max_river_width, cap_style=2)\n\n    # The algorithm uses simplified geometries for determining the distance between lines for speed.\n    # Stay accurate to within about 1 m\n    profile_simplified = river_center_line.simplify(1)\n\n    max_distance = 0\n    for ind in range(num):\n        # Clip the bank search lines to the reach of interest (indicated by the reference line).\n        search_lines[ind] = search_lines[ind].intersection(profile_buffer)\n\n        # If the bank search line breaks into multiple parts, select the part closest to the reference line.\n        if search_lines[ind].geom_type == \"MultiLineString\":\n            search_lines[ind] = SearchLines._select_closest_part(\n                search_lines[ind], profile_simplified, max_river_width\n            )\n\n        # Determine the maximum distance from a point on this line to the reference line.\n        line_simplified = search_lines[ind].simplify(1)\n        max_distance = max(\n            [Point(c).distance(profile_simplified) for c in line_simplified.coords]\n        )\n\n        # Increase the value of max_distance by 2 to account for error introduced by using simplified lines.\n        max_distance = max(max_distance, max_distance + 2)\n\n    return search_lines, max_distance\n</code></pre>"},{"location":"api/bank_lines/bank_lines.html#dfastbe.bank_lines.data_models.SearchLines.to_polygons","title":"<code>to_polygons() -&gt; List[Polygon]</code>","text":"<p>Construct a series of polygons surrounding the bank search lines.</p> <p>Returns:</p> Name Type Description <code>bank_areas</code> <code>List[Polygon]</code> <p>Array containing the areas of interest surrounding the bank search lines.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; search_lines = [LineString([(0, 0), (1, 1)]), LineString([(2, 2), (3, 3)])]\n&gt;&gt;&gt; search_lines_clipped = SearchLines(search_lines)\n&gt;&gt;&gt; search_lines_clipped.d_lines = [10, 20]\n&gt;&gt;&gt; bank_areas = search_lines_clipped.to_polygons()\n&gt;&gt;&gt; len(bank_areas)\n2\n</code></pre> Source code in <code>src/dfastbe/bank_lines/data_models.py</code> <pre><code>def to_polygons(self) -&gt; List[Polygon]:\n    \"\"\"\n    Construct a series of polygons surrounding the bank search lines.\n\n    Returns:\n        bank_areas:\n            Array containing the areas of interest surrounding the bank search lines.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; search_lines = [LineString([(0, 0), (1, 1)]), LineString([(2, 2), (3, 3)])]\n        &gt;&gt;&gt; search_lines_clipped = SearchLines(search_lines)\n        &gt;&gt;&gt; search_lines_clipped.d_lines = [10, 20]\n        &gt;&gt;&gt; bank_areas = search_lines_clipped.to_polygons()\n        &gt;&gt;&gt; len(bank_areas)\n        2\n\n        ```\n    \"\"\"\n    bank_areas = [\n        self.values[b].buffer(distance, cap_style=2)\n        for b, distance in enumerate(self.d_lines)\n    ]\n    return bank_areas\n</code></pre>"},{"location":"api/bank_lines/bank_lines.html#utility-functions","title":"Utility Functions","text":"<p>The Bank Lines module includes several utility functions for processing bank lines:</p> <ul> <li>sort_connect_bank_lines: Sorts and connects bank line fragments</li> <li>poly_to_line: Converts polygons to lines</li> <li>tri_to_line: Converts triangles to lines</li> </ul>"},{"location":"api/bank_lines/bank_lines.html#workflow","title":"Workflow","text":"<p>The typical workflow for bank line detection is:</p> <ol> <li>Initialize the BankLines object with a configuration file</li> <li>Call the <code>detect</code> method to start the bank line detection process</li> <li>The <code>detect</code> method orchestrates the entire process:</li> <li>Loads hydrodynamic simulation data</li> <li>Calculates water depth</li> <li>Generates bank lines</li> <li>Masks bank lines with bank areas</li> <li>Saves bank lines to output files</li> <li>Generates plots</li> </ol>"},{"location":"api/bank_lines/bank_lines.html#usage-example","title":"Usage Example","text":"<pre><code>from dfastbe.io.config import ConfigFile\nfrom dfastbe.bank_lines.bank_lines import BankLines\n\n# Load configuration file\nconfig_file = ConfigFile.read(\"config.cfg\")\n\n# Initialize BankLines object\nbank_lines = BankLines(config_file)\n\n# Run bank line detection\nbank_lines.detect()\n\n# plot results\nbank_lines.plot()\n\n# Save results\nbank_lines.save()\n</code></pre> <p>For more details on the specific methods and classes, refer to the API reference below.</p>"},{"location":"api/bank_lines/data_models.html","title":"Bank Lines Data Models","text":"<p>The Bank Lines Data Models module provides data structures for representing bank lines and related data in the D-FAST Bank Erosion software.</p>"},{"location":"api/bank_lines/data_models.html#overview","title":"Overview","text":"<p>The Bank Lines Data Models module contains classes that represent various aspects of bank lines, such as river data, simulation data, and bank line geometry. These data models are used by the Bank Lines module to process and analyze bank lines.</p> <pre><code>classDiagram\n    %% Main Classes\n\n    %% Data Models - Bank Lines\n    class BankLinesRiverData {\n        -ConfigFile config_file\n        -LineString river_center_line\n        -Tuple station_bounds\n        +search_lines()\n        -_get_bank_lines_simulation_data()\n        +simulation_data()\n    }\n\n    class SearchLines {\n        +List lines\n        +LineGeometry mask\n        +__init__(List, LineGeometry)\n        +mask(List, LineString, float)\n        -_select_closest_part(MultiLineString, LineString, float)\n        +to_polygons()\n    }\n\n    %% Data Models - IO\n    class LineGeometry {\n        +LineString line\n        +dict data\n        +__init__(LineString, Tuple, str)\n        +as_array()\n        +add_data(Dict)\n        +to_file(str, Dict)\n        +mask(LineString, Tuple)\n        -_find_mask_index(float, array)\n        -_handle_bound(int, float, bool, array)\n        -_interpolate_point(int, float, array)\n        +intersect_with_line(array)\n    }\n\n    class BaseSimulationData {\n        +array x_node\n        +array y_node\n        +array n_nodes\n        +array face_node\n        +array bed_elevation_location\n        +array bed_elevation_values\n        +array water_level_face\n        +array water_depth_face\n        +array velocity_x_face\n        +array velocity_y_face\n        +array chezy_face\n        +float dry_wet_threshold\n        +__init__(array, array, array, array, array, array, array, array, array, array, array, float)\n        +read(str, str)\n        +clip(LineString, float)\n    }\n\n    class BaseRiverData {\n        -ConfigFile config_file\n        -LineString river_center_line\n        -Tuple station_bounds\n        +__init__(ConfigFile)\n        +get_bbox(array, float)\n        +get_erosion_sim_data(int)\n    }\n\n    SearchLines --&gt; LineGeometry : uses\n\n    BankLinesRiverData --|&gt; BaseRiverData : inherits\n    BankLinesRiverData --&gt; ConfigFile : uses\n    BankLinesRiverData --&gt; SearchLines : uses\n    BankLinesRiverData --&gt; BaseSimulationData : uses\n\n    BaseRiverData --&gt; ConfigFile : uses\n    BaseRiverData --&gt; LineGeometry : uses\n</code></pre>"},{"location":"api/bank_lines/data_models.html#components","title":"Components","text":"<p>The Bank Lines Data Models module consists of the following components:</p>"},{"location":"api/bank_lines/data_models.html#data-models","title":"Data Models","text":"<p>The data models component provides classes for representing various types of data related to bank lines, such as:</p> <ul> <li>BankLinesRiverData: Represents river data for bank line detection</li> <li>BankLineGeometry: Represents the geometry of a bank line</li> <li>BankLineProperties: Represents properties of a bank line</li> </ul>"},{"location":"api/bank_lines/data_models.html#dfastbe.bank_lines.data_models","title":"<code>dfastbe.bank_lines.data_models</code>","text":""},{"location":"api/bank_lines/data_models.html#dfastbe.bank_lines.data_models.BankLinesRiverData","title":"<code>BankLinesRiverData</code>","text":"<p>               Bases: <code>BaseRiverData</code></p> Source code in <code>src/dfastbe/bank_lines/data_models.py</code> <pre><code>class BankLinesRiverData(BaseRiverData):\n\n    @property\n    def search_lines(self) -&gt; SearchLines:\n        \"\"\"Get search lines for bank lines.\n\n        Returns:\n            SearchLines:\n                Search lines for bank lines.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n            &gt;&gt;&gt; bank_lines_river_data = BankLinesRiverData(config_file)\n            No message found for read_chainage\n            No message found for clip_chainage\n            &gt;&gt;&gt; search_lines = bank_lines_river_data.search_lines\n            No message found for read_search_line\n            No message found for read_search_line\n            &gt;&gt;&gt; len(search_lines.values)\n            2\n\n            ```\n        \"\"\"\n        search_lines = SearchLines(self.config_file.get_search_lines(), self.river_center_line)\n        search_lines.d_lines = self.config_file.get_bank_search_distances(search_lines.size)\n        return search_lines\n\n    def _get_bank_lines_simulation_data(self) -&gt; Tuple[BaseSimulationData, float]:\n        \"\"\"read simulation data and drying flooding threshold dh0\n\n        Returns:\n            Tuple[BaseSimulationData, float]:\n                simulation data and critical water depth (h0).\n        \"\"\"\n        sim_file = self.config_file.get_sim_file(\"Detect\", \"\")\n        LogData().log_text(\"read_simdata\", data={\"file\": sim_file})\n        simulation_data = BaseSimulationData.read(sim_file)\n        # increase critical water depth h0 by flooding threshold dh0\n        # get critical water depth used for defining bank line (default = 0.0 m)\n        critical_water_depth = self.config_file.get_float(\n            \"Detect\", \"WaterDepth\", default=0\n        )\n        h0 = critical_water_depth + simulation_data.dry_wet_threshold\n        return simulation_data, h0\n\n    def simulation_data(self) -&gt; Tuple[BaseSimulationData, float]:\n        \"\"\"Get simulation data and critical water depth and clip to river center line.\n\n        Returns:\n            Tuple[BaseSimulationData, float]:\n                simulation data and critical water depth (h0).\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n            &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n            &gt;&gt;&gt; bank_lines_river_data = BankLinesRiverData(config_file)  # doctest: +ELLIPSIS\n            N...e\n            &gt;&gt;&gt; simulation_data, h0 = bank_lines_river_data.simulation_data()\n            N...e\n            &gt;&gt;&gt; h0\n            0.1\n\n            ```\n        \"\"\"\n        simulation_data, h0 = self._get_bank_lines_simulation_data()\n        # clip simulation data to boundaries ...\n        LogData().log_text(\"clip_data\")\n        simulation_data.clip(self.river_center_line.values, self.search_lines.max_distance)\n\n        return simulation_data, h0\n</code></pre>"},{"location":"api/bank_lines/data_models.html#dfastbe.bank_lines.data_models.BankLinesRiverData.search_lines","title":"<code>search_lines: SearchLines</code>  <code>property</code>","text":"<p>Get search lines for bank lines.</p> <p>Returns:</p> Name Type Description <code>SearchLines</code> <code>SearchLines</code> <p>Search lines for bank lines.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n&gt;&gt;&gt; bank_lines_river_data = BankLinesRiverData(config_file)\nNo message found for read_chainage\nNo message found for clip_chainage\n&gt;&gt;&gt; search_lines = bank_lines_river_data.search_lines\nNo message found for read_search_line\nNo message found for read_search_line\n&gt;&gt;&gt; len(search_lines.values)\n2\n</code></pre>"},{"location":"api/bank_lines/data_models.html#dfastbe.bank_lines.data_models.BankLinesRiverData.simulation_data","title":"<code>simulation_data() -&gt; Tuple[BaseSimulationData, float]</code>","text":"<p>Get simulation data and critical water depth and clip to river center line.</p> <p>Returns:</p> Type Description <code>Tuple[BaseSimulationData, float]</code> <p>Tuple[BaseSimulationData, float]: simulation data and critical water depth (h0).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n&gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n&gt;&gt;&gt; bank_lines_river_data = BankLinesRiverData(config_file)  # doctest: +ELLIPSIS\nN...e\n&gt;&gt;&gt; simulation_data, h0 = bank_lines_river_data.simulation_data()\nN...e\n&gt;&gt;&gt; h0\n0.1\n</code></pre> Source code in <code>src/dfastbe/bank_lines/data_models.py</code> <pre><code>def simulation_data(self) -&gt; Tuple[BaseSimulationData, float]:\n    \"\"\"Get simulation data and critical water depth and clip to river center line.\n\n    Returns:\n        Tuple[BaseSimulationData, float]:\n            simulation data and critical water depth (h0).\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from dfastbe.io.config import ConfigFile\n        &gt;&gt;&gt; config_file = ConfigFile.read(\"tests/data/bank_lines/meuse_manual.cfg\")\n        &gt;&gt;&gt; bank_lines_river_data = BankLinesRiverData(config_file)  # doctest: +ELLIPSIS\n        N...e\n        &gt;&gt;&gt; simulation_data, h0 = bank_lines_river_data.simulation_data()\n        N...e\n        &gt;&gt;&gt; h0\n        0.1\n\n        ```\n    \"\"\"\n    simulation_data, h0 = self._get_bank_lines_simulation_data()\n    # clip simulation data to boundaries ...\n    LogData().log_text(\"clip_data\")\n    simulation_data.clip(self.river_center_line.values, self.search_lines.max_distance)\n\n    return simulation_data, h0\n</code></pre>"},{"location":"api/bank_lines/data_models.html#dfastbe.bank_lines.data_models.SearchLines","title":"<code>SearchLines</code>","text":"Source code in <code>src/dfastbe/bank_lines/data_models.py</code> <pre><code>class SearchLines:\n\n    def __init__(self, lines: List[LineString], mask: LineGeometry = None):\n        \"\"\"Search lines initialization.\n\n        Args:\n            lines (List[LineString]):\n                List of search lines.\n            mask (LineGeometry, optional):\n                Center line for masking the search lines. Defaults to None.\n        \"\"\"\n        if mask is None:\n            self.values = lines\n            self.max_distance = None\n        else:\n            self.values, self.max_distance = self.mask(lines, mask.values)\n\n        self.size = len(lines)\n\n    @property\n    def d_lines(self) -&gt; List[float]:\n        if hasattr(self, \"_d_lines\"):\n            return self._d_lines\n        else:\n            raise ValueError(\"The d_lines property has not been set yet.\")\n\n    @d_lines.setter\n    def d_lines(self, value: List[float]):\n        self._d_lines = value\n\n    @staticmethod\n    def mask(\n        search_lines: List[LineString],\n        river_center_line: LineString,\n        max_river_width: float = MAX_RIVER_WIDTH,\n    ) -&gt; Tuple[List[LineString], float]:\n        \"\"\"\n        Clip the list of lines to the envelope of a certain size surrounding a reference line.\n\n        Args:\n            search_lines (List[LineString]):\n                List of lines to be clipped.\n            river_center_line (LineString):\n                Reference line to which the search lines are clipped.\n            max_river_width: float\n                Maximum distance away from river_profile.\n\n        Returns:\n            Tuple[List[LineString], float]:\n                - List of clipped search lines.\n                - Maximum distance from any point within line to reference line.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; from shapely.geometry import LineString\n            &gt;&gt;&gt; search_lines = [LineString([(0, 0), (1, 1)]), LineString([(2, 2), (3, 3)])]\n            &gt;&gt;&gt; river_center_line = LineString([(0, 0), (2, 2)])\n            &gt;&gt;&gt; search_lines_clipped, max_distance = SearchLines.mask(search_lines, river_center_line)\n            &gt;&gt;&gt; max_distance\n            2.0\n\n            ```\n        \"\"\"\n        num = len(search_lines)\n        profile_buffer = river_center_line.buffer(max_river_width, cap_style=2)\n\n        # The algorithm uses simplified geometries for determining the distance between lines for speed.\n        # Stay accurate to within about 1 m\n        profile_simplified = river_center_line.simplify(1)\n\n        max_distance = 0\n        for ind in range(num):\n            # Clip the bank search lines to the reach of interest (indicated by the reference line).\n            search_lines[ind] = search_lines[ind].intersection(profile_buffer)\n\n            # If the bank search line breaks into multiple parts, select the part closest to the reference line.\n            if search_lines[ind].geom_type == \"MultiLineString\":\n                search_lines[ind] = SearchLines._select_closest_part(\n                    search_lines[ind], profile_simplified, max_river_width\n                )\n\n            # Determine the maximum distance from a point on this line to the reference line.\n            line_simplified = search_lines[ind].simplify(1)\n            max_distance = max(\n                [Point(c).distance(profile_simplified) for c in line_simplified.coords]\n            )\n\n            # Increase the value of max_distance by 2 to account for error introduced by using simplified lines.\n            max_distance = max(max_distance, max_distance + 2)\n\n        return search_lines, max_distance\n\n    @staticmethod\n    def _select_closest_part(\n        search_lines_segments: MultiLineString,\n        reference_line: LineString,\n        max_river_width: float,\n    ) -&gt; LineString:\n        \"\"\"Select the closest part of a MultiLineString to the reference line.\n\n        Args:\n            search_lines_segments (MultiLineString):\n                The MultiLineString containing multiple line segments to evaluate.\n            reference_line (LineString):\n                The reference line to calculate distances.\n            max_river_width (float):\n                Maximum allowable distance.\n\n        Returns:\n            LineString: The closest part of the MultiLineString.\n        \"\"\"\n        closest_part = search_lines_segments.geoms[0]\n        min_distance = max_river_width\n\n        for part in search_lines_segments.geoms:\n            simplified_part = part.simplify(1)\n            distance = simplified_part.distance(reference_line)\n            if distance &lt; min_distance:\n                min_distance = distance\n                closest_part = part\n\n        return closest_part\n\n    def to_polygons(self) -&gt; List[Polygon]:\n        \"\"\"\n        Construct a series of polygons surrounding the bank search lines.\n\n        Returns:\n            bank_areas:\n                Array containing the areas of interest surrounding the bank search lines.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; search_lines = [LineString([(0, 0), (1, 1)]), LineString([(2, 2), (3, 3)])]\n            &gt;&gt;&gt; search_lines_clipped = SearchLines(search_lines)\n            &gt;&gt;&gt; search_lines_clipped.d_lines = [10, 20]\n            &gt;&gt;&gt; bank_areas = search_lines_clipped.to_polygons()\n            &gt;&gt;&gt; len(bank_areas)\n            2\n\n            ```\n        \"\"\"\n        bank_areas = [\n            self.values[b].buffer(distance, cap_style=2)\n            for b, distance in enumerate(self.d_lines)\n        ]\n        return bank_areas\n</code></pre>"},{"location":"api/bank_lines/data_models.html#dfastbe.bank_lines.data_models.SearchLines.__init__","title":"<code>__init__(lines: List[LineString], mask: LineGeometry = None)</code>","text":"<p>Search lines initialization.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>List[LineString]</code> <p>List of search lines.</p> required <code>mask</code> <code>LineGeometry</code> <p>Center line for masking the search lines. Defaults to None.</p> <code>None</code> Source code in <code>src/dfastbe/bank_lines/data_models.py</code> <pre><code>def __init__(self, lines: List[LineString], mask: LineGeometry = None):\n    \"\"\"Search lines initialization.\n\n    Args:\n        lines (List[LineString]):\n            List of search lines.\n        mask (LineGeometry, optional):\n            Center line for masking the search lines. Defaults to None.\n    \"\"\"\n    if mask is None:\n        self.values = lines\n        self.max_distance = None\n    else:\n        self.values, self.max_distance = self.mask(lines, mask.values)\n\n    self.size = len(lines)\n</code></pre>"},{"location":"api/bank_lines/data_models.html#dfastbe.bank_lines.data_models.SearchLines.mask","title":"<code>mask(search_lines: List[LineString], river_center_line: LineString, max_river_width: float = MAX_RIVER_WIDTH) -&gt; Tuple[List[LineString], float]</code>  <code>staticmethod</code>","text":"<p>Clip the list of lines to the envelope of a certain size surrounding a reference line.</p> <p>Parameters:</p> Name Type Description Default <code>search_lines</code> <code>List[LineString]</code> <p>List of lines to be clipped.</p> required <code>river_center_line</code> <code>LineString</code> <p>Reference line to which the search lines are clipped.</p> required <code>max_river_width</code> <code>float</code> <p>float Maximum distance away from river_profile.</p> <code>MAX_RIVER_WIDTH</code> <p>Returns:</p> Type Description <code>Tuple[List[LineString], float]</code> <p>Tuple[List[LineString], float]: - List of clipped search lines. - Maximum distance from any point within line to reference line.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shapely.geometry import LineString\n&gt;&gt;&gt; search_lines = [LineString([(0, 0), (1, 1)]), LineString([(2, 2), (3, 3)])]\n&gt;&gt;&gt; river_center_line = LineString([(0, 0), (2, 2)])\n&gt;&gt;&gt; search_lines_clipped, max_distance = SearchLines.mask(search_lines, river_center_line)\n&gt;&gt;&gt; max_distance\n2.0\n</code></pre> Source code in <code>src/dfastbe/bank_lines/data_models.py</code> <pre><code>@staticmethod\ndef mask(\n    search_lines: List[LineString],\n    river_center_line: LineString,\n    max_river_width: float = MAX_RIVER_WIDTH,\n) -&gt; Tuple[List[LineString], float]:\n    \"\"\"\n    Clip the list of lines to the envelope of a certain size surrounding a reference line.\n\n    Args:\n        search_lines (List[LineString]):\n            List of lines to be clipped.\n        river_center_line (LineString):\n            Reference line to which the search lines are clipped.\n        max_river_width: float\n            Maximum distance away from river_profile.\n\n    Returns:\n        Tuple[List[LineString], float]:\n            - List of clipped search lines.\n            - Maximum distance from any point within line to reference line.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from shapely.geometry import LineString\n        &gt;&gt;&gt; search_lines = [LineString([(0, 0), (1, 1)]), LineString([(2, 2), (3, 3)])]\n        &gt;&gt;&gt; river_center_line = LineString([(0, 0), (2, 2)])\n        &gt;&gt;&gt; search_lines_clipped, max_distance = SearchLines.mask(search_lines, river_center_line)\n        &gt;&gt;&gt; max_distance\n        2.0\n\n        ```\n    \"\"\"\n    num = len(search_lines)\n    profile_buffer = river_center_line.buffer(max_river_width, cap_style=2)\n\n    # The algorithm uses simplified geometries for determining the distance between lines for speed.\n    # Stay accurate to within about 1 m\n    profile_simplified = river_center_line.simplify(1)\n\n    max_distance = 0\n    for ind in range(num):\n        # Clip the bank search lines to the reach of interest (indicated by the reference line).\n        search_lines[ind] = search_lines[ind].intersection(profile_buffer)\n\n        # If the bank search line breaks into multiple parts, select the part closest to the reference line.\n        if search_lines[ind].geom_type == \"MultiLineString\":\n            search_lines[ind] = SearchLines._select_closest_part(\n                search_lines[ind], profile_simplified, max_river_width\n            )\n\n        # Determine the maximum distance from a point on this line to the reference line.\n        line_simplified = search_lines[ind].simplify(1)\n        max_distance = max(\n            [Point(c).distance(profile_simplified) for c in line_simplified.coords]\n        )\n\n        # Increase the value of max_distance by 2 to account for error introduced by using simplified lines.\n        max_distance = max(max_distance, max_distance + 2)\n\n    return search_lines, max_distance\n</code></pre>"},{"location":"api/bank_lines/data_models.html#dfastbe.bank_lines.data_models.SearchLines.to_polygons","title":"<code>to_polygons() -&gt; List[Polygon]</code>","text":"<p>Construct a series of polygons surrounding the bank search lines.</p> <p>Returns:</p> Name Type Description <code>bank_areas</code> <code>List[Polygon]</code> <p>Array containing the areas of interest surrounding the bank search lines.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; search_lines = [LineString([(0, 0), (1, 1)]), LineString([(2, 2), (3, 3)])]\n&gt;&gt;&gt; search_lines_clipped = SearchLines(search_lines)\n&gt;&gt;&gt; search_lines_clipped.d_lines = [10, 20]\n&gt;&gt;&gt; bank_areas = search_lines_clipped.to_polygons()\n&gt;&gt;&gt; len(bank_areas)\n2\n</code></pre> Source code in <code>src/dfastbe/bank_lines/data_models.py</code> <pre><code>def to_polygons(self) -&gt; List[Polygon]:\n    \"\"\"\n    Construct a series of polygons surrounding the bank search lines.\n\n    Returns:\n        bank_areas:\n            Array containing the areas of interest surrounding the bank search lines.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; search_lines = [LineString([(0, 0), (1, 1)]), LineString([(2, 2), (3, 3)])]\n        &gt;&gt;&gt; search_lines_clipped = SearchLines(search_lines)\n        &gt;&gt;&gt; search_lines_clipped.d_lines = [10, 20]\n        &gt;&gt;&gt; bank_areas = search_lines_clipped.to_polygons()\n        &gt;&gt;&gt; len(bank_areas)\n        2\n\n        ```\n    \"\"\"\n    bank_areas = [\n        self.values[b].buffer(distance, cap_style=2)\n        for b, distance in enumerate(self.d_lines)\n    ]\n    return bank_areas\n</code></pre>"},{"location":"api/bank_lines/data_models.html#usage-example","title":"Usage Example","text":"<pre><code>from dfastbe.bank_lines.data_models import BankLinesRiverData\nfrom dfastbe.io.config import ConfigFile\n\n# Load configuration file\nconfig_file = ConfigFile.read(\"config.cfg\")\n\n# Create river data object\nriver_data = BankLinesRiverData(config_file)\n\n# Access river data properties\nprint(f\"River name: {river_data.name}\")\nprint(f\"River length: {river_data.length} km\")\n</code></pre> <p>For more details on the specific classes and their properties, refer to the API reference below.</p>"},{"location":"architecture-design/class-diagram.html","title":"Class Diagram for Existing D-FAST Bank Erosion Code","text":""},{"location":"architecture-design/class-diagram.html#overview","title":"Overview","text":"<p>This document provides a class diagram and detailed description of the current architecture of the D-FAST Bank Erosion software. The diagram illustrates the relationships between classes, key methods, and data flow across all modules.</p>"},{"location":"architecture-design/class-diagram.html#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\n    %% Main Classes\n\n    %% Generic Base Class\n    class BaseBank~T~ {\n        +T left\n        +T right\n        +get_bank(int)\n        +from_column_arrays(Dict, Type, Tuple)\n    }\n    class Erosion {\n        -ErosionCalculator erosion_calculator\n        +__init__(ConfigFile, bool)\n        +run()\n    }\n\n    class ErosionCalculator {\n    }\n\n    class BankLines {\n        -ConfigFile config_file\n        +__init__(ConfigFile, bool)\n        +detect()\n        +mask(GeoSeries, Polygon)\n        +plot()\n        +save()\n        +detect_bank_lines()\n    }\n\n    class ConfigFile {\n    }\n\n    %% Data Models - Bank Erosion\n    class ErosionRiverData {\n    }\n\n    class ErosionSimulationData {\n    }\n\n    class BankData {\n    }\n\n    class SingleBank {\n    }\n\n    class FairwayData {\n    }\n\n    class ErosionInputs {\n    }\n\n    class SingleErosion {\n    }\n\n    class ErosionResults {\n    }\n\n    class WaterLevelData {\n        +List water_levels\n        +array hfw_max\n    }\n\n    class MeshData {\n    }\n\n    class DischargeLevels {\n    }\n\n    class SingleDischargeLevel {\n    }\n\n    class SingleCalculation {\n    }\n\n    class SingleLevelParameters {\n        +List banks\n    }\n\n    class SingleParameters {\n    }\n\n    %% Data Models - Bank Lines\n    class BankLinesRiverData {\n    }\n\n    class SearchLines {\n    }\n\n    %% Data Models - IO\n    class LineGeometry {\n    }\n\n    class BaseSimulationData {\n    }\n\n    class BaseRiverData {\n    }\n\n    %% Relationships\n    Erosion --&gt; ConfigFile : uses\n    Erosion --&gt; ErosionRiverData : uses\n    Erosion --&gt; ErosionSimulationData : uses\n    Erosion --&gt; BankData : uses\n    Erosion --&gt; FairwayData : uses\n    Erosion --&gt; ErosionInputs : uses\n    Erosion --&gt; ErosionResults : uses\n    Erosion --&gt; DischargeLevels : uses\n    Erosion --&gt; WaterLevelData : uses\n    Erosion --&gt; MeshData : uses\n    Erosion --&gt; SingleCalculation : uses\n    Erosion --&gt; SingleLevelParameters : uses\n    Erosion --&gt; SingleDischargeLevel : uses\n    Erosion --&gt; SingleParameters : uses\n    Erosion --&gt; SingleErosion : uses\n    Erosion --&gt; Debugger : uses\n    Erosion --&gt; BankLinesProcessor : uses\n    Erosion --&gt; LineGeometry : uses\n    Erosion --&gt; ErosionCalculator : uses\n\n    BankLines --&gt; ConfigFile : uses\n    BankLines --&gt; BankLinesRiverData : uses\n    BankLines --&gt; SearchLines : uses\n    BankLines --&gt; LineGeometry : uses\n    BankLines --&gt; BaseSimulationData : uses\n\n    SearchLines --&gt; LineGeometry : uses\n\n    ErosionRiverData --|&gt; BaseRiverData : inherits\n    ErosionRiverData --&gt; ConfigFile : uses\n\n    BankLinesRiverData --|&gt; BaseRiverData : inherits\n    BankLinesRiverData --&gt; ConfigFile : uses\n    BankLinesRiverData --&gt; SearchLines : uses\n    BankLinesRiverData --&gt; BaseSimulationData : uses\n\n    ErosionSimulationData --|&gt; BaseSimulationData : inherits\n    ErosionSimulationData --&gt; MeshData : uses\n    ErosionSimulationData --&gt; SingleBank : uses\n\n    %% Inheritance relationships\n    BankData --|&gt; BaseBank : inherits\n    BankData --|&gt; BaseBank : inherits\n    ErosionInputs --|&gt; BaseBank : inherits\n    SingleDischargeLevel --|&gt; BaseBank : inherits\n    SingleLevelParameters --|&gt; BaseBank : inherits\n\n    %% Containment relationships\n    BankData --&gt; SingleBank : contains\n    ErosionInputs --&gt; SingleErosion : contains\n    SingleDischargeLevel --&gt; SingleCalculation : contains\n    SingleLevelParameters --&gt; SingleParameters : contains\n    DischargeLevels --&gt; SingleDischargeLevel : contains\n\n    BaseRiverData --&gt; ConfigFile : uses\n    BaseRiverData --&gt; LineGeometry : uses</code></pre> <p>for detailed class diagram Detailed class diagram</p>"},{"location":"architecture-design/class-diagram.html#class-descriptions","title":"Class Descriptions","text":""},{"location":"architecture-design/class-diagram.html#main-classes","title":"Main Classes","text":""},{"location":"architecture-design/class-diagram.html#erosion","title":"Erosion","text":"<ul> <li>Responsibility: Handles the calculation of bank erosion based on hydrodynamic data and detected bank lines</li> <li>Key Methods:</li> <li><code>run()</code>: Executes the complete erosion analysis workflow</li> <li><code>compute_erosion_per_level()</code>: Computes erosion for a specific discharge level</li> <li><code>calculate_fairway_bank_line_distance()</code>: Calculates the distance between bank lines and fairway</li> <li>Dependencies: ConfigFile, ErosionRiverData, BankData, FairwayData, ErosionInputs, ErosionResults, DischargeLevels, WaterLevelData, MeshData</li> </ul>"},{"location":"architecture-design/class-diagram.html#banklines","title":"BankLines","text":"<ul> <li>Responsibility: Handles the detection of bank lines from hydrodynamic simulation results</li> <li>Key Methods:</li> <li><code>detect()</code>: Executes the bank line detection workflow</li> <li><code>detect_bank_lines()</code>: Detects bank lines from simulation data</li> <li><code>mask()</code>: Masks bank lines with bank areas</li> <li><code>save()</code>: Saves bank lines to output files</li> <li>Dependencies: ConfigFile, BankLinesRiverData, SearchLines</li> </ul>"},{"location":"architecture-design/class-diagram.html#configfile","title":"ConfigFile","text":"<ul> <li>Responsibility: Handles configuration file parsing and management</li> <li>Key Methods:</li> <li><code>read()</code>: Reads a configuration file</li> <li><code>write()</code>: Writes a configuration file</li> <li><code>get_parameter()</code>: Gets a parameter from the configuration</li> <li><code>get_river_center_line()</code>: Gets the river center line from the configuration</li> <li>Dependencies: None</li> </ul>"},{"location":"architecture-design/class-diagram.html#data-models-bank-erosion","title":"Data Models - Bank Erosion","text":""},{"location":"architecture-design/class-diagram.html#basebank","title":"BaseBank","text":"<ul> <li>Responsibility: Generic base class for representing paired bank data (left and right banks)</li> <li>Key Properties:</li> <li><code>left</code>: Left bank data (generic type)</li> <li><code>right</code>: Right bank data (generic type)</li> <li><code>id</code>: Optional identifier</li> <li>Key Methods:</li> <li><code>get_bank()</code>: Gets bank data for a specific bank index (0 for left, 1 for right)</li> <li><code>from_column_arrays()</code>: Creates a BaseBank instance from column arrays</li> <li><code>__iter__()</code>: Allows iteration over banks</li> <li>Dependencies: None</li> </ul>"},{"location":"architecture-design/class-diagram.html#erosionriverdata","title":"ErosionRiverData","text":"<ul> <li>Responsibility: Represents river data for erosion calculations</li> <li>Key Methods:</li> <li><code>simulation_data()</code>: Gets simulation data for erosion calculations</li> <li>Dependencies: BaseRiverData, ConfigFile</li> </ul>"},{"location":"architecture-design/class-diagram.html#erosionsimulationdata","title":"ErosionSimulationData","text":"<ul> <li>Responsibility: Represents simulation data for erosion calculations</li> <li>Key Methods:</li> <li><code>compute_mesh_topology()</code>: Computes mesh topology</li> <li><code>calculate_bank_velocity()</code>: Calculates velocity at bank</li> <li><code>calculate_bank_height()</code>: Calculates height at bank</li> <li>Dependencies: BaseSimulationData, SingleBank</li> </ul>"},{"location":"architecture-design/class-diagram.html#bankdata","title":"BankData","text":"<ul> <li>Responsibility: Represents bank data for erosion calculations</li> <li>Key Properties:</li> <li><code>left</code>: Left bank (SingleBank)</li> <li><code>right</code>: Right bank (SingleBank)</li> <li><code>id</code>: Optional identifier</li> <li>Inheritance: Inherits from BaseBank[SingleBank]</li> <li>Dependencies: BaseBank, SingleBank</li> </ul>"},{"location":"architecture-design/class-diagram.html#singlebank","title":"SingleBank","text":"<ul> <li>Responsibility: Represents a single bank for erosion calculations</li> <li>Key Properties:</li> <li><code>bank_line</code>: Bank line geometry</li> <li><code>face_indices</code>: Indices of faces adjacent to the bank</li> <li><code>chainage</code>: Chainage along the bank</li> <li><code>is_right</code>: Whether the bank is a right bank</li> <li>Dependencies: None</li> </ul>"},{"location":"architecture-design/class-diagram.html#fairwaydata","title":"FairwayData","text":"<ul> <li>Responsibility: Represents fairway data for erosion calculations</li> <li>Key Properties:</li> <li><code>fairway_axis</code>: Fairway axis geometry</li> <li><code>fairway_polygon</code>: Fairway polygon geometry</li> <li><code>fairway_initial_water_levels</code>: Initial water levels in the fairway</li> <li><code>fairway_velocities</code>: Velocities in the fairway</li> <li><code>fairway_chezy_coefficients</code>: Chezy coefficients in the fairway</li> <li>Dependencies: None</li> </ul>"},{"location":"architecture-design/class-diagram.html#erosioninputs","title":"ErosionInputs","text":"<ul> <li>Responsibility: Represents inputs for erosion calculations</li> <li>Key Properties:</li> <li><code>left</code>: Left bank erosion inputs (SingleErosion)</li> <li><code>right</code>: Right bank erosion inputs (SingleErosion)</li> <li><code>id</code>: Optional identifier</li> <li><code>shipping_data</code>: Shipping data for erosion calculations</li> <li>Inheritance: Inherits from BaseBank[SingleErosion]</li> <li>Dependencies: BaseBank, SingleErosion</li> </ul>"},{"location":"architecture-design/class-diagram.html#singleerosion","title":"SingleErosion","text":"<ul> <li>Responsibility: Represents erosion inputs for a single bank</li> <li>Key Properties:</li> <li><code>wave_fairway_distance_0</code>: Distance from fairway for wave calculations</li> <li><code>wave_fairway_distance_1</code>: Distance from fairway for wave calculations</li> <li><code>bank_protection_level</code>: Bank protection level</li> <li><code>tauc</code>: Critical shear stress</li> <li><code>bank_type</code>: Bank type</li> <li>Dependencies: None</li> </ul>"},{"location":"architecture-design/class-diagram.html#erosionresults","title":"ErosionResults","text":"<ul> <li>Responsibility: Represents results of erosion calculations</li> <li>Key Properties:</li> <li>Various lists and arrays storing erosion-related data</li> <li>Dependencies: None</li> </ul>"},{"location":"architecture-design/class-diagram.html#debugger","title":"Debugger","text":"<ul> <li>Responsibility: Handles debugging and output of bank erosion calculations</li> <li>Key Methods:</li> <li><code>last_discharge_level()</code>: Writes the last discharge level to a shapefile and CSV file</li> <li><code>middle_levels()</code>: Writes the middle levels to a shapefile and CSV file</li> <li><code>_write_data()</code>: Writes data to a shapefile and CSV file</li> <li>Dependencies: None</li> </ul>"},{"location":"architecture-design/class-diagram.html#banklinesprocessor","title":"BankLinesProcessor","text":"<ul> <li>Responsibility: Processes bank lines and intersects them with a mesh</li> <li>Key Methods:</li> <li><code>intersect_with_mesh()</code>: Intersects bank lines with a mesh and returns bank data</li> <li>Dependencies: ErosionRiverData, LineGeometry</li> </ul>"},{"location":"architecture-design/class-diagram.html#erosioncalculator","title":"ErosionCalculator","text":"<ul> <li>Responsibility: Performs erosion calculations for bank erosion</li> <li>Key Methods:</li> <li><code>comp_erosion_eq()</code>: Computes the equilibrium bank erosion distance and volume</li> <li><code>compute_bank_erosion_dynamics()</code>: Computes the bank erosion during a specific discharge level</li> <li><code>comp_hw_ship_at_bank()</code>: Computes wave heights at bank due to passing ships</li> <li>Dependencies: None</li> </ul>"},{"location":"architecture-design/class-diagram.html#waterleveldata","title":"WaterLevelData","text":"<ul> <li>Responsibility: Represents water level data for erosion calculations</li> <li>Key Properties:</li> <li><code>water_levels</code>: List of water levels</li> <li><code>hfw_max</code>: Maximum water level</li> <li>Dependencies: None</li> </ul>"},{"location":"architecture-design/class-diagram.html#meshdata","title":"MeshData","text":"<ul> <li>Responsibility: Represents mesh data for erosion calculations</li> <li>Key Properties:</li> <li>Various arrays storing mesh-related data</li> <li>Dependencies: None</li> </ul>"},{"location":"architecture-design/class-diagram.html#dischargelevels","title":"DischargeLevels","text":"<ul> <li>Responsibility: Represents discharge levels for erosion calculations</li> <li>Key Properties:</li> <li><code>levels</code>: List of SingleDischargeLevel objects</li> <li>Dependencies: SingleDischargeLevel</li> </ul>"},{"location":"architecture-design/class-diagram.html#singledischargelevel","title":"SingleDischargeLevel","text":"<ul> <li>Responsibility: Represents a calculation level for erosion calculations</li> <li>Key Properties:</li> <li><code>left</code>: Left bank calculation parameters (SingleCalculation)</li> <li><code>right</code>: Right bank calculation parameters (SingleCalculation)</li> <li><code>id</code>: Optional identifier</li> <li>Inheritance: Inherits from BaseBank[SingleCalculation]</li> <li>Dependencies: BaseBank, SingleCalculation</li> </ul>"},{"location":"architecture-design/class-diagram.html#singlecalculation","title":"SingleCalculation","text":"<ul> <li>Responsibility: Represents parameters for discharge calculations</li> <li>Key Properties:</li> <li>Various arrays storing discharge-related data</li> <li>Dependencies: None</li> </ul>"},{"location":"architecture-design/class-diagram.html#singlelevelparameters","title":"SingleLevelParameters","text":"<ul> <li>Responsibility: Represents parameters for discharge levels</li> <li>Key Properties:</li> <li><code>left</code>: Left bank parameters (SingleParameters)</li> <li><code>right</code>: Right bank parameters (SingleParameters)</li> <li><code>id</code>: Optional identifier</li> <li>Inheritance: Inherits from BaseBank[SingleParameters]</li> <li>Dependencies: BaseBank, SingleParameters</li> </ul>"},{"location":"architecture-design/class-diagram.html#singleparameters","title":"SingleParameters","text":"<ul> <li>Responsibility: Represents parameters for each bank</li> <li>Key Properties:</li> <li><code>discharge</code>: Discharge value</li> <li><code>probability</code>: Probability of discharge</li> <li><code>ship_parameters</code>: Ship parameters</li> <li>Dependencies: None</li> </ul>"},{"location":"architecture-design/class-diagram.html#data-models-bank-lines","title":"Data Models - Bank Lines","text":""},{"location":"architecture-design/class-diagram.html#banklinesriverdata","title":"BankLinesRiverData","text":"<ul> <li>Responsibility: Represents river data for bank line detection</li> <li>Key Methods:</li> <li><code>search_lines()</code>: Gets search lines for bank line detection</li> <li><code>simulation_data()</code>: Gets simulation data for bank line detection</li> <li>Dependencies: BaseRiverData, ConfigFile, SearchLines</li> </ul>"},{"location":"architecture-design/class-diagram.html#searchlines","title":"SearchLines","text":"<ul> <li>Responsibility: Represents search lines for bank line detection</li> <li>Key Methods:</li> <li><code>mask()</code>: Masks search lines with river center line</li> <li><code>to_polygons()</code>: Converts search lines to polygons</li> <li>Dependencies: LineGeometry</li> </ul>"},{"location":"architecture-design/class-diagram.html#data-models-io","title":"Data Models - IO","text":""},{"location":"architecture-design/class-diagram.html#linegeometry","title":"LineGeometry","text":"<ul> <li>Responsibility: Represents line geometry</li> <li>Key Methods:</li> <li><code>mask()</code>: Masks line geometry</li> <li><code>intersect_with_line()</code>: Intersects line geometry with another line</li> <li>Dependencies: None</li> </ul>"},{"location":"architecture-design/class-diagram.html#basesimulationdata","title":"BaseSimulationData","text":"<ul> <li>Responsibility: Base class for simulation data</li> <li>Key Methods:</li> <li><code>read()</code>: Reads simulation data from a file</li> <li><code>clip()</code>: Clips simulation data to a region</li> <li>Dependencies: None</li> </ul>"},{"location":"architecture-design/class-diagram.html#baseriverdata","title":"BaseRiverData","text":"<ul> <li>Responsibility: Base class for river data</li> <li>Key Methods:</li> <li><code>get_erosion_sim_data()</code>: Gets simulation data for erosion calculations</li> <li>Dependencies: ConfigFile, LineGeometry</li> </ul>"},{"location":"architecture-design/class-diagram.html#data-flow","title":"Data Flow","text":"<ol> <li>The user initializes the <code>Erosion</code> or <code>BankLines</code> class with a <code>ConfigFile</code></li> <li>The <code>ConfigFile</code> is used to read configuration parameters</li> <li>For bank line detection:</li> <li><code>BankLines</code> uses <code>BankLinesRiverData</code> to get river data</li> <li><code>BankLinesRiverData</code> uses <code>SearchLines</code> to get search lines</li> <li><code>BankLines</code> detects bank lines and saves them to output files</li> <li>For erosion calculation:</li> <li><code>Erosion</code> uses <code>ErosionRiverData</code> to get river data</li> <li><code>Erosion</code> processes the river axis and gets fairway data</li> <li><code>Erosion</code> prepares initial conditions and processes discharge levels</li> <li><code>Erosion</code> computes erosion per level and post-processes results</li> <li><code>Erosion</code> writes output files and generates plots</li> </ol> <p>This architecture provides a clear separation of concerns, with each class having a specific responsibility. The data flows through the system in a logical manner, with each step building on the previous one.</p>"},{"location":"architecture-design/detailed-class-diagram.html","title":"Detailed class diagram","text":"<pre><code>classDiagram\n    %% Main Classes\n\n    %% Generic Base Class\n    class BaseBank~T~ {\n        +T left\n        +T right\n        +Optional[int] id\n        +get_bank(int)\n        +from_column_arrays(Dict, Type, Tuple)\n        +__iter__()\n    }\n    class Erosion {\n        -ConfigFile config_file\n        -bool gui\n        -Path bank_dir\n        -Path output_dir\n        -bool debug\n        -dict plot_flags\n        -ErosionCalculator erosion_calculator\n        +__init__(ConfigFile, bool)\n        +run()\n        -_process_river_axis_by_center_line()\n        -_get_fairway_data(LineGeometry, MeshData)\n        +calculate_fairway_bank_line_distance(BankData, FairwayData, ErosionSimulationData)\n        -_prepare_initial_conditions(ConfigFile, List, FairwayData)\n        -_process_discharge_levels(array, tuple, ConfigFile, ErosionInputs, BankData, FairwayData)\n        -_postprocess_erosion_results(tuple, array, BankData, ErosionResults)\n        +compute_erosion_per_level(int, BankData, ErosionSimulationData, FairwayData, SingleLevelParameters, ErosionInputs, tuple, int, array)\n        -_write_bankline_shapefiles(list, list, ConfigFile)\n        -_write_volume_outputs(ErosionResults, array)\n        -_generate_plots(array, ErosionSimulationData, list, array, float, ErosionInputs, WaterLevelData, MeshData, BankData, ErosionResults)\n    }\n\n    class ErosionCalculator {\n        +comp_erosion_eq(array, array, array, SingleParameters, array, array, SingleErosion)\n        +compute_bank_erosion_dynamics(SingleCalculation, array, array, array, array, SingleParameters, float, array, SingleErosion)\n        +comp_hw_ship_at_bank(array, array, array, array, array, array, array)\n    }\n\n    class BankLines {\n        -ConfigFile config_file\n        -bool gui\n        -Path output_dir\n        -bool debug\n        -dict plot_flags\n        -float max_river_width\n        +__init__(ConfigFile, bool)\n        +detect()\n        +mask(GeoSeries, Polygon)\n        +plot(array, int, List, Tuple, List, ConfigFile)\n        +save(List, GeoSeries, List, List, ConfigFile)\n        +detect_bank_lines(BaseSimulationData, float, ConfigFile)\n        -_calculate_water_depth(BaseSimulationData)\n        -_generate_bank_lines(BaseSimulationData, array, array, array, float)\n        -_progress_bar(int, int)\n    }\n\n    class ConfigFile {\n        -ConfigParser config\n        -str path\n        +__init__(ConfigParser, Path)\n        +read(Path)\n        +write(str)\n        +make_paths_absolute()\n        +get_str(str, str, str)\n        +get_bool(str, str, bool)\n        +get_float(str, str, float, bool)\n        +get_int(str, str, int, bool)\n        +get_sim_file(str, str)\n        +get_start_end_stations()\n        +get_search_lines()\n        +read_bank_lines(str)\n        +get_parameter(str, str, List, Any, str, bool, List, bool)\n        +get_bank_search_distances(int)\n        +get_range(str, str)\n        +get_river_center_line()\n        +resolve(str)\n        +relative_to(str)\n        +get_plotting_flags(Path)\n        +get_output_dir(str)\n    }\n\n    %% Data Models - Bank Erosion\n    class ErosionRiverData {\n        -ConfigFile config_file\n        -LineString river_center_line\n        -Tuple station_bounds\n        +__init__(ConfigFile)\n        +simulation_data()\n        -_get_bank_output_dir()\n        -_get_bank_line_dir()\n        -_read_river_axis()\n    }\n\n    class ErosionSimulationData {\n        +compute_mesh_topology()\n        +apply_masked_indexing(array, array)\n        +calculate_bank_velocity(SingleBank, array)\n        +calculate_bank_height(SingleBank, array)\n    }\n\n    class BankData {\n        +List banks\n        +from_column_arrays(dict, Type, GeoDataFrame, int, Tuple)\n        +bank_line_coords()\n        +is_right_bank()\n        +bank_chainage_midpoints()\n        +num_stations_per_bank()\n    }\n\n    class SingleBank {\n        +LineString bank_line\n        +array face_indices\n        +array chainage\n        +bool is_right\n        +__post_init__()\n        -_segment_length()\n        -_dx()\n        -_dy()\n        +get_mid_points(bool, str)\n    }\n\n    class FairwayData {\n        +LineString fairway_axis\n        +Polygon fairway_polygon\n        +array fairway_initial_water_levels\n        +array fairway_velocities\n        +array fairway_chezy_coefficients\n    }\n\n    class ErosionInputs {\n        +List banks\n        +dict shipping_data\n        +from_column_arrays(dict, Type, Dict, array, Tuple)\n        +bank_protection_level()\n        +tauc()\n    }\n\n    class SingleErosion {\n        +array wave_fairway_distance_0\n        +array wave_fairway_distance_1\n        +array bank_protection_level\n        +array tauc\n        +array bank_type\n    }\n\n    class ErosionResults {\n        +int erosion_time\n        +List velocity\n        +List bank_height\n        +List water_level\n        +List chezy\n        +List vol_per_discharge\n        +List ship_wave_max\n        +List ship_wave_min\n        +List line_size\n        +List flow_erosion_dist\n        +List ship_erosion_dist\n        +List total_erosion_dist\n        +List total_eroded_vol\n        +List eq_erosion_dist\n        +List eq_eroded_vol\n        +array avg_erosion_rate\n        +array eq_eroded_vol_per_km\n        +array total_eroded_vol_per_km\n    }\n\n    class WaterLevelData {\n        +List water_levels\n        +array hfw_max\n    }\n\n    class MeshData {\n        +array x_node\n        +array y_node\n        +array n_nodes\n        +array face_node\n        +array face_x\n        +array face_y\n        +array face_area\n        +array face_nodes_count\n        +array face_nodes_indices\n    }\n\n    class DischargeLevels {\n        +List levels\n        +__init__(List)\n        +__getitem__(int)\n        +__len__()\n        +append(SingleDischargeLevel)\n        +get_max_hfw_level()\n        +total_erosion_volume()\n        +__iter__()\n        +accumulate(str, str)\n        -_accumulate_attribute_side(str, str)\n        -_get_attr_both_sides_level(str, object)\n        +get_attr_level(str)\n        +get_water_level_data(array)\n    }\n\n    class SingleDischargeLevel {\n        +List banks\n        +from_column_arrays(dict, Type, float, Tuple)\n    }\n\n    class SingleCalculation {\n        +array water_level\n        +array velocity\n        +array chezy\n        +array flow_erosion_dist\n        +array ship_erosion_dist\n        +array total_erosion_dist\n        +array total_eroded_vol\n        +array eq_erosion_dist\n        +array eq_eroded_vol\n    }\n\n    class SingleLevelParameters {\n        +List banks\n    }\n\n    class SingleParameters {\n        +float discharge\n        +float probability\n        +dict ship_parameters\n    }\n\n    %% Data Models - Bank Lines\n    class BankLinesRiverData {\n        -ConfigFile config_file\n        -LineString river_center_line\n        -Tuple station_bounds\n        +search_lines()\n        -_get_bank_lines_simulation_data()\n        +simulation_data()\n    }\n\n    class SearchLines {\n        +List lines\n        +LineGeometry mask\n        +__init__(List, LineGeometry)\n        +mask(List, LineString, float)\n        -_select_closest_part(MultiLineString, LineString, float)\n        +to_polygons()\n    }\n\n    %% Data Models - IO\n    class LineGeometry {\n        +LineString line\n        +dict data\n        +__init__(LineString, Tuple, str)\n        +as_array()\n        +add_data(Dict)\n        +to_file(str, Dict)\n        +mask(LineString, Tuple)\n        -_find_mask_index(float, array)\n        -_handle_bound(int, float, bool, array)\n        -_interpolate_point(int, float, array)\n        +intersect_with_line(array)\n    }\n\n    class BaseSimulationData {\n        +array x_node\n        +array y_node\n        +array n_nodes\n        +array face_node\n        +array bed_elevation_location\n        +array bed_elevation_values\n        +array water_level_face\n        +array water_depth_face\n        +array velocity_x_face\n        +array velocity_y_face\n        +array chezy_face\n        +float dry_wet_threshold\n        +__init__(array, array, array, array, array, array, array, array, array, array, array, float)\n        +read(str, str)\n        +clip(LineString, float)\n    }\n\n    class BaseRiverData {\n        -ConfigFile config_file\n        -LineString river_center_line\n        -Tuple station_bounds\n        +__init__(ConfigFile)\n        +get_bbox(array, float)\n        +get_erosion_sim_data(int)\n    }\n\n    %% Relationships\n    Erosion --&gt; ConfigFile : uses\n    Erosion --&gt; ErosionRiverData : uses\n    Erosion --&gt; ErosionSimulationData : uses\n    Erosion --&gt; BankData : uses\n    Erosion --&gt; FairwayData : uses\n    Erosion --&gt; ErosionInputs : uses\n    Erosion --&gt; ErosionResults : uses\n    Erosion --&gt; DischargeLevels : uses\n    Erosion --&gt; WaterLevelData : uses\n    Erosion --&gt; MeshData : uses\n    Erosion --&gt; SingleCalculation : uses\n    Erosion --&gt; SingleLevelParameters : uses\n    Erosion --&gt; SingleDischargeLevel : uses\n    Erosion --&gt; SingleParameters : uses\n    Erosion --&gt; SingleErosion : uses\n    Erosion --&gt; Debugger : uses\n    Erosion --&gt; BankLinesProcessor : uses\n    Erosion --&gt; LineGeometry : uses\n    Erosion --&gt; ErosionCalculator : uses\n\n    BankLines --&gt; ConfigFile : uses\n    BankLines --&gt; BankLinesRiverData : uses\n    BankLines --&gt; SearchLines : uses\n    BankLines --&gt; LineGeometry : uses\n    BankLines --&gt; BaseSimulationData : uses\n\n    SearchLines --&gt; LineGeometry : uses\n\n    ErosionRiverData --|&gt; BaseRiverData : inherits\n    ErosionRiverData --&gt; ConfigFile : uses\n\n    BankLinesRiverData --|&gt; BaseRiverData : inherits\n    BankLinesRiverData --&gt; ConfigFile : uses\n    BankLinesRiverData --&gt; SearchLines : uses\n    BankLinesRiverData --&gt; BaseSimulationData : uses\n\n    ErosionSimulationData --|&gt; BaseSimulationData : inherits\n    ErosionSimulationData --&gt; MeshData : uses\n    ErosionSimulationData --&gt; SingleBank : uses\n\n    %% Inheritance relationships\n    BankData --|&gt; BaseBank : inherits\n    BankData --|&gt; BaseBank : inherits\n    ErosionInputs --|&gt; BaseBank : inherits\n    SingleDischargeLevel --|&gt; BaseBank : inherits\n    SingleLevelParameters --|&gt; BaseBank : inherits\n\n    %% Containment relationships\n    BankData --&gt; SingleBank : contains\n    ErosionInputs --&gt; SingleErosion : contains\n    SingleDischargeLevel --&gt; SingleCalculation : contains\n    SingleLevelParameters --&gt; SingleParameters : contains\n    DischargeLevels --&gt; SingleDischargeLevel : contains\n\n    BaseRiverData --&gt; ConfigFile : uses\n    BaseRiverData --&gt; LineGeometry : uses</code></pre>"},{"location":"architecture-design/main-components.html","title":"D-FAST Bank Erosion Architecture and Design","text":"<p>This document provides a comprehensive overview of the D-FAST Bank Erosion software architecture, including its components, their relationships, and data flow.</p>"},{"location":"architecture-design/main-components.html#overview","title":"Overview","text":"<p>D-FAST Bank Erosion is a tool developed by Deltares to compute local bank erosion sensitivity and estimate the amount of bank material that will be eroded. It works in conjunction with D-Flow FM (Flexible Mesh) and requires users to run steady-state hydrodynamic simulations for different discharges.</p> <p>The software has three main operational modes: 1. BANKLINES: Detects bank lines from hydrodynamic simulation results 2. BANKEROSION: Calculates bank erosion based on detected bank lines and hydrodynamic data 3. GUI: Provides a graphical user interface for configuring and running the above processes</p>"},{"location":"architecture-design/main-components.html#repository-structure","title":"Repository Structure","text":"<pre><code>D-FAST_Bank_Erosion/\n\u251c\u2500\u2500\u2500docs                      # Documentation\n\u2502   \u251c\u2500\u2500\u2500end-user-docs         # End-user documentation (LaTeX)\n\u2502   \u2514\u2500\u2500\u2500mkdocs                # MkDocs documentation (Markdown)\n\u2502       \u251c\u2500\u2500\u2500api               # API reference documentation\n\u2502       \u251c\u2500\u2500\u2500architecture-design # Architecture documentation\n\u2502       \u251c\u2500\u2500\u2500gui               # GUI documentation\n\u2502       \u2514\u2500\u2500\u2500guides            # User and developer guides\n\u251c\u2500\u2500\u2500examples                  # Example data and configurations\n\u251c\u2500\u2500\u2500src                       # Source code\n\u2502   \u2514\u2500\u2500\u2500dfastbe               # Main package\n\u2502       \u251c\u2500\u2500\u2500bank_erosion      # Bank erosion calculation modules\n\u2502       \u2502   \u2514\u2500\u2500\u2500data_models   # Data models for bank erosion\n\u2502       \u251c\u2500\u2500\u2500bank_lines        # Bank line detection modules\n\u2502       \u251c\u2500\u2500\u2500gui               # GUI modules and resources\n\u2502       \u2502   \u2514\u2500\u2500\u2500icons         # GUI icons\n\u2502       \u251c\u2500\u2500\u2500io                # Input/output handling modules\n\u2502       \u2502   \u2514\u2500\u2500\u2500log_data      # Logging data and resources\n\u2502       \u251c\u2500\u2500\u2500__main__.py       # Entry point for CLI\n\u2502       \u251c\u2500\u2500\u2500runner.py            # Command processing\n\u2502       \u251c\u2500\u2500\u2500plotting.py       # Plotting utilities\n\u2502       \u2514\u2500\u2500\u2500utils.py          # General utilities\n\u251c\u2500\u2500\u2500tests                     # Test suite\n\u2514\u2500\u2500\u2500pyproject.toml            # Project configuration\n</code></pre>"},{"location":"architecture-design/main-components.html#component-architecture","title":"Component Architecture","text":"<p>The D-FAST Bank Erosion software is organized into several key components, each with specific responsibilities:</p>"},{"location":"architecture-design/main-components.html#core-components","title":"Core Components","text":"<pre><code>graph TD\n    subgraph Presentation_Layer\n        GUI[\"GUI (gui.py)\"]\n        CLI[\"CLI (__main__.py, runner.py)\"]\n    end\n\n    subgraph Domain_Layer\n        BankErosion[\"Bank Erosion (bank_erosion/)\"]\n        BankLines[\"Bank Lines (bank_lines/)\"]\n    end\n\n    subgraph Data_Layer\n        IO[\"I/O (io/)\"]\n        Utils[\"Utilities (utils.py)\"]\n        Plotting[\"Plotting (plotting.py)\"]\n    end\n\n    CLI --&gt; runner\n    GUI --&gt; runner\n\n    runner --&gt; BankErosion\n    runner --&gt; BankLines\n\n    BankErosion --&gt; IO\n    BankErosion --&gt; Utils\n    BankErosion --&gt; Plotting\n\n    BankLines --&gt; IO\n    BankLines --&gt; Utils\n    BankLines --&gt; Plotting\n\n    classDef core fill:#f9f,stroke:#333,stroke-width:2px\n    classDef domain fill:#bbf,stroke:#333,stroke-width:2px\n    classDef data fill:#bfb,stroke:#333,stroke-width:2px\n\n    class GUI,CLI core\n    class BankErosion,BankLines domain\n    class IO,Utils,Plotting data</code></pre> <ol> <li>Presentation Layer</li> <li>GUI: Provides a graphical user interface for configuring and running bank line detection and erosion calculations</li> <li> <p>CLI: Provides a command-line interface for running the software in batch mode</p> </li> <li> <p>Domain Layer</p> </li> <li>Bank Erosion: Handles the calculation of bank erosion based on hydrodynamic data and detected bank lines</li> <li> <p>Bank Lines: Handles the detection of bank lines from hydrodynamic simulation results</p> </li> <li> <p>Data Layer</p> </li> <li>I/O: Handles input/output operations, including reading configuration files and writing results</li> <li>Utilities: Provides general utility functions used across the application</li> <li>Plotting: Handles the generation of plots and visualizations</li> </ol>"},{"location":"architecture-design/main-components.html#module-details","title":"Module Details","text":""},{"location":"architecture-design/main-components.html#bank-erosion-module","title":"Bank Erosion Module","text":"<p>The Bank Erosion module (<code>bank_erosion/</code>) is responsible for calculating bank erosion based on hydrodynamic data and detected bank lines. It includes:</p> <ul> <li>bank_erosion.py: Main class for bank erosion calculations</li> <li>erosion_calculator.py: Encapsulates core erosion calculation algorithms</li> <li>mesh_processor.py: Processes mesh data from hydrodynamic simulations</li> <li>debugger.py: Provides debugging utilities</li> <li>utils.py: Utility functions specific to bank erosion</li> <li>data_models/: Data models for bank erosion inputs, calculations, and results</li> </ul>"},{"location":"architecture-design/main-components.html#bank-lines-module","title":"Bank Lines Module","text":"<p>The Bank Lines module (<code>bank_lines/</code>) is responsible for detecting bank lines from hydrodynamic simulation results. It includes:</p> <ul> <li>bank_lines.py: Main class for bank line detection</li> <li>data_models.py: Data models for bank line detection</li> <li>utils.py: Utility functions specific to bank line detection</li> </ul>"},{"location":"architecture-design/main-components.html#io-module","title":"I/O Module","text":"<p>The I/O module (<code>io/</code>) handles input/output operations, including:</p> <ul> <li>config.py: Handles configuration file parsing and management</li> <li>data_models.py: Data models for I/O operations</li> <li>file_utils.py: Utility functions for file operations</li> <li>logger.py: Handles logging functionality</li> <li>log_data/: Logging data and resources, including language files</li> </ul>"},{"location":"architecture-design/main-components.html#gui-module","title":"GUI Module","text":"<p>The GUI module (<code>gui/</code>) provides a graphical user interface for the application:</p> <ul> <li>gui.py: Main GUI implementation</li> <li>icons/: GUI icons and resources</li> </ul>"},{"location":"architecture-design/main-components.html#data-flow","title":"Data Flow","text":"<p>The following diagram illustrates the data flow through the D-FAST Bank Erosion software:</p> <pre><code>flowchart TD\n    subgraph Input\n        config[\"Configuration File\"]\n        hydro[\"Hydrodynamic Simulation Results\"]\n    end\n\n    subgraph Processing\n        config_parser[\"Configuration Parser\"]\n        banklines_detector[\"Bank Lines Detector\"]\n        erosion_calculator[\"Erosion Calculator\"]\n    end\n\n    subgraph Output\n        banklines_output[\"Bank Lines Output\"]\n        erosion_output[\"Erosion Output\"]\n        plots[\"Plots and Visualizations\"]\n    end\n\n    config --&gt; config_parser\n    hydro --&gt; config_parser\n\n    config_parser --&gt; banklines_detector\n    banklines_detector --&gt; banklines_output\n    banklines_output --&gt; erosion_calculator\n\n    config_parser --&gt; erosion_calculator\n    erosion_calculator --&gt; erosion_output\n    erosion_calculator --&gt; plots\n\n    style Input fill:#f9f9f9,stroke:#333,stroke-width:1px\n    style Processing fill:#e6f3ff,stroke:#333,stroke-width:1px\n    style Output fill:#f0fff0,stroke:#333,stroke-width:1px</code></pre> <ol> <li>Input:</li> <li>Configuration file specifying parameters for bank line detection and erosion calculation</li> <li> <p>Hydrodynamic simulation results from D-Flow FM</p> </li> <li> <p>Processing:</p> </li> <li>Configuration parser reads and validates the configuration file</li> <li>Bank lines detector processes hydrodynamic data to detect bank lines</li> <li> <p>Erosion calculator computes bank erosion based on detected bank lines and hydrodynamic data</p> </li> <li> <p>Output:</p> </li> <li>Bank lines output (shapefiles)</li> <li>Erosion output (shapefiles, CSV files)</li> <li>Plots and visualizations</li> </ol>"},{"location":"architecture-design/main-components.html#process-workflows","title":"Process Workflows","text":""},{"location":"architecture-design/main-components.html#bank-line-detection-workflow","title":"Bank Line Detection Workflow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant CLI/GUI\n    participant Config\n    participant BankLines\n    participant IO\n    participant Plotting\n\n    User-&gt;&gt;CLI/GUI: Run BANKLINES mode\n    CLI/GUI-&gt;&gt;Config: Load configuration\n    Config-&gt;&gt;BankLines: Initialize with config\n    BankLines-&gt;&gt;IO: Load hydrodynamic data\n    BankLines-&gt;&gt;BankLines: Calculate water depth\n    BankLines-&gt;&gt;BankLines: Generate bank lines\n    BankLines-&gt;&gt;BankLines: Mask bank lines\n    BankLines-&gt;&gt;IO: Save bank lines\n    BankLines-&gt;&gt;Plotting: Generate plots\n    Plotting-&gt;&gt;User: Display/save plots</code></pre>"},{"location":"architecture-design/main-components.html#bank-erosion-calculation-workflow","title":"Bank Erosion Calculation Workflow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant CLI/GUI\n    participant Config\n    participant Erosion\n    participant BankLines\n    participant IO\n    participant Plotting\n\n    User-&gt;&gt;CLI/GUI: Run BANKEROSION mode\n    CLI/GUI-&gt;&gt;Config: Load configuration\n    Config-&gt;&gt;Erosion: Initialize with config\n    Erosion-&gt;&gt;IO: Load bank lines\n    Erosion-&gt;&gt;IO: Load hydrodynamic data\n    Erosion-&gt;&gt;Erosion: Process river axis\n    Erosion-&gt;&gt;Erosion: Get fairway data\n    Erosion-&gt;&gt;Erosion: Calculate bank-fairway distance\n    Erosion-&gt;&gt;Erosion: Prepare initial conditions\n    Erosion-&gt;&gt;Erosion: Process discharge levels\n    Erosion-&gt;&gt;Erosion: Compute erosion per level\n    Erosion-&gt;&gt;Erosion: Post-process results\n    Erosion-&gt;&gt;IO: Write output files\n    Erosion-&gt;&gt;Plotting: Generate plots\n    Plotting-&gt;&gt;User: Display/save plots</code></pre>"},{"location":"architecture-design/main-components.html#configuration","title":"Configuration","text":"<p>The D-FAST Bank Erosion software is configured using a configuration file (typically with a .cfg extension). The configuration file specifies:</p> <ul> <li>Input and output directories</li> <li>Hydrodynamic simulation parameters</li> <li>Bank line detection parameters</li> <li>Erosion calculation parameters</li> </ul> <p>The configuration file is parsed by the <code>ConfigFile</code> class in the <code>io.config</code> module.</p>"},{"location":"architecture-design/main-components.html#extensibility","title":"Extensibility","text":"<p>The modular architecture of D-FAST Bank Erosion allows for easy extension and modification:</p> <ul> <li>New hydrodynamic data formats can be supported by extending the I/O module</li> <li>Additional erosion calculation methods can be implemented in the Bank Erosion module</li> <li>New visualization types can be added to the Plotting module</li> </ul>"},{"location":"architecture-design/main-components.html#conclusion","title":"Conclusion","text":"<p>The D-FAST Bank Erosion software has a well-structured architecture that separates concerns into distinct modules. The modular design allows for easy maintenance, extension, and testing of the software.</p>"},{"location":"gui/gui.html","title":"gui","text":""},{"location":"gui/gui.html#gui_1","title":"gui","text":""},{"location":"gui/gui.html#dfastbe.gui.gui","title":"<code>dfastbe.gui.gui</code>","text":"<p>Copyright (C) 2025 Stichting Deltares.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation version 2.1.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, see http://www.gnu.org/licenses/.</p> <p>contact: delft3d.support@deltares.nl Stichting Deltares P.O. Box 177 2600 MH Delft, The Netherlands</p> <p>All indications and logos of, and references to, \"Delft3D\" and \"Deltares\" are registered trademarks of Stichting Deltares, and remain the property of Stichting Deltares. All rights reserved.</p> <p>INFORMATION This file is part of D-FAST Bank Erosion: https://github.com/Deltares/D-FAST_Bank_Erosion</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.GUI","title":"<code>GUI</code>","text":"Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>class GUI:\n\n    def __init__(self):\n        global dialog\n        dialog = {}\n\n        self.app = QApplication()\n        self.app.setStyle(\"fusion\")\n        dialog[\"application\"] = self.app\n        self.window = self.create_window()\n        dialog[\"window\"] = self.window\n\n    @staticmethod\n    def create_window():\n        win = QMainWindow()\n        win.setWindowTitle(\"D-FAST Bank Erosion\")\n        win.setGeometry(200, 200, 600, 300)\n        win.setWindowIcon(get_icon(f\"{ICONS_DIR}/D-FASTBE.png\"))\n\n        # win.resize(1000, 800)\n        # win.setCentralWidget(QtWidgets.QWidget())\n        return win\n\n    def create(self) -&gt; None:\n        \"\"\"\n        Construct the D-FAST Bank Erosion user interface.\n        \"\"\"\n        win = self.window\n\n        menubar = win.menuBar()\n        self.create_menus(menubar)\n\n        centralWidget = QtWidgets.QWidget()\n        layout = QBoxLayout(QBoxLayout.Direction.TopToBottom, centralWidget)\n        win.setCentralWidget(centralWidget)\n\n        tabs = QtWidgets.QTabWidget(win)\n        dialog[\"tabs\"] = tabs\n        layout.addWidget(tabs)\n\n        buttonBar = QtWidgets.QWidget(win)\n        buttonBarLayout = QBoxLayout(QBoxLayout.Direction.LeftToRight, buttonBar)\n        buttonBarLayout.setContentsMargins(0, 0, 0, 0)\n        layout.addWidget(buttonBar)\n\n        detect = QPushButton(gui_text(\"action_detect\"), win)\n        detect.clicked.connect(run_detection)\n        buttonBarLayout.addWidget(detect)\n\n        erode = QPushButton(gui_text(\"action_erode\"), win)\n        erode.clicked.connect(run_erosion)\n        buttonBarLayout.addWidget(erode)\n\n        done = QPushButton(gui_text(\"action_close\"), win)\n        done.clicked.connect(self.close)\n        buttonBarLayout.addWidget(done)\n\n        addGeneralTab(tabs, win)\n        addDetectTab(tabs, win, self.app)\n        addErosionTab(tabs, win, self.app)\n        addShippingTab(tabs, win)\n        addBankTab(tabs, win)\n\n    def create_menus(self, menubar: QtWidgets.QMenuBar) -&gt; None:\n        \"\"\"\n        Add the menus to the menubar.\n\n        Arguments\n        ---------\n        menubar : QtWidgets.QMenuBar\n            Menubar to which menus should be added.\n        \"\"\"\n        menu = menubar.addMenu(gui_text(\"File\"))\n        item = menu.addAction(gui_text(\"Load\"))\n        item.triggered.connect(menu_load_configuration)\n        item = menu.addAction(gui_text(\"Save\"))\n        item.triggered.connect(menu_save_configuration)\n        menu.addSeparator()\n        item = menu.addAction(gui_text(\"Close\"))\n        item.triggered.connect(self.close)\n\n        menu = menubar.addMenu(gui_text(\"Help\"))\n        item = menu.addAction(gui_text(\"Manual\"))\n        item.triggered.connect(menu_open_manual)\n        menu.addSeparator()\n        item = menu.addAction(gui_text(\"Version\"))\n        item.triggered.connect(menu_about_self)\n        item = menu.addAction(gui_text(\"AboutQt\"))\n        item.triggered.connect(menu_about_qt)\n\n    def activate(self) -&gt; None:\n        \"\"\"Activate the user interface and run the program.\"\"\"\n        self.window.show()\n        sys.exit(self.app.exec())\n\n    def close(self) -&gt; None:\n        \"\"\"Close the dialog and program.\"\"\"\n        plt.close(\"all\")\n        self.window.close()\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.GUI.activate","title":"<code>activate() -&gt; None</code>","text":"<p>Activate the user interface and run the program.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def activate(self) -&gt; None:\n    \"\"\"Activate the user interface and run the program.\"\"\"\n    self.window.show()\n    sys.exit(self.app.exec())\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.GUI.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the dialog and program.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the dialog and program.\"\"\"\n    plt.close(\"all\")\n    self.window.close()\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.GUI.create","title":"<code>create() -&gt; None</code>","text":"<p>Construct the D-FAST Bank Erosion user interface.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def create(self) -&gt; None:\n    \"\"\"\n    Construct the D-FAST Bank Erosion user interface.\n    \"\"\"\n    win = self.window\n\n    menubar = win.menuBar()\n    self.create_menus(menubar)\n\n    centralWidget = QtWidgets.QWidget()\n    layout = QBoxLayout(QBoxLayout.Direction.TopToBottom, centralWidget)\n    win.setCentralWidget(centralWidget)\n\n    tabs = QtWidgets.QTabWidget(win)\n    dialog[\"tabs\"] = tabs\n    layout.addWidget(tabs)\n\n    buttonBar = QtWidgets.QWidget(win)\n    buttonBarLayout = QBoxLayout(QBoxLayout.Direction.LeftToRight, buttonBar)\n    buttonBarLayout.setContentsMargins(0, 0, 0, 0)\n    layout.addWidget(buttonBar)\n\n    detect = QPushButton(gui_text(\"action_detect\"), win)\n    detect.clicked.connect(run_detection)\n    buttonBarLayout.addWidget(detect)\n\n    erode = QPushButton(gui_text(\"action_erode\"), win)\n    erode.clicked.connect(run_erosion)\n    buttonBarLayout.addWidget(erode)\n\n    done = QPushButton(gui_text(\"action_close\"), win)\n    done.clicked.connect(self.close)\n    buttonBarLayout.addWidget(done)\n\n    addGeneralTab(tabs, win)\n    addDetectTab(tabs, win, self.app)\n    addErosionTab(tabs, win, self.app)\n    addShippingTab(tabs, win)\n    addBankTab(tabs, win)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.GUI.create_menus","title":"<code>create_menus(menubar: QtWidgets.QMenuBar) -&gt; None</code>","text":"<p>Add the menus to the menubar.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.GUI.create_menus--arguments","title":"Arguments","text":"<p>menubar : QtWidgets.QMenuBar     Menubar to which menus should be added.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def create_menus(self, menubar: QtWidgets.QMenuBar) -&gt; None:\n    \"\"\"\n    Add the menus to the menubar.\n\n    Arguments\n    ---------\n    menubar : QtWidgets.QMenuBar\n        Menubar to which menus should be added.\n    \"\"\"\n    menu = menubar.addMenu(gui_text(\"File\"))\n    item = menu.addAction(gui_text(\"Load\"))\n    item.triggered.connect(menu_load_configuration)\n    item = menu.addAction(gui_text(\"Save\"))\n    item.triggered.connect(menu_save_configuration)\n    menu.addSeparator()\n    item = menu.addAction(gui_text(\"Close\"))\n    item.triggered.connect(self.close)\n\n    menu = menubar.addMenu(gui_text(\"Help\"))\n    item = menu.addAction(gui_text(\"Manual\"))\n    item.triggered.connect(menu_open_manual)\n    menu.addSeparator()\n    item = menu.addAction(gui_text(\"Version\"))\n    item.triggered.connect(menu_about_self)\n    item = menu.addAction(gui_text(\"AboutQt\"))\n    item.triggered.connect(menu_about_qt)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.addAnItem","title":"<code>addAnItem(key: str) -&gt; None</code>","text":"<p>Implements the actions for the add item button.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.addAnItem--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def addAnItem(key: str) -&gt; None:\n    \"\"\"\n    Implements the actions for the add item button.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    \"\"\"\n    nItems = dialog[key].invisibleRootItem().childCount()\n    i = nItems + 1\n    istr = str(i)\n    if key == \"searchLines\":\n        fileName, dist = editASearchLine(key, istr)\n        c1 = QtWidgets.QTreeWidgetItem(dialog[\"searchLines\"], [istr, fileName, dist])\n    elif key == \"discharges\":\n        prob = str(1 / (nItems + 1))\n        fileName, prob = editADischarge(key, istr, prob=prob)\n        c1 = QtWidgets.QTreeWidgetItem(dialog[\"discharges\"], [istr, fileName, prob])\n        addTabForLevel(istr)\n        dialog[\"refLevel\"].validator().setTop(i)\n    dialog[key + \"Edit\"].setEnabled(True)\n    dialog[key + \"Remove\"].setEnabled(True)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.addBankTab","title":"<code>addBankTab(tabs: QtWidgets.QTabWidget, win: QtWidgets.QMainWindow) -&gt; None</code>","text":"<p>Create the tab for the general bank properties.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.addBankTab--arguments","title":"Arguments","text":"<p>tabs : QtWidgets.QTabWidget     Tabs object to which the tab should be added. win : QtWidgets.QMainWindow     The window object in which the tab item is located.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def addBankTab(\n    tabs: QtWidgets.QTabWidget, win: QtWidgets.QMainWindow\n) -&gt; None:\n    \"\"\"\n    Create the tab for the general bank properties.\n\n    Arguments\n    ---------\n    tabs : QtWidgets.QTabWidget\n        Tabs object to which the tab should be added.\n    win : QtWidgets.QMainWindow\n        The window object in which the tab item is located.\n    \"\"\"\n    eParamsWidget = QtWidgets.QWidget()\n    eParamsLayout = QtWidgets.QGridLayout(eParamsWidget)\n    tabs.addTab(eParamsWidget, \"Bank Parameters\")\n\n    strength = QtWidgets.QLabel(\"Strength Parameter\")\n    eParamsLayout.addWidget(strength, 0, 0)\n    strengthPar = QtWidgets.QComboBox()\n    strengthPar.addItems((\"Bank Type\", \"Critical Shear Stress\"))\n    strengthPar.currentIndexChanged.connect(bankStrengthSwitch)\n    dialog[\"strengthPar\"] = strengthPar\n    eParamsLayout.addWidget(strengthPar, 0, 1, 1, 2)\n\n    generalParLayout(\n        eParamsLayout,\n        1,\n        \"bankType\",\n        \"Bank Type\",\n        selectList=[\n            \"0 (Beschermde oeverlijn)\",\n            \"1 (Begroeide oeverlijn)\",\n            \"2 (Goede klei)\",\n            \"3 (Matig / slechte klei)\",\n            \"4 (Zand)\",\n        ],\n    )\n    generalParLayout(eParamsLayout, 3, \"bankShear\", \"Critical Shear Stress [N/m2]\")\n    bankStrengthSwitch()\n    generalParLayout(eParamsLayout, 4, \"bankProtect\", \"Protection [m]\")\n    generalParLayout(eParamsLayout, 5, \"bankSlope\", \"Slope [-]\")\n    generalParLayout(eParamsLayout, 6, \"bankReed\", \"Reed [-]\")\n\n    addFilter(eParamsLayout, 7, \"velFilter\", \"Velocity Filter [km]\")\n    addFilter(eParamsLayout, 8, \"bedFilter\", \"Bank Elevation Filter [km]\")\n\n    stretch = QtWidgets.QSpacerItem(\n        10, 10, QSizePolicy.Policy.Ignored, QSizePolicy.Policy.Expanding\n    )\n    eParamsLayout.addItem(stretch, 9, 0)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.addCheckBox","title":"<code>addCheckBox(formLayout: QtWidgets.QFormLayout, key: str, labelString: str, isChecked: bool = False) -&gt; None</code>","text":"<p>Add a line of with checkbox control to a form layout.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.addCheckBox--arguments","title":"Arguments","text":"<p>formLayout : QtWidgets.QFormLayout     Form layout object in which to position the edit controls. key : str     Short name of the parameter. labelString : str     String describing the parameter to be displayed as label. isChecked : bool     Initial state of the check box.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def addCheckBox(\n    formLayout: QtWidgets.QFormLayout,\n    key: str,\n    labelString: str,\n    isChecked: bool = False,\n) -&gt; None:\n    \"\"\"\n    Add a line of with checkbox control to a form layout.\n\n    Arguments\n    ---------\n    formLayout : QtWidgets.QFormLayout\n        Form layout object in which to position the edit controls.\n    key : str\n        Short name of the parameter.\n    labelString : str\n        String describing the parameter to be displayed as label.\n    isChecked : bool\n        Initial state of the check box.\n    \"\"\"\n    checkBox = QtWidgets.QCheckBox(\"\")\n    checkBox.setChecked(isChecked)\n    dialog[key + \"Edit\"] = checkBox\n\n    checkTxt = QtWidgets.QLabel(labelString)\n    dialog[key] = checkTxt\n    formLayout.addRow(checkTxt, checkBox)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.addDetectTab","title":"<code>addDetectTab(tabs: QtWidgets.QTabWidget, win: QtWidgets.QMainWindow, app: QtWidgets.QApplication) -&gt; None</code>","text":"<p>Create the tab for the bank line detection settings.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.addDetectTab--arguments","title":"Arguments","text":"<p>tabs : QtWidgets.QTabWidget     Tabs object to which the tab should be added. win : QtWidgets.QMainWindow     The window object in which the tab item is located. app : QtWidgets.QApplication     The application object to which the window belongs, needed for font information.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def addDetectTab(\n    tabs: QtWidgets.QTabWidget,\n    win: QtWidgets.QMainWindow,\n    app: QtWidgets.QApplication,\n) -&gt; None:\n    \"\"\"\n    Create the tab for the bank line detection settings.\n\n    Arguments\n    ---------\n    tabs : QtWidgets.QTabWidget\n        Tabs object to which the tab should be added.\n    win : QtWidgets.QMainWindow\n        The window object in which the tab item is located.\n    app : QtWidgets.QApplication\n        The application object to which the window belongs, needed for font information.\n    \"\"\"\n    detectWidget = QtWidgets.QWidget()\n    detectLayout = QtWidgets.QFormLayout(detectWidget)\n    tabs.addTab(detectWidget, \"Detection\")\n\n    addOpenFileRow(detectLayout, \"simFile\", \"Simulation File\")\n\n    waterDepth = QtWidgets.QLineEdit(win)\n    waterDepth.setValidator(validator(\"positive_real\"))\n    dialog[\"waterDepth\"] = waterDepth\n    detectLayout.addRow(\"Water Depth [m]\", waterDepth)\n\n    searchLines = QtWidgets.QTreeWidget(win)\n    searchLines.setHeaderLabels([\"Index\", \"FileName\", \"Search Distance [m]\"])\n    searchLines.setFont(app.font())\n    searchLines.setColumnWidth(0, 50)\n    searchLines.setColumnWidth(1, 200)\n    # c1 = QtWidgets.QTreeWidgetItem(searchLines, [\"0\", \"test\\\\filename\", \"50\"])\n\n    slLayout = addRemoveEditLayout(searchLines, \"searchLines\")\n    detectLayout.addRow(\"Search Lines\", slLayout)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.addErosionTab","title":"<code>addErosionTab(tabs: QtWidgets.QTabWidget, win: QtWidgets.QMainWindow, app: QtWidgets.QApplication) -&gt; None</code>","text":"<p>Create the tab for the main bank erosion settings.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.addErosionTab--arguments","title":"Arguments","text":"<p>tabs : QtWidgets.QTabWidget     Tabs object to which the tab should be added. win : QtWidgets.QMainWindow     The window object in which the tab item is located. app : QtWidgets.QApplication     The application object to which the window belongs, needed for font information.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def addErosionTab(\n    tabs: QtWidgets.QTabWidget,\n    win: QtWidgets.QMainWindow,\n    app: QtWidgets.QApplication,\n) -&gt; None:\n    \"\"\"\n    Create the tab for the main bank erosion settings.\n\n    Arguments\n    ---------\n    tabs : QtWidgets.QTabWidget\n        Tabs object to which the tab should be added.\n    win : QtWidgets.QMainWindow\n        The window object in which the tab item is located.\n    app : QtWidgets.QApplication\n        The application object to which the window belongs, needed for font information.\n    \"\"\"\n    erosionWidget = QtWidgets.QWidget()\n    erosionLayout = QtWidgets.QFormLayout(erosionWidget)\n    tabs.addTab(erosionWidget, \"Erosion\")\n\n    tErosion = QtWidgets.QLineEdit(win)\n    tErosion.setValidator(validator(\"positive_real\"))\n    dialog[\"tErosion\"] = tErosion\n    erosionLayout.addRow(\"Simulation Time [yr]\", tErosion)\n\n    addOpenFileRow(erosionLayout, \"riverAxis\", \"River Axis File\")\n\n    addOpenFileRow(erosionLayout, \"fairway\", \"Fairway File\")\n\n    discharges = QtWidgets.QTreeWidget(win)\n    discharges.setHeaderLabels([\"Level\", \"FileName\", \"Probability [-]\"])\n    discharges.setFont(app.font())\n    discharges.setColumnWidth(0, 50)\n    discharges.setColumnWidth(1, 250)\n    # c1 = QtWidgets.QTreeWidgetItem(discharges, [\"0\", \"test\\\\filename\", \"0.5\"])\n\n    disLayout = addRemoveEditLayout(discharges, \"discharges\")\n    erosionLayout.addRow(\"Discharges\", disLayout)\n\n    refLevel = QtWidgets.QLineEdit(win)\n    refLevel.setValidator(QtGui.QIntValidator(1, 1))\n    dialog[\"refLevel\"] = refLevel\n    erosionLayout.addRow(\"Reference Case\", refLevel)\n\n    chainageOutStep = QtWidgets.QLineEdit(win)\n    chainageOutStep.setValidator(validator(\"positive_real\"))\n    dialog[\"chainageOutStep\"] = chainageOutStep\n    erosionLayout.addRow(\"Chainage Output Step [km]\", chainageOutStep)\n\n    addOpenFileRow(erosionLayout, \"outDir\", \"Output Directory\")\n\n    newBankFile = QtWidgets.QLineEdit(win)\n    dialog[\"newBankFile\"] = newBankFile\n    erosionLayout.addRow(\"New Bank File Name\", newBankFile)\n\n    newEqBankFile = QtWidgets.QLineEdit(win)\n    dialog[\"newEqBankFile\"] = newEqBankFile\n    erosionLayout.addRow(\"New Eq Bank File Name\", newEqBankFile)\n\n    eroVol = QtWidgets.QLineEdit(win)\n    dialog[\"eroVol\"] = eroVol\n    erosionLayout.addRow(\"EroVol File Name\", eroVol)\n\n    eroVolEqui = QtWidgets.QLineEdit(win)\n    dialog[\"eroVolEqui\"] = eroVolEqui\n    erosionLayout.addRow(\"EroVolEqui File Name\", eroVolEqui)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.addFilter","title":"<code>addFilter(gridLayout: QtWidgets.QGridLayout, row: int, key: str, labelString: str) -&gt; None</code>","text":"<p>Add a line of controls for a filter</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.addFilter--arguments","title":"Arguments","text":"<p>gridLayout : QtWidgets.QGridLayout     Grid layout object in which to position the edit controls. row : int     Grid row number to be used for this parameter. key : str     Short name of the parameter. labelString : str     String describing the parameter to be displayed as label.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def addFilter(\n    gridLayout: QtWidgets.QGridLayout, row: int, key: str, labelString: str\n) -&gt; None:\n    \"\"\"\n    Add a line of controls for a filter\n\n    Arguments\n    ---------\n    gridLayout : QtWidgets.QGridLayout\n        Grid layout object in which to position the edit controls.\n    row : int\n        Grid row number to be used for this parameter.\n    key : str\n        Short name of the parameter.\n    labelString : str\n        String describing the parameter to be displayed as label.\n    \"\"\"\n\n    widthEdit = QtWidgets.QLineEdit(\"0.3\")\n    widthEdit.setValidator(validator(\"positive_real\"))\n    gridLayout.addWidget(widthEdit, row, 2)\n    dialog[key + \"Width\"] = widthEdit\n\n    useFilter = QtWidgets.QCheckBox(\"\")\n    useFilter.setChecked(False)\n    useFilter.stateChanged.connect(lambda: updateFilter(key))\n    gridLayout.addWidget(useFilter, row, 1)\n    dialog[key + \"Active\"] = useFilter\n\n    filterTxt = QtWidgets.QLabel(labelString)\n    gridLayout.addWidget(filterTxt, row, 0)\n    dialog[key + \"Txt\"] = filterTxt\n\n    updateFilter(key)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.addGeneralTab","title":"<code>addGeneralTab(tabs: QtWidgets.QTabWidget, win: QtWidgets.QMainWindow) -&gt; None</code>","text":"<p>Create the tab for the general settings.</p> <p>These settings are used by both the bank line detection and the bank erosion analysis.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.addGeneralTab--arguments","title":"Arguments","text":"<p>tabs : QtWidgets.QTabWidget     Tabs object to which the tab should be added. win : QtWidgets.QMainWindow     Windows in which the tab item is located.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def addGeneralTab(\n    tabs: QtWidgets.QTabWidget, win: QtWidgets.QMainWindow\n) -&gt; None:\n    \"\"\"\n    Create the tab for the general settings.\n\n    These settings are used by both the bank line detection and the bank\n    erosion analysis.\n\n    Arguments\n    ---------\n    tabs : QtWidgets.QTabWidget\n        Tabs object to which the tab should be added.\n    win : QtWidgets.QMainWindow\n        Windows in which the tab item is located.\n    \"\"\"\n    generalWidget = QtWidgets.QWidget()\n    generalLayout = QtWidgets.QFormLayout(generalWidget)\n    tabs.addTab(generalWidget, \"General\")\n\n    addOpenFileRow(generalLayout, \"chainFile\", \"Chain File\")\n\n    chainRange = QtWidgets.QWidget()\n    gridly = QtWidgets.QGridLayout(chainRange)\n    gridly.setContentsMargins(0, 0, 0, 0)\n\n    gridly.addWidget(QtWidgets.QLabel(\"From [km]\", win), 0, 0)\n    startRange = QtWidgets.QLineEdit(win)\n    dialog[\"startRange\"] = startRange\n    gridly.addWidget(startRange, 0, 1)\n    gridly.addWidget(QtWidgets.QLabel(\"To [km]\", win), 0, 2)\n    endRange = QtWidgets.QLineEdit(win)\n    dialog[\"endRange\"] = endRange\n    gridly.addWidget(endRange, 0, 3)\n\n    generalLayout.addRow(\"Study Range\", chainRange)\n\n    addOpenFileRow(generalLayout, \"bankDir\", \"Bank Directory\")\n\n    bankFileName = QtWidgets.QLineEdit(win)\n    dialog[\"bankFileName\"] = bankFileName\n    generalLayout.addRow(\"Bank File Name\", bankFileName)\n\n    addCheckBox(generalLayout, \"makePlots\", \"Create Figures\", True)\n    dialog[\"makePlotsEdit\"].stateChanged.connect(updatePlotting)\n\n    addCheckBox(generalLayout, \"savePlots\", \"Save Figures\", True)\n    dialog[\"savePlotsEdit\"].stateChanged.connect(updatePlotting)\n\n    zoomPlots = QtWidgets.QWidget()\n    gridly = QtWidgets.QGridLayout(zoomPlots)\n    gridly.setContentsMargins(0, 0, 0, 0)\n\n    saveZoomPlotsEdit = QtWidgets.QCheckBox(\"\", win)\n    saveZoomPlotsEdit.stateChanged.connect(updatePlotting)\n    saveZoomPlotsEdit.setChecked(False)\n    gridly.addWidget(saveZoomPlotsEdit, 0, 0)\n    dialog[\"saveZoomPlotsEdit\"] = saveZoomPlotsEdit\n\n    zoomPlotsRangeTxt = QtWidgets.QLabel(\"Zoom Range [km]\", win)\n    zoomPlotsRangeTxt.setEnabled(False)\n    gridly.addWidget(zoomPlotsRangeTxt, 0, 1)\n    dialog[\"zoomPlotsRangeTxt\"] = zoomPlotsRangeTxt\n\n    zoomPlotsRangeEdit = QtWidgets.QLineEdit(\"1.0\",win)\n    zoomPlotsRangeEdit.setValidator(validator(\"positive_real\"))\n    zoomPlotsRangeEdit.setEnabled(False)\n    gridly.addWidget(zoomPlotsRangeEdit, 0, 2)\n    dialog[\"zoomPlotsRangeEdit\"] = zoomPlotsRangeEdit\n\n    saveZoomPlots = QtWidgets.QLabel(\"Save Zoomed Figures\", win)\n    generalLayout.addRow(saveZoomPlots, zoomPlots)\n    dialog[\"saveZoomPlots\"] = saveZoomPlots\n\n    addOpenFileRow(generalLayout, \"figureDir\", \"Figure Directory\")\n    addCheckBox(generalLayout, \"closePlots\", \"Close Figures\")\n    addCheckBox(generalLayout, \"debugOutput\", \"Debug Output\")\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.addOpenFileRow","title":"<code>addOpenFileRow(formLayout: QtWidgets.QFormLayout, key: str, labelString: str) -&gt; None</code>","text":"<p>Add a line of controls for selecting a file or folder in a form layout.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.addOpenFileRow--arguments","title":"Arguments","text":"<p>formLayout : QtWidgets.QFormLayout     Form layout object in which to position the edit controls. key : str     Short name of the parameter. labelString : str     String describing the parameter to be displayed as label.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def addOpenFileRow(\n    formLayout: QtWidgets.QFormLayout, key: str, labelString: str\n) -&gt; None:\n    \"\"\"\n    Add a line of controls for selecting a file or folder in a form layout.\n\n    Arguments\n    ---------\n    formLayout : QtWidgets.QFormLayout\n        Form layout object in which to position the edit controls.\n    key : str\n        Short name of the parameter.\n    labelString : str\n        String describing the parameter to be displayed as label.\n    \"\"\"\n    Label = QtWidgets.QLabel(labelString)\n    dialog[key] = Label\n    fLayout = openFileLayout(key + \"Edit\")\n    formLayout.addRow(Label, fLayout)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.addRemoveEditLayout","title":"<code>addRemoveEditLayout(mainWidget: QtWidgets.QWidget, key: str) -&gt; QtWidgets.QWidget</code>","text":"<p>Create a standard layout with list control and add, edit and remove buttons.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.addRemoveEditLayout--arguments","title":"Arguments","text":"<p>mainWidget : QtWidgets.QWidget     Main object on which the add, edit and remove buttons should operate. key : str     Short name of the parameter.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.addRemoveEditLayout--returns","title":"Returns","text":"<p>parent : QtWidgets.QWidget     Parent QtWidget that contains the add, edit and remove buttons.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def addRemoveEditLayout(\n    mainWidget: QtWidgets.QWidget, key: str\n) -&gt; QtWidgets.QWidget:\n    \"\"\"\n    Create a standard layout with list control and add, edit and remove buttons.\n\n    Arguments\n    ---------\n    mainWidget : QtWidgets.QWidget\n        Main object on which the add, edit and remove buttons should operate.\n    key : str\n        Short name of the parameter.\n\n    Returns\n    -------\n    parent : QtWidgets.QWidget\n        Parent QtWidget that contains the add, edit and remove buttons.\n    \"\"\"\n    parent = QtWidgets.QWidget()\n    gridly = QtWidgets.QGridLayout(parent)\n    gridly.setContentsMargins(0, 0, 0, 0)\n\n    dialog[key] = mainWidget\n    gridly.addWidget(mainWidget, 0, 0)\n\n    buttonBar = QtWidgets.QWidget()\n    buttonBarLayout = QBoxLayout(QBoxLayout.Direction.TopToBottom, buttonBar)\n    buttonBarLayout.setContentsMargins(0, 0, 0, 0)\n    gridly.addWidget(buttonBar, 0, 1)\n\n    addBtn = QPushButton(get_icon(f\"{ICONS_DIR}/add.png\"), \"\")\n    addBtn.clicked.connect(lambda: addAnItem(key))\n    dialog[key + \"Add\"] = addBtn\n    buttonBarLayout.addWidget(addBtn)\n\n    editBtn = QPushButton(get_icon(f\"{ICONS_DIR}/edit.png\"), \"\")\n    editBtn.clicked.connect(lambda: editAnItem(key))\n    editBtn.setEnabled(False)\n    dialog[key + \"Edit\"] = editBtn\n    buttonBarLayout.addWidget(editBtn)\n\n    delBtn = QPushButton(get_icon(f\"{ICONS_DIR}/remove.png\"), \"\")\n    delBtn.clicked.connect(lambda: removeAnItem(key))\n    delBtn.setEnabled(False)\n    dialog[key + \"Remove\"] = delBtn\n    buttonBarLayout.addWidget(delBtn)\n\n    stretch = QtWidgets.QSpacerItem(\n        10, 10, QSizePolicy.Policy.Ignored, QSizePolicy.Policy.Expanding\n    )\n    buttonBarLayout.addItem(stretch)\n\n    return parent\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.addShippingTab","title":"<code>addShippingTab(tabs: QtWidgets.QTabWidget, win: QtWidgets.QMainWindow) -&gt; None</code>","text":"<p>Create the tab for the general shipping settings.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.addShippingTab--arguments","title":"Arguments","text":"<p>tabs : QtWidgets.QTabWidget     Tabs object to which the tab should be added. win : QtWidgets.QMainWindow     The window object in which the tab item is located.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def addShippingTab(\n    tabs: QtWidgets.QTabWidget, win: QtWidgets.QMainWindow\n) -&gt; None:\n    \"\"\"\n    Create the tab for the general shipping settings.\n\n    Arguments\n    ---------\n    tabs : QtWidgets.QTabWidget\n        Tabs object to which the tab should be added.\n    win : QtWidgets.QMainWindow\n        The window object in which the tab item is located.\n    \"\"\"\n    eParamsWidget = QtWidgets.QWidget()\n    eParamsLayout = QtWidgets.QGridLayout(eParamsWidget)\n    tabs.addTab(eParamsWidget, \"Shipping Parameters\")\n\n    generalParLayout(eParamsLayout, 0, \"shipType\", \"Ship Type\", selectList=SHIP_TYPES)\n    generalParLayout(eParamsLayout, 2, \"shipVeloc\", \"Velocity [m/s]\")\n    generalParLayout(eParamsLayout, 3, \"nShips\", \"# Ships [1/yr]\")\n    generalParLayout(eParamsLayout, 4, \"shipNWaves\", \"# Waves [1/ship]\")\n    generalParLayout(eParamsLayout, 5, \"shipDraught\", \"Draught [m]\")\n    generalParLayout(eParamsLayout, 6, \"wavePar0\", \"Wave0 [m]\")\n    generalParLayout(eParamsLayout, 7, \"wavePar1\", \"Wave1 [m]\")\n\n    stretch = QtWidgets.QSpacerItem(\n        10, 10, QSizePolicy.Policy.Ignored, QSizePolicy.Policy.Expanding\n    )\n    eParamsLayout.addItem(stretch, 8, 0)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.addTabForLevel","title":"<code>addTabForLevel(istr: str) -&gt; None</code>","text":"<p>Create the tab for the settings associated with simulation i.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.addTabForLevel--arguments","title":"Arguments","text":"<p>istr : str     String representation of the simulation number.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.addTabForLevel--arguments_1","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def addTabForLevel(istr: str) -&gt; None:\n    \"\"\"\n    Create the tab for the settings associated with simulation i.\n\n    Arguments\n    ---------\n    istr : str\n        String representation of the simulation number.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    newWidget = QtWidgets.QWidget()\n    newLayout = QtWidgets.QGridLayout(newWidget)\n    dialog[\"tabs\"].addTab(newWidget, \"Level \" + istr)\n\n    optionalParLayout(\n        newLayout, 0, istr + \"_shipType\", \"Ship Type\", selectList=SHIP_TYPES\n    )\n    optionalParLayout(newLayout, 2, istr + \"_shipVeloc\", \"Velocity [m/s]\")\n    optionalParLayout(newLayout, 3, istr + \"_nShips\", \"# Ships [1/yr]\")\n    optionalParLayout(newLayout, 4, istr + \"_shipNWaves\", \"# Waves [1/ship]\")\n    optionalParLayout(newLayout, 5, istr + \"_shipDraught\", \"Draught [m]\")\n    optionalParLayout(newLayout, 6, istr + \"_bankSlope\", \"Slope [-]\")\n    optionalParLayout(newLayout, 7, istr + \"_bankReed\", \"Reed [-]\")\n\n    Label = QtWidgets.QLabel(\"EroVol File Name\")\n    dialog[istr + \"_eroVol\"] = Label\n    newLayout.addWidget(Label, 8, 0)\n    Edit = QtWidgets.QLineEdit()\n    dialog[istr + \"_eroVolEdit\"] = Edit\n    newLayout.addWidget(Edit, 8, 2)\n\n    stretch = QtWidgets.QSpacerItem(\n        10, 10, QSizePolicy.Policy.Ignored, QSizePolicy.Policy.Expanding\n    )\n    newLayout.addItem(stretch, 9, 0)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.bankStrengthSwitch","title":"<code>bankStrengthSwitch() -&gt; None</code>","text":"<p>Implements the dialog settings depending on the bank strength specification method.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.bankStrengthSwitch--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def bankStrengthSwitch() -&gt; None:\n    \"\"\"\n    Implements the dialog settings depending on the bank strength specification method.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    type = dialog[\"strengthPar\"].currentText()\n    if type == \"Bank Type\":\n        dialog[\"bankType\"].setEnabled(True)\n        dialog[\"bankTypeType\"].setEnabled(True)\n        typeUpdatePar(\"bankType\")\n        dialog[\"bankShear\"].setEnabled(False)\n        dialog[\"bankShearType\"].setEnabled(False)\n        dialog[\"bankShearEdit\"].setText(\"\")\n        dialog[\"bankShearEdit\"].setEnabled(False)\n        dialog[\"bankShearEditFile\"].setEnabled(False)\n    elif type == \"Critical Shear Stress\":\n        dialog[\"bankShear\"].setEnabled(True)\n        dialog[\"bankShearType\"].setEnabled(True)\n        dialog[\"bankShearEdit\"].setEnabled(True)\n        typeUpdatePar(\"bankShear\")\n        dialog[\"bankType\"].setEnabled(False)\n        dialog[\"bankTypeType\"].setEnabled(False)\n        dialog[\"bankTypeSelect\"].setEnabled(False)\n        dialog[\"bankTypeEdit\"].setText(\"\")\n        dialog[\"bankTypeEdit\"].setEnabled(False)\n        dialog[\"bankTypeEditFile\"].setEnabled(False)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.close_edit","title":"<code>close_edit(hDialog: QDialog) -&gt; None</code>","text":"<p>Generic close function for edit dialogs.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.close_edit--arguments","title":"Arguments","text":"<p>hDialog : QDialog     Dialog object to be closed.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def close_edit(hDialog: QDialog) -&gt; None:\n    \"\"\"\n    Generic close function for edit dialogs.\n\n    Arguments\n    ---------\n    hDialog : QDialog\n        Dialog object to be closed.\n    \"\"\"\n    hDialog.close()\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.editADischarge","title":"<code>editADischarge(key: str, istr: str, fileName: str = '', prob: str = '')</code>","text":"<p>Create an edit dialog for simulation file and weighing.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.editADischarge--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter. istr : str     String representation of the simulation in the list. fileName : str     Name of the simulation file. prob : str     String representation of the weight for this simulation.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def editADischarge(key: str, istr: str, fileName: str = \"\", prob: str = \"\"):\n    \"\"\"\n    Create an edit dialog for simulation file and weighing.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    istr : str\n        String representation of the simulation in the list.\n    fileName : str\n        Name of the simulation file.\n    prob : str\n        String representation of the weight for this simulation.\n    \"\"\"\n    editDialog = QDialog()\n    setDialogSize(editDialog, 600, 100)\n    editDialog.setWindowFlags(\n        QtCore.Qt.WindowTitleHint | QtCore.Qt.WindowSystemMenuHint\n    )\n    editDialog.setWindowTitle(\"Edit Discharge\")\n    editLayout = QtWidgets.QFormLayout(editDialog)\n\n    label = QtWidgets.QLabel(istr)\n    editLayout.addRow(\"Level Nr\", label)\n\n    addOpenFileRow(editLayout, \"editDischarge\", \"Simulation File\")\n    dialog[\"editDischargeEdit\"].setText(fileName)\n\n    probability = QtWidgets.QLineEdit()\n    probability.setText(prob)\n    probability.setValidator(validator(\"positive_real\"))\n    editLayout.addRow(\"Probability [-]\", probability)\n\n    done = QPushButton(\"Done\")\n    done.clicked.connect(lambda: close_edit(editDialog))\n    # edit_SearchDistance.setValidator(validator(\"positive_real\"))\n    editLayout.addRow(\" \", done)\n\n    editDialog.exec()\n\n    fileName = dialog[\"editDischargeEdit\"].text()\n    prob = probability.text()\n    return fileName, prob\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.editASearchLine","title":"<code>editASearchLine(key: str, istr: str, fileName: str = '', dist: str = '50') -&gt; Tuple[str, str]</code>","text":"<p>Create an edit dialog for the search lines list.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.editASearchLine--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter. istr : str     String representation of the search line in the list. fileName : str     Name of the search line file. dist : str     String representation of the search distance.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.editASearchLine--returns","title":"Returns","text":"<p>fileName1 : str     Updated name of the search line file. dist1 : str     Updated string representation of the search distance.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def editASearchLine(\n    key: str, istr: str, fileName: str = \"\", dist: str = \"50\"\n) -&gt; Tuple[str, str]:\n    \"\"\"\n    Create an edit dialog for the search lines list.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    istr : str\n        String representation of the search line in the list.\n    fileName : str\n        Name of the search line file.\n    dist : str\n        String representation of the search distance.\n\n    Returns\n    -------\n    fileName1 : str\n        Updated name of the search line file.\n    dist1 : str\n        Updated string representation of the search distance.\n    \"\"\"\n    editDialog = QDialog()\n    setDialogSize(editDialog, 600, 100)\n    editDialog.setWindowFlags(\n        QtCore.Qt.WindowTitleHint | QtCore.Qt.WindowSystemMenuHint\n    )\n    editDialog.setWindowTitle(\"Edit Search Line\")\n    editLayout = QtWidgets.QFormLayout(editDialog)\n\n    label = QtWidgets.QLabel(istr)\n    editLayout.addRow(\"Search Line Nr\", label)\n\n    addOpenFileRow(editLayout, \"editSearchLine\", \"Search Line File\")\n    dialog[\"editSearchLineEdit\"].setText(fileName)\n\n    searchDistance = QtWidgets.QLineEdit()\n    searchDistance.setText(dist)\n    searchDistance.setValidator(validator(\"positive_real\"))\n    editLayout.addRow(\"Search Distance [m]\", searchDistance)\n\n    done = QPushButton(\"Done\")\n    done.clicked.connect(lambda: close_edit(editDialog))\n    # edit_SearchDistance.setValidator(validator(\"positive_real\"))\n    editLayout.addRow(\" \", done)\n\n    editDialog.exec()\n\n    fileName = dialog[\"editSearchLineEdit\"].text()\n    dist = searchDistance.text()\n    return fileName, dist\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.editAnItem","title":"<code>editAnItem(key: str) -&gt; None</code>","text":"<p>Implements the actions for the edit item button.</p> <p>Dialog implemented in separate routines.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.editAnItem--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def editAnItem(key: str) -&gt; None:\n    \"\"\"\n    Implements the actions for the edit item button.\n\n    Dialog implemented in separate routines.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    \"\"\"\n    selected = dialog[key].selectedItems()\n    root = dialog[key].invisibleRootItem()\n    if len(selected) &gt; 0:\n        istr = selected[0].text(0)\n        if key == \"searchLines\":\n            fileName = selected[0].text(1)\n            dist = selected[0].text(2)\n            fileName, dist = editASearchLine(key, istr, fileName=fileName, dist=dist)\n            selected[0].setText(1, fileName)\n            selected[0].setText(2, dist)\n        elif key == \"discharges\":\n            fileName = selected[0].text(1)\n            prob = selected[0].text(2)\n            fileName, prob = editADischarge(key, istr, fileName=fileName, prob=prob)\n            selected[0].setText(1, fileName)\n            selected[0].setText(2, prob)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.generalParLayout","title":"<code>generalParLayout(gridLayout: QtWidgets.QGridLayout, row: int, key: str, labelString: str, selectList: Optional[List[str]] = None) -&gt; None</code>","text":"<p>Add a line of controls for editing a general parameter.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.generalParLayout--arguments","title":"Arguments","text":"<p>gridLayout : QtWidgets.QGridLayout     Grid layout object in which to position the edit controls. row : int     Grid row number to be used for this parameter. key : str     Short name of the parameter. labelString : str     String describing the parameter to be displayed as label. selectList : Optional[List[str]]     In case the parameter can only have a limited number of values: a list     of strings describing the options.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def generalParLayout(\n    gridLayout: QtWidgets.QGridLayout,\n    row: int,\n    key: str,\n    labelString: str,\n    selectList: Optional[List[str]] = None,\n) -&gt; None:\n    \"\"\"\n    Add a line of controls for editing a general parameter.\n\n    Arguments\n    ---------\n    gridLayout : QtWidgets.QGridLayout\n        Grid layout object in which to position the edit controls.\n    row : int\n        Grid row number to be used for this parameter.\n    key : str\n        Short name of the parameter.\n    labelString : str\n        String describing the parameter to be displayed as label.\n    selectList : Optional[List[str]]\n        In case the parameter can only have a limited number of values: a list\n        of strings describing the options.\n    \"\"\"\n    Label = QLabel(labelString)\n    dialog[key] = Label\n    gridLayout.addWidget(Label, row, 0)\n\n    paramTypes = (\"Constant\", \"Variable\")\n    Type = QComboBox()\n    Type.addItems(paramTypes)\n    Type.currentIndexChanged.connect(lambda: typeUpdatePar(key))\n    dialog[key + \"Type\"] = Type\n    gridLayout.addWidget(Type, row, 1)\n\n    if selectList is None:\n        fLayout = openFileLayout(key + \"Edit\", enabled=False)\n        gridLayout.addWidget(fLayout, row, 2)\n    else:\n        Select = QtWidgets.QComboBox()\n        Select.addItems(selectList)\n        dialog[key + \"Select\"] = Select\n        gridLayout.addWidget(Select, row, 2)\n\n        fLayout = openFileLayout(key + \"Edit\", enabled=False)\n        dialog[key + \"Edit\"].setEnabled(False)\n        gridLayout.addWidget(fLayout, row + 1, 2)\n\n    typeUpdatePar(key)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.get_configuration","title":"<code>get_configuration() -&gt; configparser.ConfigParser</code>","text":"<p>Extract a configuration from the GUI.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.get_configuration--arguments","title":"Arguments","text":"<p>None</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.get_configuration--returns","title":"Returns","text":"<p>config : configparser.ConfigParser     Configuration for the D-FAST Bank Erosion analysis.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def get_configuration() -&gt; configparser.ConfigParser:\n    \"\"\"\n    Extract a configuration from the GUI.\n\n    Arguments\n    ---------\n    None\n\n    Returns\n    -------\n    config : configparser.ConfigParser\n        Configuration for the D-FAST Bank Erosion analysis.\n    \"\"\"\n    config = configparser.ConfigParser()\n    config.optionxform = str  # case sensitive configuration\n\n    config.add_section(\"General\")\n    config[\"General\"][\"Version\"] = \"1.0\"\n    config[\"General\"][\"RiverKM\"] = dialog[\"chainFileEdit\"].text()\n    config[\"General\"][\"Boundaries\"] = (\n        dialog[\"startRange\"].text() + \":\" + dialog[\"endRange\"].text()\n    )\n    config[\"General\"][\"BankDir\"] = dialog[\"bankDirEdit\"].text()\n    config[\"General\"][\"BankFile\"] = dialog[\"bankFileName\"].text()\n    config[\"General\"][\"Plotting\"] = str(dialog[\"makePlotsEdit\"].isChecked())\n    config[\"General\"][\"SavePlots\"] = str(dialog[\"savePlotsEdit\"].isChecked())\n    config[\"General\"][\"SaveZoomPlots\"] = str(dialog[\"saveZoomPlotsEdit\"].isChecked())\n    config[\"General\"][\"ZoomStepKM\"] = dialog[\"zoomPlotsRangeEdit\"].text()\n    config[\"General\"][\"FigureDir\"] = dialog[\"figureDirEdit\"].text()\n    config[\"General\"][\"ClosePlots\"] = str(dialog[\"closePlotsEdit\"].isChecked())\n    config[\"General\"][\"DebugOutput\"] = str(dialog[\"debugOutputEdit\"].isChecked())\n\n    config.add_section(\"Detect\")\n    config[\"Detect\"][\"SimFile\"] = dialog[\"simFileEdit\"].text()\n    config[\"Detect\"][\"WaterDepth\"] = dialog[\"waterDepth\"].text()\n    nbank = dialog[\"searchLines\"].topLevelItemCount()\n    config[\"Detect\"][\"NBank\"] = str(nbank)\n    dlines = \"[ \"\n    for i in range(nbank):\n        istr = str(i + 1)\n        config[\"Detect\"][\"Line\" + istr] = dialog[\"searchLines\"].topLevelItem(i).text(1)\n        dlines += dialog[\"searchLines\"].topLevelItem(i).text(2) + \", \"\n    dlines = dlines[:-2] + \" ]\"\n    config[\"Detect\"][\"DLines\"] = dlines\n\n    config.add_section(\"Erosion\")\n    config[\"Erosion\"][\"TErosion\"] = dialog[\"tErosion\"].text()\n    config[\"Erosion\"][\"RiverAxis\"] = dialog[\"riverAxisEdit\"].text()\n    config[\"Erosion\"][\"Fairway\"] = dialog[\"fairwayEdit\"].text()\n    config[\"Erosion\"][\"OutputInterval\"] = dialog[\"chainageOutStep\"].text()\n    config[\"Erosion\"][\"OutputDir\"] = dialog[\"outDirEdit\"].text()\n    config[\"Erosion\"][\"BankNew\"] = dialog[\"newBankFile\"].text()\n    config[\"Erosion\"][\"BankEq\"] = dialog[\"newEqBankFile\"].text()\n    config[\"Erosion\"][\"EroVol\"] = dialog[\"eroVol\"].text()\n    config[\"Erosion\"][\"EroVolEqui\"] = dialog[\"eroVolEqui\"].text()\n\n    if dialog[\"shipTypeType\"].currentText() == \"Constant\":\n        config[\"Erosion\"][\"ShipType\"] = str(\n            dialog[\"shipTypeSelect\"].currentIndex() + 1\n        )  # index 0 -&gt; shipType 1\n    else:\n        config[\"Erosion\"][\"ShipType\"] = dialog[\"shipTypeEdit\"].text()\n    config[\"Erosion\"][\"VShip\"] = dialog[\"shipVelocEdit\"].text()\n    config[\"Erosion\"][\"NShip\"] = dialog[\"nShipsEdit\"].text()\n    config[\"Erosion\"][\"NWaves\"] = dialog[\"shipNWavesEdit\"].text()\n    config[\"Erosion\"][\"Draught\"] = dialog[\"shipDraughtEdit\"].text()\n    config[\"Erosion\"][\"Wave0\"] = dialog[\"wavePar0Edit\"].text()\n    config[\"Erosion\"][\"Wave1\"] = dialog[\"wavePar1Edit\"].text()\n\n    if dialog[\"strengthPar\"].currentText() == \"Bank Type\":\n        config[\"Erosion\"][\"Classes\"] = \"true\"\n        if dialog[\"bankTypeType\"].currentText() == \"Constant\":\n            config[\"Erosion\"][\"BankType\"] = dialog[\"bankTypeSelect\"].currentIndex()\n        else:\n            config[\"Erosion\"][\"BankType\"] = dialog[\"bankTypeEdit\"].text()\n    else:\n        config[\"Erosion\"][\"Classes\"] = \"false\"\n        config[\"Erosion\"][\"BankType\"] = dialog[\"bankShearEdit\"].text()\n    config[\"Erosion\"][\"ProtectionLevel\"] = dialog[\"bankProtectEdit\"].text()\n    config[\"Erosion\"][\"Slope\"] = dialog[\"bankSlopeEdit\"].text()\n    config[\"Erosion\"][\"Reed\"] = dialog[\"bankReedEdit\"].text()\n\n    if dialog[\"velFilterActive\"].isChecked():\n        config[\"Erosion\"][\"VelFilterDist\"] = dialog[\"velFilterWidth\"].text()\n    if dialog[\"bedFilterActive\"].isChecked():\n        config[\"Erosion\"][\"BedFilterDist\"] = dialog[\"bedFilterWidth\"].text()\n\n    nlevel = dialog[\"discharges\"].topLevelItemCount()\n    config[\"Erosion\"][\"NLevel\"] = str(nlevel)\n    config[\"Erosion\"][\"RefLevel\"] = dialog[\"refLevel\"].text()\n    for i in range(nlevel):\n        istr = str(i + 1)\n        config[\"Erosion\"][\"SimFile\" + istr] = (\n            dialog[\"discharges\"].topLevelItem(i).text(1)\n        )\n        config[\"Erosion\"][\"PDischarge\" + istr] = (\n            dialog[\"discharges\"].topLevelItem(i).text(2)\n        )\n        if dialog[istr + \"_shipTypeType\"].currentText() != \"Use Default\":\n            if dialog[istr + \"_shipTypeType\"].currentText() == \"Constant\":\n                config[\"Erosion\"][\"ShipType\" + istr] = (\n                    dialog[istr + \"_shipTypeSelect\"].currentIndex() + 1\n                )  # index 0 -&gt; shipType 1\n            else:\n                config[\"Erosion\"][\"ShipType\" + istr] = dialog[\n                    istr + \"_shipTypeEdit\"\n                ].text()\n        if dialog[istr + \"_shipVelocType\"].currentText() != \"Use Default\":\n            config[\"Erosion\"][\"VShip\" + istr] = dialog[istr + \"_shipVelocEdit\"].text()\n        if dialog[istr + \"_nShipsType\"].currentText() != \"Use Default\":\n            config[\"Erosion\"][\"NShip\" + istr] = dialog[istr + \"_nShipsEdit\"].text()\n        if dialog[istr + \"_shipNWavesType\"].currentText() != \"Use Default\":\n            config[\"Erosion\"][\"NWaves\" + istr] = dialog[istr + \"_shipNWavesEdit\"].text()\n        if dialog[istr + \"_shipDraughtType\"].currentText() != \"Use Default\":\n            config[\"Erosion\"][\"Draught\" + istr] = dialog[\n                istr + \"_shipDraughtEdit\"\n            ].text()\n        if dialog[istr + \"_bankSlopeType\"].currentText() != \"Use Default\":\n            config[\"Erosion\"][\"Slope\" + istr] = dialog[istr + \"_bankSlopeEdit\"].text()\n        if dialog[istr + \"_bankReedType\"].currentText() != \"Use Default\":\n            config[\"Erosion\"][\"Reed\" + istr] = dialog[istr + \"_bankReedEdit\"].text()\n        if dialog[istr + \"_eroVolEdit\"].text() != \"\":\n            config[\"Erosion\"][\"EroVol\" + istr] = dialog[istr + \"_eroVolEdit\"].text()\n    return config\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.load_configuration","title":"<code>load_configuration(config_path: Path) -&gt; None</code>","text":"<p>Open a configuration file and update the GUI accordingly.</p> <p>This routines opens the specified configuration file and updates the GUI to reflect it contents.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.load_configuration--arguments","title":"Arguments","text":"<p>config_path : str     Name of the configuration file to be opened.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def load_configuration(config_path: Path) -&gt; None:\n    \"\"\"\n    Open a configuration file and update the GUI accordingly.\n\n    This routines opens the specified configuration file and updates the GUI\n    to reflect it contents.\n\n    Arguments\n    ---------\n    config_path : str\n        Name of the configuration file to be opened.\n    \"\"\"\n    if not config_path.exists():\n        if config_path != \"dfastbe.cfg\":\n            show_error(f\"The file {config_path} does not exist!\")\n        return\n\n    config_path_abs = absolute_path(os.getcwd(), config_path)\n    rootdir = os.path.dirname(config_path_abs)\n    config_file = ConfigFile.read(config_path_abs)\n\n    config_file.path = config_path_abs\n\n    try:\n        version = config_file.version\n    except KeyError:\n        show_error(f\"No version information in the file {config_path}!\")\n        return\n\n    config = config_file.config\n    if version == \"1.0\":\n        section = config[\"General\"]\n        dialog[\"chainFileEdit\"].setText(section[\"RiverKM\"])\n        studyRange = config_file.get_range(\"General\", \"Boundaries\")\n        dialog[\"startRange\"].setText(str(studyRange[0]))\n        dialog[\"endRange\"].setText(str(studyRange[1]))\n        dialog[\"bankDirEdit\"].setText(section[\"BankDir\"])\n        bankFile = config_file.get_str(\"General\", \"BankFile\", default=\"bankfile\")\n        dialog[\"bankFileName\"].setText(bankFile)\n        flag = config_file.get_bool(\"General\", \"Plotting\", default=True)\n        dialog[\"makePlotsEdit\"].setChecked(flag)\n        flag = config_file.get_bool(\"General\", \"SavePlots\", default=True)\n        dialog[\"savePlotsEdit\"].setChecked(flag)\n        flag = config_file.get_bool(\"General\", \"SaveZoomPlots\", default=False)\n        dialog[\"saveZoomPlotsEdit\"].setChecked(flag)\n        zoomStepKM = config_file.get_float(\"General\", \"ZoomStepKM\", default=1.0)\n        dialog[\"zoomPlotsRangeEdit\"].setText(str(zoomStepKM))\n        figDir = config_file.get_str(\n            \"General\",\n            \"FigureDir\",\n            default=absolute_path(rootdir, \"figures\"),\n        )\n        dialog[\"figureDirEdit\"].setText(figDir)\n        flag = config_file.get_bool(\"General\", \"ClosePlots\", default=False)\n        dialog[\"closePlotsEdit\"].setChecked(flag)\n        flag = config_file.get_bool(\"General\", \"DebugOutput\", default=False)\n        dialog[\"debugOutputEdit\"].setChecked(flag)\n\n        section = config[\"Detect\"]\n        dialog[\"simFileEdit\"].setText(section[\"SimFile\"])\n        waterDepth = config_file.get_float(\"Detect\", \"WaterDepth\", default=0.0)\n        dialog[\"waterDepth\"].setText(str(waterDepth))\n        NBank = config_file.get_int(\"Detect\", \"NBank\", default=0, positive=True)\n        DLines = config_file.get_bank_search_distances(NBank)\n        dialog[\"searchLines\"].invisibleRootItem().takeChildren()\n        for i in range(NBank):\n            istr = str(i + 1)\n            fileName = config_file.get_str(\"Detect\", \"Line\" + istr)\n            c1 = QtWidgets.QTreeWidgetItem(\n                dialog[\"searchLines\"], [istr, fileName, str(DLines[i])]\n            )\n        if NBank &gt; 0:\n            dialog[\"searchLinesEdit\"].setEnabled(True)\n            dialog[\"searchLinesRemove\"].setEnabled(True)\n\n        section = config[\"Erosion\"]\n        dialog[\"tErosion\"].setText(section[\"TErosion\"])\n        dialog[\"riverAxisEdit\"].setText(section[\"RiverAxis\"])\n        dialog[\"fairwayEdit\"].setText(section[\"Fairway\"])\n        dialog[\"chainageOutStep\"].setText(section[\"OutputInterval\"])\n        dialog[\"outDirEdit\"].setText(section[\"OutputDir\"])\n        bankNew = config_file.get_str(\"Erosion\", \"BankNew\", default=\"banknew\")\n        dialog[\"newBankFile\"].setText(bankNew)\n        bankEq = config_file.get_str(\"Erosion\", \"BankEq\", default=\"bankeq\")\n        dialog[\"newEqBankFile\"].setText(bankEq)\n        txt = config_file.get_str(\"Erosion\", \"EroVol\", default=\"erovol_standard.evo\")\n        dialog[\"eroVol\"].setText(txt)\n        txt = config_file.get_str(\"Erosion\", \"EroVolEqui\", default=\"erovol_eq.evo\")\n        dialog[\"eroVolEqui\"].setText(txt)\n\n        NLevel = config_file.get_int(\"Erosion\", \"NLevel\", default=0, positive=True)\n        dialog[\"discharges\"].invisibleRootItem().takeChildren()\n        for i in range(NLevel):\n            istr = str(i + 1)\n            fileName = config_file.get_str(\"Erosion\", \"SimFile\" + istr)\n            prob = config_file.get_str(\"Erosion\", \"PDischarge\" + istr)\n            c1 = QtWidgets.QTreeWidgetItem(dialog[\"discharges\"], [istr, fileName, prob])\n        if NLevel &gt; 0:\n            dialog[\"dischargesEdit\"].setEnabled(True)\n            dialog[\"dischargesRemove\"].setEnabled(True)\n        dialog[\"refLevel\"].validator().setTop(NLevel)\n        dialog[\"refLevel\"].setText(section[\"RefLevel\"])\n\n        setParam(\"shipType\", config, \"Erosion\", \"ShipType\")\n        setParam(\"shipVeloc\", config, \"Erosion\", \"VShip\")\n        setParam(\"nShips\", config, \"Erosion\", \"NShip\")\n        setParam(\"shipNWaves\", config, \"Erosion\", \"NWave\", \"5\")\n        setParam(\"shipDraught\", config, \"Erosion\", \"Draught\")\n        setParam(\"wavePar0\", config, \"Erosion\", \"Wave0\", \"200.0\")\n        wave0 = config_file.get_str(\"Erosion\", \"Wave0\", \"200.0\")\n        setParam(\"wavePar1\", config_file.config, \"Erosion\", \"Wave1\", wave0)\n\n        useBankType = config_file.get_bool(\"Erosion\", \"Classes\", default=True)\n        dialog[\"bankType\"].setEnabled(useBankType)\n        dialog[\"bankTypeType\"].setEnabled(useBankType)\n        dialog[\"bankTypeEdit\"].setEnabled(useBankType)\n        dialog[\"bankTypeEditFile\"].setEnabled(useBankType)\n        dialog[\"bankShear\"].setEnabled(not useBankType)\n        dialog[\"bankShearType\"].setEnabled(not useBankType)\n        dialog[\"bankShearEdit\"].setEnabled(not useBankType)\n        dialog[\"bankShearEditFile\"].setEnabled(not useBankType)\n        if useBankType:\n            dialog[\"strengthPar\"].setCurrentText(\"Bank Type\")\n            bankStrengthSwitch()\n            setParam(\"bankType\", config_file.config, \"Erosion\", \"BankType\")\n        else:\n            dialog[\"strengthPar\"].setCurrentText(\"Critical Shear Stress\")\n            bankStrengthSwitch()\n            setParam(\"bankShear\", config, \"Erosion\", \"BankType\")\n        setParam(\"bankProtect\", config, \"Erosion\", \"ProtectionLevel\", \"-1000\")\n        setParam(\"bankSlope\", config, \"Erosion\", \"Slope\", \"20.0\")\n        setParam(\"bankReed\", config, \"Erosion\", \"Reed\", \"0.0\")\n\n        setFilter(\"velFilter\", config, \"Erosion\", \"VelFilterDist\")\n        setFilter(\"bedFilter\", config, \"Erosion\", \"BedFilterDist\")\n\n        tabs = dialog[\"tabs\"]\n        for i in range(tabs.count() - 1, 4, -1):\n            tabs.removeTab(i)\n\n        for i in range(NLevel):\n            istr = str(i + 1)\n            addTabForLevel(istr)\n            setOptParam(istr + \"_shipType\", config, \"Erosion\", \"ShipType\" + istr)\n            setOptParam(istr + \"_shipVeloc\", config, \"Erosion\", \"VShip\" + istr)\n            setOptParam(istr + \"_nShips\", config, \"Erosion\", \"NShip\" + istr)\n            setOptParam(istr + \"_shipNWaves\", config, \"Erosion\", \"NWave\" + istr)\n            setOptParam(istr + \"_shipDraught\", config, \"Erosion\", \"Draught\" + istr)\n            setOptParam(istr + \"_bankSlope\", config, \"Erosion\", \"Slope\" + istr)\n            setOptParam(istr + \"_bankReed\", config, \"Erosion\", \"Reed\" + istr)\n            txt = config_file.get_str(\"Erosion\", \"EroVol\" + istr, default=\"\")\n            dialog[istr + \"_eroVolEdit\"].setText(txt)\n\n    else:\n        show_error(f\"Unsupported version number {version} in the file {config_path}!\")\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.main","title":"<code>main(config: Optional[Path] = None) -&gt; None</code>","text":"<p>Start the user interface using default settings or optional configuration.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.main--arguments","title":"Arguments","text":"<p>config : Optional[str]     Optional name of configuration file.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def main(config: Optional[Path] = None) -&gt; None:\n    \"\"\"\n    Start the user interface using default settings or optional configuration.\n\n    Arguments\n    ---------\n    config : Optional[str]\n        Optional name of configuration file.\n    \"\"\"\n    gui = GUI()\n    gui.create()\n    if not config is None:\n        load_configuration(config)\n\n    gui.activate()\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.menu_about_qt","title":"<code>menu_about_qt()</code>","text":"<p>Show the about dialog for Qt.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.menu_about_qt--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def menu_about_qt():\n    \"\"\"\n    Show the about dialog for Qt.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    QtWidgets.QApplication.aboutQt()\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.menu_about_self","title":"<code>menu_about_self()</code>","text":"<p>Show the about dialog for D-FAST Bank Erosion.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.menu_about_self--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def menu_about_self():\n    \"\"\"\n    Show the about dialog for D-FAST Bank Erosion.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    msg = QtWidgets.QMessageBox()\n    msg.setText(f\"D-FAST Bank Erosion {__version__}\")\n    msg.setInformativeText(\"Copyright (c) 2025 Deltares.\")\n    msg.setDetailedText(gui_text(\"license\"))\n    msg.setWindowTitle(gui_text(\"about\"))\n    msg.setStandardButtons(QtWidgets.QMessageBox.Ok)\n\n    dfast_icon = get_icon(f\"{ICONS_DIR}/D-FASTBE.png\")\n    available_sizes = dfast_icon.availableSizes()\n    if available_sizes:\n        icon_size = available_sizes[0]\n        pixmap = dfast_icon.pixmap(icon_size).scaled(64,64)\n        msg.setIconPixmap(pixmap)\n    msg.setWindowIcon(dfast_icon)\n    msg.exec()\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.menu_load_configuration","title":"<code>menu_load_configuration() -&gt; None</code>","text":"<p>Select and load a configuration file.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.menu_load_configuration--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def menu_load_configuration() -&gt; None:\n    \"\"\"\n    Select and load a configuration file.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    fil = QtWidgets.QFileDialog.getOpenFileName(\n        caption=\"Select Configuration File\", filter=\"Config Files (*.cfg)\"\n    )\n    filename = fil[0]\n    if filename != \"\":\n        load_configuration(filename)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.menu_open_manual","title":"<code>menu_open_manual()</code>","text":"<p>Open the user manual.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def menu_open_manual():\n    \"\"\"Open the user manual.\"\"\"\n    manual_path = r_dir / USER_MANUAL_FILE_NAME\n    filename = str(manual_path)\n    if not manual_path.exists():\n        show_error(f\"User manual not found: {filename}\")\n        return\n    try:\n        # bandit complains about os.startfile, but it is the only way to open a file in the default application on Windows.\n        # On Linux and MacOS, opening the file might give a security warning.\n        os.startfile(filename) # nosec\n    except Exception as e:\n        show_error(f\"Failed to open the user manual: {e}\")\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.menu_save_configuration","title":"<code>menu_save_configuration() -&gt; None</code>","text":"<p>Ask for a configuration file name and save GUI selection to that file.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.menu_save_configuration--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def menu_save_configuration() -&gt; None:\n    \"\"\"\n    Ask for a configuration file name and save GUI selection to that file.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    fil = QtWidgets.QFileDialog.getSaveFileName(\n        caption=\"Save Configuration As\", filter=\"Config Files (*.cfg)\"\n    )\n    filename = fil[0]\n    if filename != \"\":\n        config = get_configuration()\n        rootdir = os.path.dirname(filename)\n        config_file = ConfigFile(config)\n        config_file.relative_to(rootdir)\n        config.write(filename)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.openFileLayout","title":"<code>openFileLayout(key, enabled=True) -&gt; QtWidgets.QWidget</code>","text":"<p>Create a standard layout with a file or folder edit field and selection button.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.openFileLayout--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter. enabled : bool     Flag indicating whether the file selection button should be enabed by default.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.openFileLayout--returns","title":"Returns","text":"<p>parent : QtWidgets.QWidget     Parent QtWidget that contains the edit field and selection button.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def openFileLayout(key, enabled=True) -&gt; QtWidgets.QWidget:\n    \"\"\"\n    Create a standard layout with a file or folder edit field and selection button.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    enabled : bool\n        Flag indicating whether the file selection button should be enabed by default.\n\n    Returns\n    ------\n    parent : QtWidgets.QWidget\n        Parent QtWidget that contains the edit field and selection button.\n    \"\"\"\n    parent = QtWidgets.QWidget()\n    gridly = QtWidgets.QGridLayout(parent)\n    gridly.setContentsMargins(0, 0, 0, 0)\n\n    myWidget = QtWidgets.QLineEdit()\n    dialog[key] = myWidget\n    gridly.addWidget(myWidget, 0, 0)\n\n    openFile = QPushButton(get_icon(f\"{ICONS_DIR}/open.png\"), \"\")\n    openFile.clicked.connect(lambda: selectFile(key))\n    openFile.setEnabled(enabled)\n    dialog[key + \"File\"] = openFile\n    gridly.addWidget(openFile, 0, 2)\n\n    return parent\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.optionalParLayout","title":"<code>optionalParLayout(gridLayout: QtWidgets.QGridLayout, row: int, key, labelString, selectList=None) -&gt; None</code>","text":"<p>Add a line of controls for editing an optional parameter.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.optionalParLayout--arguments","title":"Arguments","text":"<p>gridLayout : QtWidgets.QGridLayout     Grid layout object in which to position the edit controls. row : int     Grid row number to be used for this parameter. key : str     Short name of the parameter. labelString : str     String describing the parameter to be displayed as label. selectList : Optional[List[str]]     In case the parameter can only have a limited number of values: a list     of strings describing the options.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def optionalParLayout(\n    gridLayout: QtWidgets.QGridLayout, row: int, key, labelString, selectList=None\n) -&gt; None:\n    \"\"\"\n    Add a line of controls for editing an optional parameter.\n\n    Arguments\n    ---------\n    gridLayout : QtWidgets.QGridLayout\n        Grid layout object in which to position the edit controls.\n    row : int\n        Grid row number to be used for this parameter.\n    key : str\n        Short name of the parameter.\n    labelString : str\n        String describing the parameter to be displayed as label.\n    selectList : Optional[List[str]]\n        In case the parameter can only have a limited number of values: a list\n        of strings describing the options.\n    \"\"\"\n    Label = QtWidgets.QLabel(labelString)\n    dialog[key + \"Label\"] = Label\n    gridLayout.addWidget(Label, row, 0)\n\n    paramTypes = (\"Use Default\", \"Constant\", \"Variable\")\n    Type = QtWidgets.QComboBox()\n    Type.addItems(paramTypes)\n    Type.currentIndexChanged.connect(lambda: typeUpdatePar(key))\n    dialog[key + \"Type\"] = Type\n    gridLayout.addWidget(Type, row, 1)\n\n    if selectList is None:\n        fLayout = openFileLayout(key + \"Edit\", enabled=False)\n        dialog[key + \"Edit\"].setEnabled(False)\n        gridLayout.addWidget(fLayout, row, 2)\n    else:\n        Select = QtWidgets.QComboBox()\n        Select.addItems(selectList)\n        Select.setEnabled(False)\n        dialog[key + \"Select\"] = Select\n        gridLayout.addWidget(Select, row, 2)\n\n        fLayout = openFileLayout(key + \"Edit\", enabled=False)\n        dialog[key + \"Edit\"].setEnabled(False)\n        gridLayout.addWidget(fLayout, row + 1, 2)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.removeAnItem","title":"<code>removeAnItem(key: str) -&gt; None</code>","text":"<p>Implements the actions for the remove item button.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.removeAnItem--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def removeAnItem(key: str) -&gt; None:\n    \"\"\"\n    Implements the actions for the remove item button.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    \"\"\"\n    selected = dialog[key].selectedItems()\n    root = dialog[key].invisibleRootItem()\n    if len(selected) &gt; 0:\n        istr = selected[0].text(0)\n        root.removeChild(selected[0])\n        i = int(istr) - 1\n        for j in range(i, root.childCount()):\n            root.child(j).setText(0, str(j + 1))\n    else:\n        istr = \"\"\n    if root.childCount() == 0:\n        dialog[key + \"Edit\"].setEnabled(False)\n        dialog[key + \"Remove\"].setEnabled(False)\n    if istr == \"\":\n        pass\n    elif key == \"searchLines\":\n        pass\n    elif key == \"discharges\":\n        tabs = dialog[\"tabs\"]\n        dialog[\"refLevel\"].validator().setTop(root.childCount())\n        dj = 0\n        for j in range(tabs.count()):\n            if dj &gt; 0:\n                tabs.setTabText(j - 1, \"Level \" + str(j + dj))\n                updateTabKeys(j + dj + 1)\n            elif tabs.tabText(j) == \"Level \" + istr:\n                tabs.removeTab(j)\n                dj = i - j\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.run_detection","title":"<code>run_detection() -&gt; None</code>","text":"<p>Trigger the bank line detection analysis with error handling.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.run_detection--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def run_detection() -&gt; None:\n    \"\"\"\n    Trigger the bank line detection analysis with error handling.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    try_run_and_catch(run_detection_steps)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.run_detection_steps","title":"<code>run_detection_steps(config_file: ConfigFile) -&gt; None</code>","text":"<p>Create bank line detection object and run the analysis.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.run_detection_steps--arguments","title":"Arguments","text":"<p>config : configparser.ConfigParser     Analysis configuration settings.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def run_detection_steps(config_file: ConfigFile) -&gt; None:\n    \"\"\"\n    Create bank line detection object and run the analysis.\n\n    Arguments\n    ---------\n    config : configparser.ConfigParser\n        Analysis configuration settings.\n    \"\"\"\n    bank_line = BankLines(config_file, gui=True)\n    bank_line.detect()\n    bank_line.plot()\n    bank_line.save()\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.run_erosion","title":"<code>run_erosion() -&gt; None</code>","text":"<p>Trigger the bank line erosion analysis with error handling.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.run_erosion--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def run_erosion() -&gt; None:\n    \"\"\"\n    Trigger the bank line erosion analysis with error handling.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    try_run_and_catch(run_erosion_steps)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.run_erosion_steps","title":"<code>run_erosion_steps(config_file: ConfigFile) -&gt; None</code>","text":"<p>Create bank line erosion object and run the analysis.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.run_erosion_steps--arguments","title":"Arguments","text":"<p>config : configparser.ConfigParser     Analysis configuration settings.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def run_erosion_steps(config_file: ConfigFile) -&gt; None:\n    \"\"\"\n    Create bank line erosion object and run the analysis.\n\n    Arguments\n    ---------\n    config : configparser.ConfigParser\n        Analysis configuration settings.\n    \"\"\"\n    erosion = Erosion(config_file, gui=True)\n    erosion.run()\n    erosion.plot()\n    erosion.save()\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.selectFile","title":"<code>selectFile(key: str) -&gt; None</code>","text":"<p>Select a file or directory via a selection dialog.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.selectFile--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def selectFile(key: str) -&gt; None:\n    \"\"\"\n    Select a file or directory via a selection dialog.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    \"\"\"\n    dnm: str\n    if not dialog[key + \"File\"].hasFocus():\n        # in the add/edit dialogs, the selectFile is triggered when the user presses enter in one of the lineEdit boxes ...\n        # don't trigger the actual selectFile\n        fil = \"\"\n    elif key == \"simFileEdit\":\n        fil, fltr = QtWidgets.QFileDialog.getOpenFileName(\n            caption=\"Select D-Flow FM Map File\", filter=\"D-Flow FM Map Files (*map.nc)\"\n        )\n        # getOpenFileName returns a tuple van file name and active file filter.\n    elif key == \"chainFileEdit\":\n        fil, fltr = QtWidgets.QFileDialog.getOpenFileName(\n            caption=\"Select Chainage File\", filter=\"Chainage Files (*.xyc)\"\n        )\n    elif key == \"riverAxisEdit\":\n        fil, fltr = QtWidgets.QFileDialog.getOpenFileName(\n            caption=\"Select River Axis File\", filter=\"River Axis Files (*.xyc)\"\n        )\n    elif key == \"fairwayEdit\":\n        fil, fltr = QtWidgets.QFileDialog.getOpenFileName(\n            caption=\"Select Fairway File\", filter=\"Fairway Files (*.xyc)\"\n        )\n    elif key == \"editSearchLineEdit\":\n        fil, fltr = QtWidgets.QFileDialog.getOpenFileName(\n            caption=\"Select Search Line File\", filter=\"Search Line Files (*.xyc)\"\n        )\n    elif key == \"editDischargeEdit\":\n        fil, fltr = QtWidgets.QFileDialog.getOpenFileName(\n            caption=\"Select Simulation File\", filter=\"Simulation File (*map.nc)\"\n        )\n    elif key == \"bankDirEdit\":\n        fil = QtWidgets.QFileDialog.getExistingDirectory(\n            caption=\"Select Bank Directory\"\n        )\n    elif key == \"figureDirEdit\":\n        fil = QtWidgets.QFileDialog.getExistingDirectory(\n            caption=\"Select Figure Output Directory\"\n        )\n    elif key == \"outDirEdit\":\n        fil = QtWidgets.QFileDialog.getExistingDirectory(\n            caption=\"Select Output Directory\"\n        )\n    else:\n        if key[-4:] == \"Edit\":\n            rkey = key[:-4]\n            nr = \"\"\n            while rkey[0] in \"1234567890\":\n                nr = nr + rkey[0]\n                rkey = rkey[1:]\n            if rkey[0] == \"_\":\n                rkey = rkey[1:]\n            if not nr == \"\":\n                nr = \" for Level \" + nr\n            if rkey == \"bankType\":\n                ftype = \"Bank Type\"\n                ext = \".btp\"\n                oneFile = False\n            elif rkey == \"bankShear\":\n                ftype = \"Critical Shear\"\n                ext = \".btp\"\n                oneFile = False\n            elif rkey == \"bankProtect\":\n                ftype = \"Protection Level\"\n                ext = \".bpl\"\n                oneFile = False\n            elif rkey == \"bankSlope\":\n                ftype = \"Bank Slope\"\n                ext = \".slp\"\n                oneFile = False\n            elif rkey == \"bankReed\":\n                ftype = \"Reed Fraction\"\n                ext = \".rdd\"\n                oneFile = False\n            elif rkey == \"shipType\":\n                ftype = \"Ship Type\"\n                ext = \"\"\n                oneFile = True\n            elif rkey == \"shipVeloc\":\n                ftype = \"Ship Velocity\"\n                ext = \"\"\n                oneFile = True\n            elif rkey == \"nShips\":\n                ftype = \"Number of Ships\"\n                ext = \"\"\n                oneFile = True\n            elif rkey == \"shipNWaves\":\n                ftype = \"Number of Ship Waves\"\n                ext = \"\"\n                oneFile = True\n            elif rkey == \"shipDraught\":\n                ftype = \"Ship Draught\"\n                ext = \"\"\n                oneFile = True\n            elif rkey == \"wavePar0\":\n                ftype = \"Wave0\"\n                ext = \"\"\n                oneFile = True\n            elif rkey == \"wavePar1\":\n                ftype = \"Wave1\"\n                ext = \"\"\n                oneFile = True\n            else:\n                ftype = \"Parameter\"\n                ext = \"*\"\n            ftype = ftype + \" File\"\n            fil, fltr = QtWidgets.QFileDialog.getOpenFileName(\n                caption=\"Select \" + ftype + nr, filter=ftype + \" (*\" + ext + \")\"\n            )\n            if fil != \"\":\n                fil, fext = os.path.splitext(fil)\n                if fext == ext:\n                    if not oneFile:\n                        # file should end on _&lt;nr&gt;\n                        nr = \"\"\n                        while fil[-1] in \"1234567890\":\n                             nr = rkey[-1] + nr\n                             fil = fil[:-1]\n                        if nr == \"\" or fil[-1] != \"_\":\n                            print(\"Missing bank number(s) at end of file name. Reference not updated.\")\n                            fil = \"\"\n                        else:\n                            fil = fil[:-1]\n                else:\n                    if ext == \"\":\n                        print(\"Unsupported file extension {} while expecting no extension. Reference not updated.\".format(fext))\n                    else:\n                        print(\"Unsupported file extension {} while expecting {}. Reference not updated.\".format(fext,ext))\n                    fil = \"\"\n        else:\n            print(key)\n            fil = \"\"\n    if fil != \"\":\n        dialog[key].setText(fil)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.setDialogSize","title":"<code>setDialogSize(editDialog: QtWidgets.QDialog, width: int, height: int) -&gt; None</code>","text":"<p>Set the width and height of a dialog and position it centered relative to the main window.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.setDialogSize--arguments","title":"Arguments","text":"<p>editDialog : QtWidgets.QDialog     Dialog object to be positioned correctly. width : int     Desired width of the dialog. height : int     Desired height of the dialog.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def setDialogSize(editDialog: QtWidgets.QDialog, width: int, height: int) -&gt; None:\n    \"\"\"\n    Set the width and height of a dialog and position it centered relative to the main window.\n\n    Arguments\n    ---------\n    editDialog : QtWidgets.QDialog\n        Dialog object to be positioned correctly.\n    width : int\n        Desired width of the dialog.\n    height : int\n        Desired height of the dialog.\n    \"\"\"\n    parent = dialog[\"window\"]\n    x = parent.x()\n    y = parent.y()\n    pw = parent.width()\n    ph = parent.height()\n    editDialog.setGeometry(\n        x + pw / 2 - width / 2, y + ph / 2 - height / 2, width, height\n    )\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.setFilter","title":"<code>setFilter(field: str, config, group: str, key: str) -&gt; None</code>","text":"<p>Update the dialog for a filter based on configuration file.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.setFilter--arguments","title":"Arguments","text":"<p>field : str     Short name of the parameter. config : configparser.ConfigParser     Configuration for the D-FAST Bank Erosion analysis with absolute or relative paths. group : str     Name of the group in the configuration. key : str     Name of the key in the configuration group.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def setFilter(field: str, config, group: str, key: str) -&gt; None:\n    \"\"\"\n    Update the dialog for a filter based on configuration file.\n\n    Arguments\n    ---------\n    field : str\n        Short name of the parameter.\n    config : configparser.ConfigParser\n        Configuration for the D-FAST Bank Erosion analysis with absolute or relative paths.\n    group : str\n        Name of the group in the configuration.\n    key : str\n        Name of the key in the configuration group.\n\n    \"\"\"\n    config_file = ConfigFile(config)\n    val = config_file.get_float(group, key, 0.0)\n    if val &gt; 0.0:\n        dialog[field + \"Active\"].setChecked(True)\n        dialog[field + \"Width\"].setText(str(val))\n    else:\n        dialog[field + \"Active\"].setChecked(False)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.setOptParam","title":"<code>setOptParam(field: str, config, group: str, key: str) -&gt; None</code>","text":"<p>Update the dialog for an optional parameter based on configuration file.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.setOptParam--arguments","title":"Arguments","text":"<p>field : str     Short name of the parameter. config : configparser.ConfigParser     Configuration for the D-FAST Bank Erosion analysis with absolute or relative paths. group : str     Name of the group in the configuration. key : str     Name of the key in the configuration group.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def setOptParam(field: str, config, group: str, key: str) -&gt; None:\n    \"\"\"\n    Update the dialog for an optional parameter based on configuration file.\n\n    Arguments\n    ---------\n    field : str\n        Short name of the parameter.\n    config : configparser.ConfigParser\n        Configuration for the D-FAST Bank Erosion analysis with absolute or relative paths.\n    group : str\n        Name of the group in the configuration.\n    key : str\n        Name of the key in the configuration group.\n    \"\"\"\n    config_file = ConfigFile(config)\n    str = config_file.get_str(group, key, \"\")\n    if str == \"\":\n        dialog[field + \"Type\"].setCurrentText(\"Use Default\")\n        dialog[field + \"Edit\"].setText(\"\")\n    else:\n        try:\n            val = float(str)\n            dialog[field + \"Type\"].setCurrentText(\"Constant\")\n            if field + \"Select\" in dialog.keys():\n                ival = int(val) - 1  # shipType 1 -&gt; index 0\n                dialog[field + \"Select\"].setCurrentIndex(ival)\n            else:\n                dialog[field + \"Edit\"].setText(str)\n        except:\n            dialog[field + \"Type\"].setCurrentText(\"Variable\")\n            dialog[field + \"Edit\"].setText(str)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.setParam","title":"<code>setParam(field: str, config, group: str, key: str, default: str = '??') -&gt; None</code>","text":"<p>Update the dialog for a general parameter based on configuration file.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.setParam--arguments","title":"Arguments","text":"<p>field : str     Short name of the parameter. config : configparser.ConfigParser     Configuration for the D-FAST Bank Erosion analysis with absolute or relative paths. group : str     Name of the group in the configuration. key : str     Name of the key in the configuration group. default : str     Default string if the group/key pair doesn't exist in the configuration.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def setParam(field: str, config, group: str, key: str, default: str = \"??\") -&gt; None:\n    \"\"\"\n    Update the dialog for a general parameter based on configuration file.\n\n    Arguments\n    ---------\n    field : str\n        Short name of the parameter.\n    config : configparser.ConfigParser\n        Configuration for the D-FAST Bank Erosion analysis with absolute or relative paths.\n    group : str\n        Name of the group in the configuration.\n    key : str\n        Name of the key in the configuration group.\n    default : str\n        Default string if the group/key pair doesn't exist in the configuration.\n\n    \"\"\"\n    config_file = ConfigFile(config)\n    config_value = config_file.get_str(group, key, default)\n\n    try:\n        val = float(config_value)\n        cast(QComboBox, dialog[field + \"Type\"]).setCurrentText(\"Constant\")\n        if field + \"Select\" in dialog.keys():\n            int_value = int(val)\n            if field == \"shipType\":\n                int_value = int_value - 1\n            cast(QComboBox, dialog[field + \"Select\"]).setCurrentIndex(int_value)\n        else:\n            cast(QLineEdit, dialog[field + \"Edit\"]).setText(config_value)\n    except:\n        cast(QComboBox, dialog[field + \"Type\"]).setCurrentText(\"Variable\")\n        cast(QLineEdit, dialog[field + \"Edit\"]).setText(config_value)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.show_error","title":"<code>show_error(message: str, detailed_message: Optional[str] = None) -&gt; None</code>","text":"<p>Display an error message box with specified string.</p> <p>Parameters:</p> Name Type Description Default <code>message </code> <p>str Text to be displayed in the message box.</p> required <code>detailed_message </code> <p>Option[str] Text to be displayed when the user clicks the Details button.</p> required Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def show_error(message: str, detailed_message: Optional[str] = None) -&gt; None:\n    \"\"\"Display an error message box with specified string.\n\n    Args:\n        message : str\n            Text to be displayed in the message box.\n        detailed_message : Option[str]\n            Text to be displayed when the user clicks the Details button.\n    \"\"\"\n    msg = QtWidgets.QMessageBox()\n    msg.setIcon(QtWidgets.QMessageBox.Critical)\n    msg.setText(message)\n    if detailed_message:\n        msg.setDetailedText(detailed_message)\n    msg.setWindowTitle(\"Error\")\n    msg.setStandardButtons(QtWidgets.QMessageBox.Ok)\n    msg.exec()\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.try_run_and_catch","title":"<code>try_run_and_catch(run_analysis_steps: Callable[[ConfigFile], None]) -&gt; None</code>","text":"<p>Run an analysis based on settings in the GUI.</p> <p>Use a dummy configuration name in the current work directory to create relative paths.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.try_run_and_catch--arguments","title":"Arguments","text":"<p>run_analysis_steps : Callable[[configparser.ConfigParser], None]     function containing the plain analysis steps</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def try_run_and_catch(run_analysis_steps: Callable[[ConfigFile], None]) -&gt; None:\n    \"\"\"\n    Run an analysis based on settings in the GUI.\n\n    Use a dummy configuration name in the current work directory to create\n    relative paths.\n\n    Arguments\n    ---------\n    run_analysis_steps : Callable[[configparser.ConfigParser], None]\n        function containing the plain analysis steps\n    \"\"\"\n    config = get_configuration()\n    rootdir = os.getcwd()\n    config_file = ConfigFile(config)\n    config_file.root_dir = rootdir\n    config_file.relative_to(rootdir)\n    dialog[\"application\"].setOverrideCursor(QtCore.Qt.WaitCursor)\n    plt.close(\"all\")\n    # should maybe use a separate thread for this ...\n    try:\n        run_analysis_steps(config_file)\n    except (SystemExit, KeyboardInterrupt) as exception:\n        raise exception\n    except:\n        dialog[\"application\"].restoreOverrideCursor()\n        stack_trace = traceback.format_exc()\n        show_error(\n            \"A run-time exception occurred. Press 'Show Details...' for the full stack trace.\",\n            stack_trace,\n        )\n    else:\n        dialog[\"application\"].restoreOverrideCursor()\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.typeUpdatePar","title":"<code>typeUpdatePar(key: str) -&gt; None</code>","text":"<p>Implements the dialog setting switching for both general and optional parameters.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.typeUpdatePar--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def typeUpdatePar(key: str) -&gt; None:\n    \"\"\"\n    Implements the dialog setting switching for both general and optional parameters.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    \"\"\"\n    type = dialog[key + \"Type\"].currentText()\n    dialog[key + \"Edit\"].setText(\"\")\n    if type == \"Use Default\":\n        dialog[key + \"Edit\"].setValidator(None)\n        dialog[key + \"Edit\"].setEnabled(False)\n        dialog[key + \"EditFile\"].setEnabled(False)\n        if key + \"Select\" in dialog.keys():\n            dialog[key + \"Select\"].setEnabled(False)\n    elif type == \"Constant\":\n        if key + \"Select\" in dialog.keys():\n            dialog[key + \"Select\"].setEnabled(True)\n            dialog[key + \"Edit\"].setEnabled(False)\n        else:\n            if key != \"bankProtect\":\n                dialog[key + \"Edit\"].setValidator(validator(\"positive_real\"))\n            dialog[key + \"Edit\"].setEnabled(True)\n        dialog[key + \"EditFile\"].setEnabled(False)\n    elif type == \"Variable\":\n        if key + \"Select\" in dialog.keys():\n            dialog[key + \"Select\"].setEnabled(False)\n        dialog[key + \"Edit\"].setEnabled(True)\n        dialog[key + \"Edit\"].setValidator(None)\n        dialog[key + \"EditFile\"].setEnabled(True)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.updateFilter","title":"<code>updateFilter(key: str) -&gt; None</code>","text":"<p>Implements the dialog setting switching for both general and optional parameters.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.updateFilter--arguments","title":"Arguments","text":"<p>key : str     Short name of the parameter.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def updateFilter(key: str) -&gt; None:\n    \"\"\"\n    Implements the dialog setting switching for both general and optional parameters.\n\n    Arguments\n    ---------\n    key : str\n        Short name of the parameter.\n    \"\"\"\n    if dialog[key + \"Active\"].isChecked():\n        dialog[key + \"Width\"].setEnabled(True)\n    else:\n        dialog[key + \"Width\"].setEnabled(False)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.updatePlotting","title":"<code>updatePlotting() -&gt; None</code>","text":"<p>Update the plotting flags.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.updatePlotting--arguments","title":"Arguments","text":"<p>None</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def updatePlotting() -&gt; None:\n    \"\"\"\n    Update the plotting flags.\n\n    Arguments\n    ---------\n    None\n    \"\"\"\n    plotFlag = dialog[\"makePlotsEdit\"].isChecked()\n    dialog[\"savePlots\"].setEnabled(plotFlag)\n    dialog[\"savePlotsEdit\"].setEnabled(plotFlag)\n\n    saveFlag = dialog[\"savePlotsEdit\"].isChecked() and plotFlag\n    dialog[\"saveZoomPlots\"].setEnabled(saveFlag)\n    dialog[\"saveZoomPlotsEdit\"].setEnabled(saveFlag)\n\n    saveZoomFlag = dialog[\"saveZoomPlotsEdit\"].isChecked() and saveFlag\n    dialog[\"zoomPlotsRangeTxt\"].setEnabled(saveZoomFlag)\n    dialog[\"zoomPlotsRangeEdit\"].setEnabled(saveZoomFlag)\n\n    dialog[\"figureDir\"].setEnabled(saveFlag)\n    dialog[\"figureDirEdit\"].setEnabled(saveFlag)\n    dialog[\"figureDirEditFile\"].setEnabled(saveFlag)\n\n    dialog[\"closePlots\"].setEnabled(plotFlag)\n    dialog[\"closePlotsEdit\"].setEnabled(plotFlag)\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.updateTabKeys","title":"<code>updateTabKeys(i: int) -&gt; None</code>","text":"<p>Renumber tab i to tab i-1.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.updateTabKeys--arguments","title":"Arguments","text":"<p>i : str     Number of the tab to be updated.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def updateTabKeys(i: int) -&gt; None:\n    \"\"\"\n    Renumber tab i to tab i-1.\n\n    Arguments\n    ---------\n    i : str\n        Number of the tab to be updated.\n    \"\"\"\n    iStart = str(i) + \"_\"\n    newStart = str(i - 1) + \"_\"\n    N = len(iStart)\n    keys = [key for key in dialog.keys() if key[:N] == iStart]\n    for key in keys:\n        obj = dialog.pop(key)\n        if key[-4:] == \"Type\":\n            obj.currentIndexChanged.disconnect()\n            obj.currentIndexChanged.connect(\n                lambda: typeUpdatePar(newStart + key[N:-4])\n            )\n        elif key[-4:] == \"File\":\n            obj.clicked.disconnect()\n            obj.clicked.connect(lambda: selectFile(newStart + key[N:-4]))\n        dialog[newStart + key[N:]] = obj\n</code></pre>"},{"location":"gui/gui.html#dfastbe.gui.gui.validator","title":"<code>validator(validstr: str) -&gt; QtGui.QValidator</code>","text":"<p>Wrapper to easily create a validator.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.validator--arguments","title":"Arguments","text":"<p>validstr : str     Identifier for the requested validation method.</p>"},{"location":"gui/gui.html#dfastbe.gui.gui.validator--returns","title":"Returns","text":"<p>validator : QtGui.QValidator     Validator for the requested validation method.</p> Source code in <code>src/dfastbe/gui/gui.py</code> <pre><code>def validator(validstr: str) -&gt; QtGui.QValidator:\n    \"\"\"\n    Wrapper to easily create a validator.\n\n    Arguments\n    ---------\n    validstr : str\n        Identifier for the requested validation method.\n\n    Returns\n    -------\n    validator : QtGui.QValidator\n        Validator for the requested validation method.\n    \"\"\"\n    if validstr == \"positive_real\":\n        validator = QtGui.QDoubleValidator()\n        validator.setBottom(0)\n    else:\n        raise ValueError(f\"Unknown validator type: {validstr}\")\n    return validator\n</code></pre>"},{"location":"guides/contributing.html","title":"Contributing","text":""},{"location":"guides/contributing.html#tooling","title":"Tooling","text":""},{"location":"guides/contributing.html#poetry","title":"Poetry","text":"<p>We use <code>poetry</code> to manage our package and its dependencies. More information on the separate Poetry page.</p>"},{"location":"guides/contributing.html#pytest","title":"Pytest","text":"<p>We use <code>pytest</code> to test our package. Run it with <code>poetry run pytest</code> to test your code changes locally.</p>"},{"location":"guides/contributing.html#black","title":"Black","text":"<p>We use <code>black</code> as an autoformatter. It is also run during CI and will fail if it's not formatted beforehand.</p>"},{"location":"guides/contributing.html#isort","title":"Isort","text":"<p>We use <code>isort</code> as an autoformatter.</p>"},{"location":"guides/contributing.html#commitizen","title":"Commitizen","text":"<ul> <li>We use <code>commitizen</code> to automatically bump the version number.</li> <li>If you use conventional commit messages, the <code>change-log.md</code> is generated automatically. More details below under \"Merging\".</li> </ul>"},{"location":"guides/contributing.html#development","title":"Development","text":""},{"location":"guides/contributing.html#branches","title":"Branches","text":"<p>For each issue or feature, a separate branch should be created from the main. To keep the branches organized each branch should be created with a prefix in the name: * <code>feat/</code> for new features and feature improvements; * <code>fix/</code> for bugfixes; * <code>docs/</code> for documentation; * <code>chore/</code> for tasks, tool changes, configuration work, everything not relevant for external users.</p> <p>After this prefix, preferrably add the issue number, followed by a brief title using underscores. For example: <code>feat/160_obsfile</code> or, <code>fix/197_validation_pump_stages</code>.</p>"},{"location":"guides/contributing.html#pull-requests","title":"Pull requests","text":"<p>When starting development on a branch, a pull request should be created for reviews and continous integration. In the description text area on GitHub, use a closing keyword such that this PR will be automatically linked to the issue. For example: <code>Fixes #160</code>.</p> <p>During continuous integration, the checks will be run with several Python versions on Windows, Ubuntu and MacOS. The checks consist of running the tests, checking the code formatting and running SonarCloud. We advise to use a draft pull request, to prevent the branch to be merged back before developement is finished. When the branch is ready for review, you can update the status of the pull request to \"ready for review\".</p>"},{"location":"guides/contributing.html#reviews","title":"Reviews","text":"<p>When an issue is ready for review, it should be moved to the \"Ready for review\" column on the GitHub board for visibility.</p>"},{"location":"guides/contributing.html#merging","title":"Merging","text":"<p>Merging a branch can only happen when a pull request is accepted through review. When a pull request is accepted the changes should be merged back with the \"squash and merge\" option. The merge commit message should adhere to the conventional commit guidelines. * In the first textfield of the GitHub commit form, use for example: <code>feat: Support 3D timeseries in .bc file</code>, without any PR/issue references. * In the text area of the GitHub commit form, optionally add some more description details on the commit. * In the same text area, add footer line <code>Refs: #&lt;issuenr&gt;</code>, and if needed an extra line <code>BREAKING CHANGE: explanation</code>. Don't forget a blank line between footer lines and the preceding description lines (if present).</p>"},{"location":"guides/contributing.html#coding-guidelines","title":"Coding guidelines","text":"<ul> <li>If there is code that needs to be tested, there should be tests written for it.</li> <li>If there are any additions or changes to the public API, the documentation should be updated.</li> <li>Files should be added to the appropriate folder to keep modules and objects within the correct scope.</li> </ul>"},{"location":"guides/contributing.html#releasing","title":"Releasing","text":""},{"location":"guides/contributing.html#making-a-release-on-github-and-pypi","title":"Making a release on GitHub and PyPi","text":"<p>When we are releasing D-FAST_Bank_Erosion, we want to create a release on GitHub and PyPi. This should only be done by one of the D-FAST_Bank_Erosion maintainers. To prepare for releasing, please make sure you have a clean checkout of the latest <code>main</code> branch and follow these steps:</p> <ul> <li>Go to the root level of your D-FAST_Bank_Erosion checkout location</li> <li>Open your command line in this location</li> <li>Perform the following commands:<ul> <li>If commitizen is not installed yet:  <pre><code>pip install commitizen\n</code></pre></li> <li>Prepare the Changelog before bumping the release version:  <pre><code>cz changelog --unreleased-version=\"0.3.1\" --incremental\n</code></pre>  In the above command, use the version tag instead of the raw version number (so without \"v\" in our case).  If you don't know the version tag yet, you can do a dry-run of the next step, for example via:  <pre><code>cz bump --dry-run --increment PATCH\n</code></pre></li> <li>In the updated <code>docs/mkdocs/change-log.md</code>, manually add links to GitHub PR numbers (or issue numbers) at the     end of each line, if appropriate.      It is recommended to use the macros <code>{{gh_pr(123)}}</code>, resp. <code>{{gh_issue(345)}}</code> to get automatic hyperlinks (where 123 and 345 are GitHub's PR and issue numbers, respectively).</li> <li>Use MAJOR, MINOR or PATCH to increment the version  <pre><code>cz bump --increment {MAJOR,MINOR,PATCH}\n</code></pre></li> <li>Or let commitizen detect the increment automatically  <pre><code>cz bump\n</code></pre></li> <li>Push the tags and changes to git  <pre><code>git push --tags\ngit push\n</code></pre></li> <li>Build the wheels and publish the package to PyPi  <pre><code>poetry build\npoetry publish\n</code></pre>  You will need a PyPI account and permissions for this publish step. Ask a maintainer for help if you need this.</li> </ul> </li> <li>Go to the D-FAST_Bank_Erosion GitHub page.</li> <li>Go to <code>Releases</code> and click on <code>Draft a new release</code>.</li> <li>Fill in the <code>Release title</code> field with <code>Release v&lt;VERSION&gt;</code>, with <code>&lt;VERSION&gt;</code> in the full format <code>&lt;MAJOR&gt;.&lt;MINOR&gt;.&lt;PATCH&gt;</code>, for example <code>Release v0.3.0</code>.</li> <li>Choose the appropriate version tag in the <code>Choose a tag</code> dropdown box (typically <code>&lt;VERSION&gt;</code> without \"v\" prefix).</li> <li>Click on <code>Generate release notes</code>.</li> <li>Click on <code>Publish release</code>.</li> <li>Celebrate </li> </ul>"},{"location":"guides/developer-instructions.html","title":"Developer Instructions","text":"<p>Instructions coding guidelines for contributing to this repository. How to contribute Pre-Commit Hooks: Instructions on setting up and using pre-commit hooks for this repository.</p>"},{"location":"guides/doctest.html","title":"Docstrings and Doctest","text":"<p>Proper documentation is essential for code readability and maintainability. This guide explains how to write docstrings using the Google style and test them using <code>doctest</code>.</p>"},{"location":"guides/doctest.html#1-writing-docstrings-in-google-style","title":"1. Writing Docstrings in Google Style","text":"<p>Google style docstrings are a clean and readable way to document your code. Here is a breakdown of the format:</p>"},{"location":"guides/doctest.html#example-docstring","title":"Example Docstring","text":"<pre><code>def add_numbers(a: int, b: int) -&gt; int:\n    \"\"\"\n    Add two numbers.\n\n    Args:\n        a (int): The first number.\n        b (int): The second number.\n\n    Returns:\n        int: The sum of the two numbers.\n\n    Examples:\n        &gt;&gt;&gt; add_numbers(1, 2)\n        3\n        &gt;&gt;&gt; add_numbers(-1, 5)\n        4\n    \"\"\"\n    return a + b\n</code></pre>"},{"location":"guides/doctest.html#key-sections-of-a-google-style-docstring","title":"Key Sections of a Google Style Docstring","text":"<ol> <li>Summary: A short description of the function.</li> <li>Args: A list of all parameters with their types and descriptions.</li> <li>Returns: A description of the return value(s).</li> <li>Raises (optional): A list of exceptions the function may raise.</li> <li>Examples: Code examples demonstrating how to use the function.</li> </ol>"},{"location":"guides/doctest.html#additional-notes","title":"Additional Notes","text":"<ul> <li>Use <code>\"\"\"</code> for multi-line docstrings.</li> <li>Align descriptions for readability.</li> <li>Keep the summary concise and to the point.</li> </ul>"},{"location":"guides/doctest.html#2-testing-docstrings-with-doctest","title":"2. Testing Docstrings with Doctest","text":"<p><code>doctest</code> allows you to test the examples provided in your docstrings.</p>"},{"location":"guides/doctest.html#running-doctests","title":"Running Doctests","text":"<ol> <li>Save your code with properly formatted docstrings.</li> <li>Use the following command to run <code>doctest</code>:</li> </ol> <pre><code>python -m doctest -v your_script.py\n</code></pre> <p>The <code>-v</code> flag provides verbose output, showing which tests passed or failed.</p>"},{"location":"guides/doctest.html#example-script-with-doctest","title":"Example Script with Doctest","text":"<pre><code>def multiply_numbers(a: int, b: int) -&gt; int:\n    \"\"\"\n    Multiply two numbers.\n\n    Args:\n        a (int): The first number.\n        b (int): The second number.\n\n    Returns:\n        int: The product of the two numbers.\n\n    Examples:\n        &gt;&gt;&gt; multiply_numbers(2, 3)\n        6\n        &gt;&gt;&gt; multiply_numbers(-1, 5)\n        -5\n        &gt;&gt;&gt; multiply_numbers(0, 10)\n        0\n    \"\"\"\n    return a * b\n</code></pre>"},{"location":"guides/doctest.html#common-commands","title":"Common Commands","text":"<ul> <li>Run all tests: Run the script with doctest as shown above.</li> <li>Check specific failures: Look at the detailed output to understand why a test failed.</li> </ul>"},{"location":"guides/doctest.html#3-debugging-and-troubleshooting","title":"3. Debugging and Troubleshooting","text":"<ol> <li>Ensure your examples in the docstring match the actual output exactly (including whitespace).</li> <li>Use the <code># doctest: +SKIP</code> directive to skip examples that should not be tested:</li> </ol> <pre><code>&gt;&gt;&gt; some_function()  # doctest: +SKIP\n</code></pre> <ol> <li>If you encounter issues with floating-point numbers, use the <code># doctest: +ELLIPSIS</code> directive to allow partial matching:</li> </ol> <pre><code>&gt;&gt;&gt; divide_numbers(1, 3)\n0.333...  # doctest: +ELLIPSIS\n</code></pre>"},{"location":"guides/doctest.html#4-best-practices","title":"4. Best Practices","text":"<ul> <li>Write examples for edge cases (e.g., zero, negative numbers, large inputs).</li> <li>Ensure all public functions, methods, and classes have docstrings.</li> <li>Regularly run <code>doctest</code> to ensure your examples remain up to date.</li> </ul>"},{"location":"guides/doctest.html#5-additional-resources","title":"5. Additional Resources","text":"<ul> <li>Google Python Style Guide: Docstrings</li> <li>Python Doctest Documentation</li> </ul> <p>By following these guidelines, you can ensure your code is both well-documented and well-tested. Thank you for contributing!</p>"},{"location":"guides/documentation.html","title":"Documentation","text":"<p>We use MKdocs for documentation. For full documentation visit mkdocs.org.</p> <p>The documentation itself is written with https://documentation.divio.com/ structure in mind, creating different categories: - Guides - Tutorials - Reference - Topics</p>"},{"location":"guides/documentation.html#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"guides/documentation.html#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"guides/poetry.html","title":"Installation using Poetry","text":"<p>You can use a Poetry-based installation if you are using D-FAST_Bank_Erosion from a local clone of the Github repository, for example if you intend to contribute to the code.</p>"},{"location":"guides/poetry.html#clone-the-github-repo","title":"Clone the GitHub repo","text":"<p>Use your own preferred way of cloning the GitHub repository of D-FAST_Bank_Erosion. In the examples below it is placed in <code>C:\\checkouts\\D-FAST_Bank_Erosion_git</code>.</p>"},{"location":"guides/poetry.html#use-poetry-to-install-d-fast_bank_erosion","title":"Use Poetry to install D-FAST_Bank_Erosion","text":"<p>We use <code>poetry</code> to manage our package and its dependencies.</p> <p>Note</p> <p>If you use <code>conda</code>, do not combine conda virtual environments with the poetry virtual environment. In other words, run the <code>poetry install</code> command from the <code>base</code> conda environment.</p> <ol> <li>Download + installation instructions for Poetry are here.</li> <li> <p>After installation of Poetry itself, now use it to install your local clone of the D-FAST_Bank_Erosion package, as follows.    Make sure Poetry is available on your <code>PATH</code> and run <code>poetry install</code> in the D-FAST_Bank_Erosion directory in your shell of choice.    This will create a virtual environment in which D-FAST_Bank_Erosion is installed and made available for use in your own scripts.    For example in an Anaconda PowerShell: <pre><code>(base) PS C:\\checkouts\\D-FAST_Bank_Erosion_git&gt; poetry install\nCreating virtualenv D-FAST_Bank_Erosion-kHkQBdtS-py3.8 in C:\\Users\\dam_ar\\AppData\\Local\\pypoetry\\Cache\\virtualenvs\nInstalling dependencies from lock file\n\nPackage operations: 67 installs, 0 updates, 0 removals\n\n  * Installing six (1.16.0)\n[..]\nInstalling the current project: D-FAST_Bank_Erosion (0.1.5)\n(base) PS C:\\checkouts\\D-FAST_Bank_Erosion_git&gt;\n</code></pre>    If you need to use an already existing Python installation, you can activate it and run <code>poetry env use system</code> before <code>poetry install</code>.</p> </li> <li> <p>Test your installation, by running the D-FAST_Bank_Erosion pytest suite via poetry: <pre><code>(base) PS C:\\checkouts\\D-FAST_Bank_Erosion_git&gt; poetry run pytest\n===================================== test session starts ======================================\nplatform win32 -- Python 3.8.8, pytest-6.2.5, py-1.10.0, pluggy-1.0.0\nrootdir: C:\\checkouts\\D-FAST_Bank_Erosion_git, configfile: pyproject.toml\nplugins: cov-2.12.1\ncollected 473 items / 2 deselected / 471 selected\n\ntests\\io\\dflowfm\\ini\\test_ini.py ........................................................ [  3%]\ntests\\io\\dflowfm\\test_bc.py ....                                                          [  4%]\ntests\\io\\dflowfm\\test_ext.py ........................................................     [  5%]\ntests\\io\\dflowfm\\test_fnm.py ..................                                           [ 11%]\ntests\\io\\dflowfm\\test_net.py ............                                                 [ 11%]\ntests\\io\\dflowfm\\test_parser.py .                                                         [ 12%]\ntests\\io\\dflowfm\\test_polyfile.py ........................................................[ 23%]\n....................................                                                      [ 27%]\ntests\\io\\dflowfm\\test_structure.py .......................................................[ 42%]\n.........................................................                                 [ 54%]\ntests\\io\\dimr\\test_dimr.py ...                                                            [ 56%]\ntests\\io\\rr\\meteo\\test_bui.py ...........................                                 [ 57%]\ntests\\io\\test_docker.py .                                                                 [ 70%]\ntests\\test_model.py ...............                                                       [ 78%]\ntests\\test_utils.py .......                                                               [ 91%]\n.........................................                                                 [100%]\n\n============================== 471 passed, 2 deselected in 3.50s ===============================\n(base) PS C:\\checkouts\\D-FAST_Bank_Erosion_git&gt;\n</code></pre></p> </li> <li>Start using D-FAST_Bank_Erosion. You can launch your favourite editor (for example VS Code) by first starting a poetry shell with the virtual D-FAST_Bank_Erosion environment: <pre><code>(base) PS C:\\checkouts\\D-FAST_Bank_Erosion_git&gt; poetry shell\n(base) PS C:\\checkouts\\D-FAST_Bank_Erosion_git&gt; code\n</code></pre></li> </ol>"},{"location":"guides/poetry.html#switching-between-python-versions","title":"Switching Between Python Versions","text":"<p>If you need to switch between Python versions (e.g., from Python 3.9 to Python 3.10), you can configure Poetry to use a specific Python version. Follow these steps:</p> <ol> <li> <p>Verify python version in <code>pyproject.toml</code>: The <code>pyproject.toml</code> specifies which python version is supported. Please verify that the python version you wish to use is supported. For example, the following configuration: <pre><code>[tool.poetry.dependencies]\npython = \"~3.10\"\n</code></pre> It Indicates that the project supports Python 3.10 with any minor version (e.g., 3.10.1, 3.10.2, etc.).</p> </li> <li> <p>Check Installed Python Versions: Ensure that the desired Python version (e.g., Python 3.10) is installed on your system.  You can check the available versions by running: on windows: <pre><code>python --version\n</code></pre> or on Linux: <pre><code>python3 --version \n</code></pre></p> </li> <li> <p>Set the Python Version for Poetry: Use the <code>poetry env use</code> command to specify the Python version for your project. For example: <code>poetry env use python3.10</code>. This will create a new virtual environment using Python 3.10.</p> </li> <li> <p>Verify the Python Version: After setting the Python version, verify that Poetry is using the correct version: <code>poetry run python --version</code>. The output should show Python 3.10.</p> </li> <li> <p>Reinstall Dependencies: If you switch Python versions, you may need to reinstall your dependencies. Run: <code>poetry install</code>.</p> </li> <li> <p>Test the Installation: Run the test suite to ensure everything works correctly with the new Python version:  <code>poetry run pytest</code>.</p> </li> </ol>"},{"location":"guides/pre-commit-hooks.html","title":"Pre-Commit Hooks","text":"<p>The pre-commit hooks tool is integrated into this repository to automate code quality checks, formatting, and validation before committing changes. These hooks enforce consistency and ensure that only well-validated code is committed, improving overall codebase quality.</p>"},{"location":"guides/pre-commit-hooks.html#features-of-pre-commit-hooks","title":"Features of Pre-Commit Hooks","text":"<ul> <li>Automated Validation: Validates file formats, YAML/JSON structure, and checks for large files or trailing whitespace.</li> <li>Code Formatting: Automatically formats Python code using <code>black</code> and organizes imports with <code>isort</code>.</li> <li>Static Analysis: Enforces linting rules using <code>flake8</code> and additional plugins for advanced checks.</li> <li>Security Checks: Detects private keys and merge conflicts in committed code.</li> <li>Test Integration: Runs <code>pytest</code> for code and documentation tests, ensuring no regression in functionality.</li> </ul>"},{"location":"guides/pre-commit-hooks.html#configured-hooks","title":"Configured Hooks","text":"<p>Some of the key hooks configured for this repository include: - File Formatting and Cleanup:     - Trim trailing whitespace.     - Fix file encodings.     - Validate YAML and JSON files. - Code Linting and Formatting:     - <code>black</code> for consistent Python code style.     - <code>isort</code> for sorting imports.     - <code>flake8</code> for linting. - Testing:     - Runs unit tests and checks coverage using <code>pytest</code>.     - Validates Jupyter notebooks (<code>nbval</code>).     - Ensures all Python docstrings follow conventions (<code>doctest</code>). - Git and Metadata Checks:     - Ensures commits are not directly made to protected branches (e.g., <code>main</code>).     - Verifies commit messages are well-formed.</p>"},{"location":"guides/pre-commit-hooks.html#how-to-use-pre-commit-hooks","title":"How to Use Pre-Commit Hooks","text":"<p>Pre-commit hooks are an excellent way to ensure code quality and consistency before committing changes to the repository. This guide explains how to set up and use pre-commit hooks for this repository.</p>"},{"location":"guides/pre-commit-hooks.html#1-install-pre-commit","title":"1. Install Pre-Commit","text":"<p>Before you begin, ensure you have Python installed on your system. all the necessary packages for pre-commit hooks to work are listed as a separate dependency group in the pyproject.toml <code>pre-commit</code>. Follow these steps to install pre-commit:</p> <pre><code>poetry install --with pre-commit\n</code></pre>"},{"location":"guides/pre-commit-hooks.html#2-install-git-and-clone-the-repository","title":"2. Install Git and Clone the Repository","text":"<p>Ensure that Git is installed on your system. Then, clone the repository:</p> <pre><code>git clone &lt;repository_url&gt;\ncd &lt;repository_name&gt;\n</code></pre>"},{"location":"guides/pre-commit-hooks.html#3-install-pre-commit-hooks","title":"3. Install Pre-Commit Hooks","text":"<p>To set up the pre-commit hooks defined in the repository's configuration file:</p> <pre><code>pre-commit install\n</code></pre> <p>This command installs the hooks so they run automatically every time you create a commit.</p>"},{"location":"guides/pre-commit-hooks.html#4-run-pre-commit-hooks-manually-optional","title":"4. Run Pre-Commit Hooks Manually (Optional)","text":"<p>You can also run the pre-commit hooks manually to test your changes before committing:</p> <pre><code>pre-commit run --all-files\n</code></pre> <p>This will run all the hooks against the files in the repository.</p>"},{"location":"guides/pre-commit-hooks.html#5-configure-the-pre-commit-hooks","title":"5. Configure the Pre-Commit Hooks","text":"<p>The repository includes a <code>.pre-commit-config.yaml</code> file, which defines the hooks to be executed. If you need to modify the hooks, edit this file and reinstall the hooks:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"guides/pre-commit-hooks.html#example-pre-commit-configyaml-file","title":"Example <code>.pre-commit-config.yaml</code> File","text":"<p>Here is an example configuration file for common hooks:</p> <pre><code>repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.4.0  # Use the latest stable version\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n      - id: check-yaml\n      - id: check-added-large-files\n  - repo: https://github.com/psf/black\n    rev: 23.1.0\n    hooks:\n      - id: black\n  - repo: https://github.com/pycqa/flake8\n    rev: 6.1.0\n    hooks:\n      - id: flake8\n</code></pre>"},{"location":"guides/pre-commit-hooks.html#6-debugging-and-troubleshooting","title":"6. Debugging and Troubleshooting","text":"<p>If you encounter issues with pre-commit hooks:</p> <ol> <li>Ensure all dependencies required by the hooks are installed.</li> <li>Use the <code>--verbose</code> flag to get detailed output:</li> </ol> <p><pre><code>pre-commit run --all-files --verbose\n</code></pre> 3. Check the official documentation for each specific hook if errors persist.</p>"},{"location":"guides/pre-commit-hooks.html#7-best-practices","title":"7. Best Practices","text":"<ul> <li>Always run the hooks manually if you suspect your changes may not comply with repository standards.</li> <li>Avoid skipping hooks unless absolutely necessary. If skipping is required, use the following command to bypass hooks:</li> </ul> <pre><code>git commit --no-verify\n</code></pre> <ul> <li>Periodically update the hooks by running:</li> </ul> <pre><code>pre-commit autoupdate\n</code></pre>"},{"location":"guides/pre-commit-hooks.html#8-uninstall-hooks","title":"8. Uninstall Hooks:","text":"<ul> <li>To remove pre-commit hooks from your repository, run:</li> </ul> <p><pre><code>pre-commit uninstall\n</code></pre>    This will remove the hooks from the repository.</p>"},{"location":"guides/pre-commit-hooks.html#9-additional-resources","title":"9. Additional Resources","text":"<ul> <li>Pre-Commit Documentation</li> <li>Available Hooks</li> </ul> <p>By following these guidelines, you'll help maintain a clean, consistent, and high-quality codebase. Thank you for contributing!</p>"},{"location":"guides/teamcity-ci.html","title":"Teamcity ci","text":""},{"location":"guides/teamcity-ci.html#description-of-files-in-the-teamcity-pipelines","title":"Description of Files in the TeamCity pipelines","text":"<p>The <code>.teamcity/DFastBETests</code> folder contains Kotlin DSL configuration files for defining and managing TeamCity build configurations, templates, and dependencies for the D-FAST Bank Erosion project. Below is a description of each file as currently implemented:</p>"},{"location":"guides/teamcity-ci.html#1-settingskts","title":"1. <code>settings.kts</code>","text":"<p>Purpose: The main entry point for the TeamCity Kotlin DSL configuration. Defines the project structure, parameters, and references to build configurations and templates.</p> <p>Key Features: - Sets the project description and version. - Includes global parameters like <code>python.version</code>, and <code>poetry.path</code>. - References build configurations such as <code>UnitTests</code>, <code>BuildMain</code>, <code>BuildTerminal</code>, <code>LatexManual</code>, <code>SignedRelease</code>, <code>SignedReleaseTerminal</code>, and <code>TestBinaries</code>.</p>"},{"location":"guides/teamcity-ci.html#2-poetry_templatekt","title":"2. <code>poetry_template.kt</code>","text":"<p>Purpose: Provides a reusable template for all builds using Poetry for dependency management and environment setup.</p> <p>Key Features: - Installs Poetry standalone in a temporary directory. - Creates and manages a Poetry environment using the specified Python version. - Installs dependencies via Poetry. - Cleans up the Poetry environment after the build. - Ensures builds run only on Windows agents with the required Python path.</p>"},{"location":"guides/teamcity-ci.html#3-unit_testskt","title":"3. <code>unit_tests.kt</code>","text":"<p>Purpose: Defines the build configuration for running unit tests and (optionally) SonarCloud analysis.</p> <p>Key Features: - Uses the Poetry template for environment setup. - Runs unit tests and generates coverage reports. - (Optionally) runs SonarCloud analysis (step is present but disabled by default). - Publishes commit statuses to GitHub.</p>"},{"location":"guides/teamcity-ci.html#4-build_mainkt","title":"4. <code>build_main.kt</code>","text":"<p>Purpose: Defines the build configuration for compiling the D-FAST Bank Erosion project as the main distribution (without a command window).</p> <p>Key Features: - Uses the Poetry template for environment setup. - Executes the <code>BuildDfastbe_no_command_window.bat</code> script via Poetry. - Produces zipped distribution artifacts. - Fails the build on <code>AssertionError</code> in logs.</p>"},{"location":"guides/teamcity-ci.html#5-build_terminalkt","title":"5. <code>build_terminal.kt</code>","text":"<p>Purpose: Defines the build configuration for compiling the D-FAST Bank Erosion project with a command window (for debugging).</p> <p>Key Features: - Uses the Poetry template for environment setup. - Executes the <code>BuildDfastbe.bat</code> script via Poetry. - Produces zipped distribution artifacts. - Fails the build on <code>AssertionError</code> in logs. - Has a build timeout and artifact size checks.</p>"},{"location":"guides/teamcity-ci.html#6-latex_manualkt","title":"6. <code>latex_manual.kt</code>","text":"<p>Purpose: Defines a build configuration for generating LaTeX-based documentation for the project.</p> <p>Key Features: - Runs scripts to generate user manual, technical reference, and release notes using LaTeX and BibTeX. - Produces PDF and log artifacts. - Fails the build if documentation generation fails. - Publishes commit statuses to GitHub.</p>"},{"location":"guides/teamcity-ci.html#7-signed_releasekt","title":"7. <code>signed_release.kt</code>","text":"<p>Purpose: Defines a build configuration for collecting and packaging the signed release of the D-FAST Bank Erosion project.</p> <p>Key Features: - Collects artifacts from the main and terminal builds, as well as from signing dependencies. - Produces a signed release zip artifact. - Runs only on Windows agents.</p>"},{"location":"guides/teamcity-ci.html#8-signed_release_terminalkt","title":"8. <code>signed_release_terminal.kt</code>","text":"<p>Purpose: Defines a build configuration for collecting the signed release with a command window for debugging.</p> <p>Key Features: - Collects artifacts from the terminal build and signing dependencies. - Produces a signed release zip artifact. - Runs only on Windows agents.</p>"},{"location":"guides/teamcity-ci.html#9-test_binarieskt","title":"9. <code>test_binaries.kt</code>","text":"<p>Purpose: Defines a build configuration for running distribution tests on the built binaries.</p> <p>Key Features: - Uses the Poetry template for environment setup. - Runs tests on the distributed binaries. - Publishes commit statuses to GitHub. - Triggers on VCS changes in production environment. - Depends on the signed release with command window.</p>"},{"location":"guides/teamcity-ci.html#10-pomxml","title":"10. <code>pom.xml</code>","text":"<p>Purpose: Defines the Maven project configuration for the D-FAST Bank Erosion project (legacy or for Java-based tools).</p> <p>Key Features: - Specifies project metadata and dependencies. - May be used for integration with Java-based tools or legacy build steps.</p>"},{"location":"guides/teamcity-ci.html#additional-notes","title":"Additional Notes","text":"<ul> <li>All builds are now based on Poetry for Python dependency and environment management.</li> <li>The build pipeline is modular, with clear separation between testing, building, documentation, signing, and distribution testing.</li> <li>Commit status publishing and clean workspace features are enabled for quality and traceability.</li> <li>The configuration is designed for Windows build agents and expects a valid Python path and Poetry installation.</li> </ul>"},{"location":"guides/testing.html","title":"Naming conventions","text":""},{"location":"guides/testing.html#test-files","title":"Test Files","text":"<ul> <li>all test files should start with <code>test_</code>, and use snake case naming convention (i.e. <code>test_my_functionality.py</code>).</li> </ul>"},{"location":"guides/testing.html#test-functions","title":"Test Functions","text":"<ul> <li>all test functions should start with <code>test_</code>, and use snake case naming convention. <pre><code>def test_my_functionality():\n    # Test code here\n    pass\n</code></pre></li> </ul>"},{"location":"guides/testing.html#test-classes","title":"Test Classes","text":"<ul> <li>all test classes should start with <code>Test</code>, and use CamelCase naming convention. <pre><code>class TestMyFunctionality:\n    def test_my_functionality(self):\n        # Test code here\n        pass\n</code></pre></li> </ul>"},{"location":"guides/testing.html#docstring-convention-for-tests","title":"Docstring Convention for tests","text":"<p>All pytest test functions and classes in D-FAST Bank Erosion should include a clear and structured docstring describing the purpose and behavior of the test. The recommended format includes the following sections:</p>"},{"location":"guides/testing.html#example-docstring-structure","title":"Example Docstring Structure","text":"<pre><code>def test_my_functionality():\n    \"\"\"\n    Brief description of what the test covers.\n\n    Args:\n        param1 (Type): Description of the parameter.\n        param2 (Type): Description of the parameter.\n\n    Mocks:\n        - Description of any objects, functions, or modules that are mocked in the test.\n        - Example: Mocked database connection to avoid real I/O.\n\n    Asserts:\n        - Description of what is being asserted or validated in the test.\n        - Example: Asserts that the output matches the expected result.\n    \"\"\"\n    # Test code here\n    pass\n</code></pre>"},{"location":"guides/testing.html#guidelines","title":"Guidelines","text":"<ul> <li>Description: Start with a concise summary of what the test is verifying.</li> <li>Args: List and describe any parameters used in the test (optional for simple tests).</li> <li>Mocks: Clearly state what is mocked, why, and how it affects the test.</li> <li>Asserts: Explicitly describe what the test is asserting, including expected outcomes or behaviors.</li> </ul> <p>This convention helps maintain clarity, consistency, and traceability in the test suite, making it easier for contributors to understand the intent and coverage of each test.</p>"},{"location":"guides/testing.html#binaries","title":"Binaries","text":""},{"location":"guides/testing.html#creating-tests-for-the-binaries","title":"Creating tests for the binaries","text":"<ul> <li>all tests that are using the binaries are located in <code>tests/test_binaries</code>.</li> <li>The binaries are being built in teamcity in the following directory <pre><code>from pathlib import Path\nrepo_root = Path(__file__).resolve().parent.parent.parent\nexe_path = repo_root / \"dfastbe.dist/dfastbe.exe\"\n</code></pre></li> <li>Use the above path to trigger the binaries in any test.</li> <li>any test in the <code>tests/test_binaries</code> directory have to be marked with the following pytest marker. <pre><code>import pytest\n@pytest.mark.binaries\ndef test_my_functionality():\n    # Test code here\n    pass\n</code></pre></li> </ul>"},{"location":"guides/testing.html#teamcity-pipelines","title":"Teamcity Pipelines","text":"<p>The team city pipelines have hard coded steps that locate the dfast built binaries, and also hard coded steps to trigger the tests. This is a work in progress. - The build step that triggers testing the binaries uses the following command <pre><code>pytest -v tests/test_binaries/ --no-cov\n</code></pre> - While the unit tests pipeline uses the <code>binaries</code> pytest marker to not run the tests that uses the binaries. - So not marking any binary test with the <code>binaries</code> marker will break the unit tests pipeline. <pre><code>pytest --junitxml=\"report.xml\" --cov=%COVERAGE_LOC% --cov-report=xml tests/ -m \"not binaries\"\n</code></pre></p>"}]}